<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Posts on 超级阵雨</title>
        <link>https://zhenyu0324.github.io/post/</link>
        <description>Recent content in Posts on 超级阵雨</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <copyright>超级阵雨工作室</copyright>
        <lastBuildDate>Sat, 13 Aug 2022 10:59:54 +0800</lastBuildDate><atom:link href="https://zhenyu0324.github.io/post/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>浅谈网关及其应用-上</title>
        <link>https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/</link>
        <pubDate>Sat, 13 Aug 2022 10:59:54 +0800</pubDate>
        
        <guid>https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/</guid>
        <description>&lt;h1 id=&#34;网关概述&#34;&gt;网关概述
&lt;/h1&gt;&lt;h2 id=&#34;什么是网关&#34;&gt;什么是网关
&lt;/h2&gt;&lt;p&gt;网关（Gateway）这个词我们应该都很熟悉了，它在计算机科学中，尤其是计算机网络中十分常见，主要是用来表示位于内部区域边缘，与外界进行交互的某个物理或逻辑设备，比如你家里的路由器就属于家庭内网与互联网之间的网关。&lt;/p&gt;
&lt;p&gt;在实际使用中，通常把网关分为两类：流量网关与业务网关。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;流量网关&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;流量网关,顾名思义就是控制流量进入集群的网关,有很多工作需要在这一步做,对于一个服务集群,势必有很多非法的请求或者无效的请求,这时候要将请求拒之门外,降低集群的流量压力。&lt;/p&gt;
&lt;p&gt;定义全局性的、跟具体的后端业务应用和服务完全无关的策略网关就是上图所示的架构模型——流量网关。流量网关通常只专注于全局的Api管理策略，比如全局流量监控、日志记录、全局限流、黑白名单控制、接入请求到业务系统的负载均衡等，有点类似防火墙。Kong 就是典型的流量网关。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;业务网关&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;当一个单体应用被拆分成许许多多的微服务应用后，也带来了一些问题。一些与业务非强相关的功能，比如权限控制、日志输出、数据加密、熔断限流等，每个微服务应用都需要，因此存在着大量重复的代码实现。而且由于系统的迭代、人员的更替，各个微服务中这些功能的实现细节出现了较大的差异，导致维护成本变高。另一方面，原先单体应用下非常容易做的接口管理，在服务拆分后没有了一个集中管理的地方，无法统计已存在哪些接口、接口定义是什么、运行状态如何。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;网关就是为了解决上述问题。作为微服务体系中的核心基础设施，一般需要具备接口管理、协议适配、熔断限流、安全防护等功能，各种开源的网关产品（比如 zuul）都提供了优秀高可扩展性的架构、可以很方便的实现我们需要的一些功能、比如鉴权、日志监控、熔断限流等。&lt;/p&gt;
&lt;p&gt;与流量网关相对应的就是业务网关,业务网关更靠近我们的业务,也就是与服务器应用层打交道,那么有很多应用层需要考虑的事情就可以依托业务网关,例如在线程模型、协议适配、熔断限流，服务编排等。&lt;/p&gt;
&lt;p&gt;目前业务网关比较成熟的 API 网关框架产品有三个 分别是:Zuul1、Zuul2 和 SpringCloud Gateway&lt;/p&gt;
&lt;p&gt;我们可以通过下图来加深对二者的认知。
&lt;img src=&#34;https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/01.jpeg&#34;
	width=&#34;640&#34;
	height=&#34;333&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/01_hu_1d3f5ef0b2341b4c.jpeg 480w, https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/01_hu_2a473a65a850bce7.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;192&#34;
		data-flex-basis=&#34;461px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;这张图展示了一个多层 Gateway 架构，其中有一个总的 Gateway 接入所有的流量(流量网关)，并分发给不同的子系统，还有第二级 Gateway 用于做各个子系统的接入 Gateway(业务网关)。可以看到，网关所管理的服务力度可粗可细。通过网关，我们可以把分布式架构组织成一个星型架构，由网络对服务的请求进行路由和分发。&lt;/p&gt;
&lt;p&gt;有时候我们也会模糊流量网关和业务网关，让一个网关承担所有的工作,所以这两者之间并没有严格的界线。&lt;/p&gt;
&lt;h2 id=&#34;业务网关概述&#34;&gt;业务网关概述
&lt;/h2&gt;&lt;h3 id=&#34;什么是业务网关&#34;&gt;什么是业务网关
&lt;/h3&gt;&lt;p&gt;网关的角色是作为一个 API 架构，用来&lt;strong&gt;保护、增强和控制&lt;/strong&gt;对于 API 服务的访问。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;API 网关是一个处于应用程序或服务（提供 REST API 接口服务）之前的系统，用来管理授权、访问控制和流量限制等，这样 REST API 接口服务就被 API 网关保护起来，对所有的调用者透明。因此，隐藏在 业务网关后面的业务系统就可以专注于创建和管理服务，而不用去处理这些策略性的基础设施。&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;通俗的说业务网关中就是做一些通用的基础设施功能。类似AOP中的横切关注点概念，把业务系统中涉及的一些通用功能（日志分析、鉴权、路由等）抽取到业务网关中统一管理。业务 网关不是一个典型的业务系统， 而是一个为了让业务系统更专注与业务服务本身，给API服务提供更多附加能力的一个中间层。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;为什么需要业务网关&#34;&gt;为什么需要业务网关
&lt;/h3&gt;&lt;p&gt;在微服务架构中，服务的粒度被进一步细分，各个业务服务可以被独立的设计、开发、测试、部署和管理。各个独立部署单元可以用不同的开发测试团队维护，可以使用不同的编程语言和技术平台进行设计，这就要求必须使用一种语言和平台无关的服务协议作为各个单元间的通讯方式。&lt;/p&gt;
&lt;p&gt;业务网关作为分散在各个业务系统微服务的 API 聚合点和统一接入点，外部请求通过访问这个接入点，即可访问内部所有的 REST API 服务。&lt;/p&gt;
&lt;h3 id=&#34;业务网关的职能&#34;&gt;业务网关的职能
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;请求接入&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作为所有 API 接口服务请求的接入点，管理所有的接入请求&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;业务聚合&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作为所有后端业务服务的聚合点，所有的业务服务都可以在这里被调用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;中介策略&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实现安全、验证、路由、过滤、流控，缓存等策略，进行一些必要的中介处理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;统一管理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;提供配置管理工具，对所有 API 服务的调用生命周期和相应的中介策略进行统一管理。&lt;/p&gt;
&lt;h2 id=&#34;开源网关介绍&#34;&gt;开源网关介绍
&lt;/h2&gt;&lt;p&gt;目前常见的开源网关大致上按照语言分类有如下几类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Nginx+lua&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Open Resty、Kong、Orange、Abtesting gateway&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Go&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Janus、fagongzi、Grpc-gateway&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Java&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Zuul/Zuul2、Spring Cloud Gateway、Kaazing KWG、gravitee、Dromara soul 等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NodeJS&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Express Gateway、Micro Gateway&lt;/p&gt;
&lt;p&gt;按照使用数量、成熟度等来划分，主流的有 4 个：&lt;/p&gt;
&lt;p&gt;OpenResty 、Kong、 Zuul/Zuul2、 Spring Cloud Gateway&lt;/p&gt;
&lt;h3 id=&#34;zuulzuul2&#34;&gt;Zuul/Zuul2
&lt;/h3&gt;&lt;p&gt;项目地址：github.com/Netflix/zuul&lt;/p&gt;
&lt;p&gt;Zuul 是 Netflix 开源的 API 网关系统，它的主要设计目标是动态路由、监控、弹性和安全。&lt;/p&gt;
&lt;p&gt;Zuul 的内部原理可以简单看做是很多不同功能 filter 的集合。Zuul 1.x 基于同步 IO，也是 Spring Cloud 全家桶的一部分，可以方便的配合 Spring Boot/Spring Cloud 配置和使用。&lt;/p&gt;
&lt;h3 id=&#34;spring-cloud-gateway&#34;&gt;Spring Cloud Gateway
&lt;/h3&gt;&lt;p&gt;项目地址：
github.com/spring-cloud/spring-cloud-gateway/&lt;/p&gt;
&lt;p&gt;Spring Cloud Gateway 基于 Java 8、Spring 5.0、Spring Boot 2.0、Project Reactor，发展的比 Zuul 2 要早，目前也是 Spring Cloud 全家桶的一部分。&lt;/p&gt;
&lt;p&gt;Spring Cloud Gateway 可以看做是一个 Zuul 1.x 的升级版和代替品，比 Zuul 2 更早的使用 Netty 实现异步 IO，从而实现了一个简单、比 Zuul 1.x 更高效的、与 Spring Cloud 紧密配合的 API 网关。&lt;/p&gt;
&lt;p&gt;Spring cloud Gateway 的几个核心概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;路由&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;网关最基础的部分，路由信息由一个ID、一个目的URL、一组断言和一组Filter组成。当断言为真，则说明请求的URL和配置匹配。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;断言&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作为路由的匹配条件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;过滤器&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;过滤器Fliter 会对请求和响应进行修改处理&lt;/p&gt;
&lt;h2 id=&#34;spring-cloud-gateway-介绍及使用案例&#34;&gt;Spring Cloud Gateway 介绍及使用案例
&lt;/h2&gt;&lt;h3 id=&#34;spring-cloud-gateway-1&#34;&gt;Spring Cloud Gateway
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Spring Cloud Gateway 是由 WebFlux + Netty + Reactor 实现的响应式的 API 网关。&lt;/li&gt;
&lt;li&gt;Spring Cloud Gateway 不能在传统的 servlet 容器中工作，也不能构建成 war 包！&lt;/li&gt;
&lt;li&gt;Spring Cloud Gateway 为微服务架构提供一种简单且有效的 API 路由的管理方式，并基于 Filter 的方式提供网关的基本功能，例如说安全认证、监控、限流等等&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意：Spring Cloud Gateway会和spring-webmvc的依赖冲突，需要排除spring-webmvc&lt;/p&gt;
&lt;h3 id=&#34;spring-cloud-gateway核心概念&#34;&gt;Spring Cloud Gateway核心概念
&lt;/h3&gt;&lt;h4 id=&#34;路由route&#34;&gt;路由（route)
&lt;/h4&gt;&lt;p&gt;路由是网关中最基础的部分，路由信息包括一个ID、一个目的URI、一组断言工厂、一组Filter组成。如果断言为真，则说明请求的URL和配置的路由匹配。&lt;/p&gt;
&lt;h4 id=&#34;断言predicates&#34;&gt;断言(predicates)
&lt;/h4&gt;&lt;p&gt;Java8中的断言函数，SpringCloud Gateway中的断言函数类型是Spring5.0框架中的ServerWebExchange。断言函数允许开发者去定义匹配Http request中的任何信息，比如请求头和参数等。&lt;/p&gt;
&lt;h4 id=&#34;过滤器filter&#34;&gt;过滤器（Filter)
&lt;/h4&gt;&lt;p&gt;SpringCloud Gateway中的filter分为Gateway FilIer和Global Filter。Filter可以对请求和响应进行处理。&lt;/p&gt;
&lt;h3 id=&#34;spring-cloud-gateway如何工作&#34;&gt;Spring Cloud Gateway如何工作
&lt;/h3&gt;&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/02.jpeg&#34;
	width=&#34;924&#34;
	height=&#34;1264&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/02_hu_563e81a1b27f0676.jpeg 480w, https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/02_hu_bbc8cdc97470dc1a.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;73&#34;
		data-flex-basis=&#34;175px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;使用案例介绍&#34;&gt;使用案例介绍
&lt;/h3&gt;&lt;p&gt;我们在本地模拟一个简单的网关使用场景：通过网关查询 微服务【订单服务】的一个接口。业务架构大致如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/03.jpeg&#34;
	width=&#34;1292&#34;
	height=&#34;754&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/03_hu_b4445d50763fd4aa.jpeg 480w, https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/03_hu_34a5ae6214302ffd.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;171&#34;
		data-flex-basis=&#34;411px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;需要部署三个服务在本地，分别是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;eureka负载均衡器[eureka]&lt;/li&gt;
&lt;li&gt;网关[gateway]&lt;/li&gt;
&lt;li&gt;微服务[zhenyu-order]&lt;/li&gt;
&lt;/ol&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;序号&lt;/th&gt;
          &lt;th&gt;服务名称&lt;/th&gt;
          &lt;th&gt;端口号&lt;/th&gt;
          &lt;th&gt;备注&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;1&lt;/td&gt;
          &lt;td&gt;eurka-server&lt;/td&gt;
          &lt;td&gt;8761&lt;/td&gt;
          &lt;td&gt;eureka服务&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;2&lt;/td&gt;
          &lt;td&gt;service-gateway&lt;/td&gt;
          &lt;td&gt;80&lt;/td&gt;
          &lt;td&gt;网关服务&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;3&lt;/td&gt;
          &lt;td&gt;zhenyu-order&lt;/td&gt;
          &lt;td&gt;8081&lt;/td&gt;
          &lt;td&gt;微服务-订单&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;首先，我们搭建一个Eureka 服务，作为服务注册与发现的负载均衡器。
其次，分别在本地启动网关服务于微服务应用，启动完毕后，可以在eureka页面发现当前应用如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/04.jpeg&#34;
	width=&#34;2788&#34;
	height=&#34;1226&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/04_hu_4c23aa216537b4dd.jpeg 480w, https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/04_hu_8861cf6cc276df12.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;227&#34;
		data-flex-basis=&#34;545px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;网关的配置路由规则如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; routes:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        - id: zhenyu-order
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          uri: lb://zhenyu-order
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          predicates:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            - Path=/zhenyu-order/hello
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          filters:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            - StripPrefix=1
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在微服务【zhenyu-order】应用中，增加一个接口，实现如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;@GetMapping(&amp;#34;/queryOrder&amp;#34;)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    public String queryOrder(@RequestParam String orderNo) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        return &amp;#34;hello, 当前订单号：&amp;#34; + orderNo;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;重新部署服务后，访问网关地址：
&lt;code&gt;http://localhost/zhenyu-order/queryOrder?orderNo=ABC&lt;/code&gt;
访问结果如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/05.jpeg&#34;
	width=&#34;2210&#34;
	height=&#34;358&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/05_hu_8d7d5b53e022df1e.jpeg 480w, https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/05_hu_c163610868470d32.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;617&#34;
		data-flex-basis=&#34;1481px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;spring-cloud-gateway-窥探技术原理&#34;&gt;Spring Cloud Gateway 窥探技术原理
&lt;/h2&gt;&lt;h3 id=&#34;路由&#34;&gt;路由
&lt;/h3&gt;&lt;p&gt;在上面的示例中，我们看到一组路由有以下几个组成部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ID、目标URI&lt;/li&gt;
&lt;li&gt;一系列的断言【Predicate】&lt;/li&gt;
&lt;li&gt;过滤器【Filters】&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/06.jpeg&#34;
	width=&#34;1249&#34;
	height=&#34;588&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/06_hu_fe1aa56617077bdc.jpeg 480w, https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/06_hu_962d6f1dbed28129.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;212&#34;
		data-flex-basis=&#34;509px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;web 请求，通过一些匹配条件，定位到真正的服务节点，并在这个转发过程的前后，进行一些精细化控制&lt;/p&gt;
&lt;p&gt;predicate 就是我们的匹配条件&lt;/p&gt;
&lt;p&gt;filter：就可以理解为一个无所不能的拦截器，有了这两个元素，再加上目标的uri，就可以实现一个具体的路由了。&lt;/p&gt;
&lt;h4 id=&#34;predicate-断言条件转发规则介绍&#34;&gt;Predicate 断言条件(转发规则)介绍
&lt;/h4&gt;&lt;p&gt;Predicate 来源于 Java 8，是 Java 8 中引入的一个函数，Predicate 接受一个输入参数，返回一个布尔值结果。该接口包含多种默认方法来将 Predicate 组合成其他复杂的逻辑（比如：与，或，非）。可以用于接口请求参数校验、判断新老数据是否有变化需要进行更新操作。&lt;/p&gt;
&lt;p&gt;在 Spring Cloud Gateway 中 Spring 利用 Predicate 的特性实现了各种路由匹配规则，有通过 Header、请求参数等不同的条件来进行作为条件匹配到对应的路由。网上有一张图总结了 Spring Cloud 内置的几种 Predicate 的实现。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/07.jpeg&#34;
	width=&#34;692&#34;
	height=&#34;361&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/07_hu_58a6e0785015eb5e.jpeg 480w, https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/07_hu_ea85898cc15342.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;191&#34;
		data-flex-basis=&#34;460px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;从官方文档来看，Spring Cloud GateWay 内置了11种断言方式，具体可见下方链接。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.spring.io/spring-cloud-gateway/docs/3.0.1/reference/html/#gateway-request-predicates-factories&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;spring-cloud-gateway 官方文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/08.jpeg&#34;
	width=&#34;2772&#34;
	height=&#34;1366&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/08_hu_240c6e6fd16f2f93.jpeg 480w, https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/08_hu_787ab688897d0be4.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;202&#34;
		data-flex-basis=&#34;487px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;我们从中选取几种作为示例&lt;/p&gt;
&lt;h5 id=&#34;通过请求参数匹配&#34;&gt;通过请求参数匹配
&lt;/h5&gt;&lt;p&gt;配置如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;spring:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  cloud:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    gateway:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      routes:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        - id: query_route
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          predicates:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            - Query=foo, ba.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          uri: http://www.csdn.com
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;验证结果如图所示
&lt;img src=&#34;https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/09.jpeg&#34;
	width=&#34;1452&#34;
	height=&#34;1400&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/09_hu_a9377221300f06f9.jpeg 480w, https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/09_hu_3953c9e606af7718.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;103&#34;
		data-flex-basis=&#34;248px&#34;
	
&gt;&lt;/p&gt;
&lt;h5 id=&#34;通过请求路径匹配匹配&#34;&gt;通过请求路径匹配匹配
&lt;/h5&gt;&lt;p&gt;配置如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;spring:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  cloud:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    gateway:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      routes:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        - id: baidu
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          predicates:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            - Path=/baidu
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          uri: http://www.baidu.com
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;验证结果如图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/10.jpeg&#34;
	width=&#34;1462&#34;
	height=&#34;1298&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/10_hu_e03657f32caf90fa.jpeg 480w, https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/10_hu_293d671acc962732.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;112&#34;
		data-flex-basis=&#34;270px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;过滤器-globalfilter-vs-gatewayfilter&#34;&gt;过滤器 GlobalFilter vs GatewayFilter
&lt;/h4&gt;&lt;p&gt;在Spring Cloud Gateway 网关中，大量的使用Fliters，主要做一些过滤、拦截、校验、转发、日志等工作。&lt;/p&gt;
&lt;p&gt;Global Filters：全局过滤器，不需要配置路由，系统初始化作用到所有路由上。&lt;/p&gt;
&lt;p&gt;GatewayFilter：需要配置某个路由，才能过滤。如果需要使用全局路由，需要配置Default Filters。&lt;/p&gt;
&lt;h5 id=&#34;globalfilter&#34;&gt;GlobalFilter
&lt;/h5&gt;&lt;p&gt;GlobalFilter 接口和 GatewayFilter 有一样的接口定义，只不过， GlobalFilter 会作用于所有路由。&lt;/p&gt;
&lt;p&gt;官方定义的GlobalFilter接口如图所示，只需要去实现fliter方法即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/11.jpeg&#34;
	width=&#34;1906&#34;
	height=&#34;844&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/11_hu_5cd110fb32fe5e62.jpeg 480w, https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/11_hu_1979f8c6a274b8c1.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;225&#34;
		data-flex-basis=&#34;541px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;单独定义只需要实现GlobalFilter, Ordered这两个接口就可以了。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public class CustomFilter implements GlobalFilter, Ordered {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @Override
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    public Mono&amp;lt;Void&amp;gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        ServerHttpRequest request = exchange.getRequest();
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        System.out.println(&amp;#34;当前访问url:&amp;#34; + request.getURI().getPath());
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        return chain.filter(exchange);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @Override
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    public int getOrder() {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        return 0;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;查看运行效果如下：
&lt;img src=&#34;https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/12.jpeg&#34;
	width=&#34;2552&#34;
	height=&#34;444&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/12_hu_892db83536f9c31c.jpeg 480w, https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/12_hu_ee6aee4868b8bbee.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;574&#34;
		data-flex-basis=&#34;1379px&#34;
	
&gt;&lt;/p&gt;
&lt;h5 id=&#34;gatewayfilter&#34;&gt;GatewayFilter
&lt;/h5&gt;&lt;p&gt;不同于GlobalFilter，GatewayFilter更像是局部过滤器，Spring定义了31种实现，详情可见官方文档&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://docs.spring.io/spring-cloud-gateway/docs/3.0.1/reference/html/#gatewayfilter-factories&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;spring-cloud-gateway 官方文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官方定义的GatewayFilter接口如图所示，只需要去实现fliter方法即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/13.jpeg&#34;
	width=&#34;2680&#34;
	height=&#34;910&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/13_hu_f103df7258155b17.jpeg 480w, https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/13_hu_c3f00eb70e9cdf8a.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;294&#34;
		data-flex-basis=&#34;706px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;我们选取一个常用的 The StripPrefix GatewayFilter 作为示例，配置文件如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;spring:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  cloud:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    gateway:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      routes:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      - id: nameRoot
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        uri: https://nameservice
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        predicates:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        - Path=/name/**
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        filters:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        - StripPrefix=2
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;当形如/name/blue/red的url的请求访问网关的时候，网关访问微服务的请求url 如：nameservice/red，这种过滤器常用来根据url来区分微服务，以求把正确的请求路由到对应的微服务，保障请求可用。&lt;/p&gt;
&lt;h3 id=&#34;spring-cloud-gateway限流&#34;&gt;Spring Cloud Gateway限流
&lt;/h3&gt;&lt;h4 id=&#34;常见的限流处理方式&#34;&gt;常见的限流处理方式
&lt;/h4&gt;&lt;p&gt;在系统中设计限流方案时，有一个问题值得设计者去仔细考虑，当请求者被限流规则拦截之后，我们该如何返回结果。一般我们有下面三种限流的处理方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;拒绝服务&lt;/li&gt;
&lt;li&gt;排队等待&lt;/li&gt;
&lt;li&gt;服务降级&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;最简单的做法是拒绝服务，直接抛出异常，返回错误信息（比如返回 HTTP 状态码 429 Too Many Requests），或者给前端返回 302 重定向到一个错误页面，提示用户资源没有了或稍后再试。但是对于一些比较重要的接口不能直接拒绝，比如秒杀、下单等接口，我们既不希望用户请求太快，也不希望请求失败，这种情况一般会将请求放到一个消息队列中排队等待，消息队列可以起到削峰和限流的作用。第三种处理方式是服务降级，当触发限流条件时，直接返回兜底数据，比如查询商品库存的接口，可以默认返回有货。&lt;/p&gt;
&lt;p&gt;网关作为整个分布式系统的入口，承担了所有的用户请求，所以在网关中进行限流是最合适不过的。网关层限流有时也被称为 接入层限流。&lt;/p&gt;
&lt;h4 id=&#34;常见的限流算法&#34;&gt;常见的限流算法
&lt;/h4&gt;&lt;h5 id=&#34;固定窗口算法fixed-window&#34;&gt;固定窗口算法（Fixed Window）
&lt;/h5&gt;&lt;p&gt;固定窗口算法又叫计数器算法，是一种简单方便的限流算法。主要通过一个支持原子操作的计数器来累计 1 秒内的请求次数，当 1 秒内计数达到限流阈值时触发拒绝策略。每过 1 秒，计数器重置为 0 开始重新计数。&lt;/p&gt;
&lt;p&gt;但是此算法存在一个缺陷：&lt;/p&gt;
&lt;p&gt;假设设置限流为每秒2个访问2次，但是当遇到时间窗口的临界突变时，如 1s 中的后 500 ms 和第 2s 的前 500ms 时，虽然是加起来是 1s 时间，却可以被请求 4 次。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/14.jpeg&#34;
	width=&#34;1080&#34;
	height=&#34;305&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/14_hu_7d73a2cb2329938a.jpeg 480w, https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/14_hu_c74cd35dba890cbb.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;354&#34;
		data-flex-basis=&#34;849px&#34;
	
&gt;&lt;/p&gt;
&lt;h5 id=&#34;滑动窗口算法rolling-window-或-sliding-window&#34;&gt;滑动窗口算法（Rolling Window 或 Sliding Window）
&lt;/h5&gt;&lt;p&gt;我们已经知道固定窗口算法的实现方式以及它所存在的问题，而滑动窗口算法是对固定窗口算法的改进。既然固定窗口算法在遇到时间窗口的临界突变时会有问题，那么我们在遇到下一个时间窗口前也调整时间窗口不就可以了吗？&lt;/p&gt;
&lt;p&gt;下面是滑动窗口的示意图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/15.jpeg&#34;
	width=&#34;1080&#34;
	height=&#34;357&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/15_hu_31d90941fd48a5c8.jpeg 480w, https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/15_hu_affba9b0515c3ab9.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;302&#34;
		data-flex-basis=&#34;726px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;但是，只要有时间窗口的存在，还是有可能发生时间窗口的临界突变问题。&lt;/p&gt;
&lt;h5 id=&#34;漏桶算法leaky-bucket&#34;&gt;漏桶算法（Leaky Bucket）
&lt;/h5&gt;&lt;p&gt;漏桶算法中的漏桶是一个形象的比喻，这里可以用生产者消费者模式进行说明，请求是一个生产者，每一个请求都如一滴水，请求到来后放到一个队列（漏桶）中，而桶底有一个孔，不断的漏出水滴，就如消费者不断的在消费队列中的内容，消费的速率（漏出的速度）等于限流阈值。即假如 QPS  为 2，则每 1s / 2= 500ms 消费一次。漏桶的桶有大小，就如队列的容量，当请求堆积超过指定容量时，会触发拒绝策略。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/16.jpeg&#34;
	width=&#34;1080&#34;
	height=&#34;677&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/16_hu_9008019a3f71b48.jpeg 480w, https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/16_hu_80bade4726cf8bc2.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;159&#34;
		data-flex-basis=&#34;382px&#34;
	
&gt;&lt;/p&gt;
&lt;h5 id=&#34;令牌桶算法token-bucket&#34;&gt;令牌桶算法（Token Bucket）
&lt;/h5&gt;&lt;p&gt;令牌桶算法同样是实现限流是一种常见的思路，最为常用的 Google 的 Java 开发工具包 Guava 中的限流工具类 RateLimiter 就是令牌桶的一个实现。令牌桶的实现思路类似于生产者和消费之间的关系。&lt;/p&gt;
&lt;p&gt;系统服务作为生产者，按照指定频率向桶（容器）中添加令牌，如 QPS 为 2，每 500ms 向桶中添加一个令牌，如果桶中令牌数量达到阈值，则不再添加。&lt;/p&gt;
&lt;p&gt;请求执行作为消费者，每个请求都需要去桶中拿取一个令牌，取到令牌则继续执行；如果桶中无令牌可取，就触发拒绝策略，可以是超时等待，也可以是直接拒绝本次请求，由此达到限流目的。&lt;/p&gt;
&lt;p&gt;下面是令牌桶限流算法示意图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/17.jpeg&#34;
	width=&#34;1080&#34;
	height=&#34;463&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/17_hu_4ce39928360a155f.jpeg 480w, https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/17_hu_be0dcb29b03dc76d.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;233&#34;
		data-flex-basis=&#34;559px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;spring-cloud-gateway-限流实现方式&#34;&gt;Spring Cloud Gateway 限流实现方式
&lt;/h4&gt;&lt;h5 id=&#34;官方实现的限流过滤器&#34;&gt;官方实现的限流过滤器
&lt;/h5&gt;&lt;p&gt;spring cloud gateway里面也提供了一个自实现的限流过滤器&lt;/p&gt;
&lt;p&gt;&lt;code&gt;org.springframework.cloud.gateway.filter.factory.RequestRateLimiterGatewayFilterFactory&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;通过 RequestRateLimiterGatewayFilterFactory ，可以创建一个GatewayFilter的匿名内部类实例，它的内部使用Redis实现限流。限流规则由KeyResolver接口的具体实现类来决定，比如通过IP、url等来进行限流。
参考官方文档示例&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/18.jpeg&#34;
	width=&#34;1828&#34;
	height=&#34;1478&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/18_hu_10961ded4d6dd8e2.jpeg 480w, https://zhenyu0324.github.io/p/%E6%B5%85%E8%B0%88%E7%BD%91%E5%85%B3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8-%E4%B8%8A/18_hu_563b73797889721f.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;123&#34;
		data-flex-basis=&#34;296px&#34;
	
&gt;&lt;/p&gt;
&lt;h5 id=&#34;自定义限流过滤器&#34;&gt;自定义限流过滤器
&lt;/h5&gt;&lt;p&gt;基于GlobalFilter，可以很容易的编写一个全局过滤器来进行限流&lt;/p&gt;
&lt;p&gt;现提供一个基于 Guava的 RateLimiter实现的自定义限流过滤器&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public class MyIpLimitFilter2 implements GlobalFilter, Ordered {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    private static final Cache&amp;lt;String, RateLimiter&amp;gt; RATE_LIMITER_CACHE = CacheBuilder
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            .newBuilder()
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            .maximumSize(2)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            .expireAfterAccess(10, TimeUnit.SECONDS)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            .build();
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    private static final double DEFAULT_PERMITS_PER_SECOND = 1;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @SneakyThrows
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @Override
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    public Mono&amp;lt;Void&amp;gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        log.info(&amp;#34;MyIpLimitFilter2 $ filter start. &amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        String remoteAddr = Objects.requireNonNull(exchange.getRequest().getRemoteAddress()).getAddress().getHostAddress();
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        RateLimiter rateLimiter = RATE_LIMITER_CACHE.get(remoteAddr, () -&amp;gt; RateLimiter.create(DEFAULT_PERMITS_PER_SECOND));
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        if (rateLimiter.tryAcquire()) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            return chain.filter(exchange);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        log.info(&amp;#34;MyIpLimitFilter2 $ filter  本次请求限流.url: {}&amp;#34;,exchange.getRequest().getURI().getRawPath());
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        ServerHttpResponse response = exchange.getResponse();
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        response.setStatusCode(HttpStatus.TOO_MANY_REQUESTS);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        response.getHeaders().add(&amp;#34;Content-Type&amp;#34;, &amp;#34;application/json;charset=UTF-8&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        DataBuffer dataBuffer = response.bufferFactory().wrap(&amp;#34;Too Many Request!!!&amp;#34;.getBytes(StandardCharsets.UTF_8));
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        return response.writeWith(Mono.just(dataBuffer));
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;     }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    @Override
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    public int getOrder() {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        return 2;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
        </item>
        <item>
        <title>如何使用hugo搭建个人静态网站</title>
        <link>https://zhenyu0324.github.io/p/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/</link>
        <pubDate>Tue, 09 Aug 2022 16:19:06 +0800</pubDate>
        
        <guid>https://zhenyu0324.github.io/p/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/</guid>
        <description>&lt;h1 id=&#34;what-is-hugo&#34;&gt;What is Hugo
&lt;/h1&gt;&lt;p&gt;Hugo是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。&lt;/p&gt;
&lt;h1 id=&#34;quick-start&#34;&gt;Quick Start
&lt;/h1&gt;&lt;h2 id=&#34;1安装hugo&#34;&gt;1.安装hugo
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;二进制安装（推荐：简单、快速）
到 Hugo Releases 下载对应的操作系统版本的Hugo二进制文件（hugo或者hugo.exe）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Mac下直接使用 Homebrew 安装：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;brew install hugo
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;源码安装
源码编译安装，首先安装好依赖的工具：&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Git
Mercurial
Go 1.3+ (Go 1.4+ on Windows)
设置好 GOPATH 环境变量，获取源码并编译：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gdscript3&#34; data-lang=&#34;gdscript3&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;$&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;GOPATH&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;HOME&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;go&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;$&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;get&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;github&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;com&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;spf13&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hugo&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;源码会下载到 $GOPATH/src 目录，二进制在 $GOPATH/bin/&lt;/p&gt;
&lt;p&gt;如果需要更新所有Hugo的依赖库，增加 -u 参数：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ go get -u -v github.com/spf13/hugo
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;2生成站点&#34;&gt;2.生成站点
&lt;/h2&gt;&lt;p&gt;使用Hugo快速生成站点，比如希望生成到 /path/to/site 路径：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ hugo new site /path/to/site
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这样就在 /path/to/site 目录里生成了初始站点，进去目录：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ cd /path/to/site
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;站点目录结构：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  ▸ archetypes/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  ▸ content/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  ▸ layouts/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  ▸ static/
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    config.toml
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;3-创建文章&#34;&gt;3. 创建文章
&lt;/h2&gt;&lt;p&gt;创建一个 test 页面：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;$ hugo new post/test.md
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;自动生成到了 content/post/test.md ，打开 test.md 看下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;---
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;title: &amp;#34;Test&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;date: 2022-08-09T16:27:53+08:00
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;draft: true
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;---
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;正文内容
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;编辑文章，内容如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;---
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;title: &amp;#34;Test&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;date: 2022-08-09T16:27:53+08:00
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;draft: true
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;---
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;**这是一个测试的页面**
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;4运行hugo&#34;&gt;4.运行Hugo
&lt;/h2&gt;&lt;p&gt;本地启动 hugo&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;hugo server
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;运行信息如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Start building sites … 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;hugo v0.91.2+extended darwin/amd64 BuildDate=unknown
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;WARN 2022/08/09 16:32:28 The google_news internal template will be removed in a future release. Please remove calls to this template. See https://github.com/gohugoio/hugo/issues/9172 for additional information.
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                   | EN   
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-------------------+------
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  Pages            |  57  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  Paginator pages  |   3  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  Non-page files   | 107  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  Static files     |  41  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  Processed images |   0  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  Aliases          |  15  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  Sitemaps         |   1  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  Cleaned          |   0  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Built in 402 ms
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Watching for changes in /Users/zhenyu/github_blog/blog/{archetypes,content,data,layouts,static,themes}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Watching for config changes in /Users/zhenyu/github_blog/blog/config.toml
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Environment: &amp;#34;development&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Serving pages from memory
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Web Server is available at http://localhost:1313/ (bind address 127.0.0.1)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Press Ctrl+C to stop
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;至此，本地启动成功。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>说透中台--概念篇</title>
        <link>https://zhenyu0324.github.io/p/%E8%AF%B4%E9%80%8F%E4%B8%AD%E5%8F%B0--%E6%A6%82%E5%BF%B5%E7%AF%87/</link>
        <pubDate>Fri, 02 Apr 2021 10:43:46 +0800</pubDate>
        
        <guid>https://zhenyu0324.github.io/p/%E8%AF%B4%E9%80%8F%E4%B8%AD%E5%8F%B0--%E6%A6%82%E5%BF%B5%E7%AF%87/</guid>
        <description>&lt;h1 id=&#34;1来龙去脉中台为什么这么火&#34;&gt;1.来龙去脉：中台为什么这么火？
&lt;/h1&gt;&lt;h2 id=&#34;11-20082015-关键词孕育&#34;&gt;1.1 2008~2015 关键词：孕育
&lt;/h2&gt;&lt;p&gt;中台的兴起，是趋势使然。但中台这个概念，最早被大家关注，一定要算是阿里巴巴提出的中台战略。这不知道你有没有发现，有一个有意思的点，就是为什么我说中台最早被大家关注是因为阿里巴巴，而不直接说中台这个概念就创造于阿里巴巴呢？&lt;/p&gt;
&lt;p&gt;既然我们这个专栏叫作“说透中台”，这里可以多说一点，对于中台这个词，很多人认为是阿里巴巴创造的。但截止目前，业界对这个问题还有一些不同的看法和意见，因为在银行里很早就有前台、中台、后台之分，而且有意思的是，阿里巴巴在 2019 年阿里云峰会上海站时，在介绍阿里巴巴双中台的时候，英文翻译也同样使用了银行里中台的翻译，也就是 Middle Office，但是这个概念是否与银行领域的中台概念相关，目前还没有得到任何阿里巴巴的官方信息可以佐证。&lt;/p&gt;
&lt;p&gt;但对于你我来讲，中台这个词是阿里巴巴创造的，还是确实引用的是银行业已有概念，我认为，并不是那么的重要，我们可以将关注点更多地放在这个概念究竟是什么，究竟又能帮我们些什么。&lt;/p&gt;
&lt;p&gt;而对于阿里巴巴的中台战略，现在业界一般都认为是从 2015 年马云走访 Supercell 开始的。但是我通过关注阿里巴巴对外分享的信息，以及实际和多位阿里巴巴的同学了解之后，了解到这次走访的事件只能算是个引子，阿里巴巴的中台化进程，在这之前就已经开始了。所以，要想真正理解阿里巴巴中台产生的背景和原因，需要回到更早的时候，至少要回到 2008 年。&lt;/p&gt;
&lt;p&gt;因为在 2008 年，随着阿里巴巴战略的调整，天猫顺势而生。但因为其相较于于淘宝，有其自身的特点，所以当时天猫和淘宝就出现了重复建设的问题，也就是现在大家经常提到的烟囱式系统架构。&lt;/p&gt;
&lt;p&gt;烟囱式的系统架构，造成了大量的重复建设和资源浪费，怎么办呢？最自然的想法就是将重复的组织和系统进行整合。正因如此，阿里共享事业部正式诞生，负责将各个前台系统中的公共部分进行平台化改造，经历了一段痛苦的摸索之后，借聚划算爆发的契机，才真正奠定了阿里共享事业部的重要地位，埋下了阿里大中台战略的种子。&lt;/p&gt;
&lt;h2 id=&#34;12-2015-关键词阿里巴巴中台战略诞生&#34;&gt;1.2 2015 关键词：阿里巴巴中台战略诞生
&lt;/h2&gt;&lt;p&gt;历史就像一列行驶在山脊间的列车，一切都在按照既定的方向不紧不慢地向前推进。&lt;/p&gt;
&lt;p&gt;中台这个新物种也正在时间的推进中不断孕育，只在等待一个契机的到来。&lt;/p&gt;
&lt;p&gt;2015 年，终于等来了这个契机。&lt;/p&gt;
&lt;p&gt;接下来就是大家津津乐道的那个故事：在 2015 年，马云带领阿里众高管一起拜访了位于芬兰、号称是世界上最成功的移动游戏公司 Supercell。说起这家公司，你可能会觉得比较陌生，但是提到这个公司开发的游戏，相信你一定有所耳闻，《部落战争》《海岛奇兵》《卡通农场》等等知名的游戏都出于这家游戏公司之手。&lt;/p&gt;
&lt;p&gt;但当时触动马云和阿里高管团队的是，催生了这么多火遍全球游戏的企业，却只有不到 200 名员工。而负责一款游戏的每个团队平均也只有 5 到 7 名团队成员。团队有充分的自由，他们可以自行决定开发什么样的产品，之后就会以最快的速度推出公测版，让市场来评判，来验证产品的好坏。一旦产品不成功，则迅速放弃，此时不但不会有任何惩罚，反而团队会举杯庆祝，之后立即做出调整继续迅速寻找新的方向。&lt;/p&gt;
&lt;p&gt;嗯，是的，这就是典型的精益创业的套路。&lt;/p&gt;
&lt;p&gt;但要想让这个机制得以正常运转，必须有一个前提，就是产品的构建时间要足够短，试错的成本要足够低，这样才能保证团队在大量的试错中，通过不断从失败中学习，持续迭代调整，尽快找到正确的方向，让创新成功的进度条快速前进。&lt;/p&gt;
&lt;p&gt;而背后支撑这个机制得以实现的，就是 Supercell 经过 6 年时间沉淀下来的游戏开发过程中那些公共的、通用的游戏素材和算法。基于这些像乐高积木一样的基础素材和算法，才可以同时支持几个小团队在几周时间内像搭积木一样快速研发出一款新游戏。&lt;/p&gt;
&lt;p&gt;这种方式触动了到访的阿里巴巴高管团队，这种理念与阿里巴巴及业界这么多年一直在尝试和构思的“厚平台，薄应用”架构方向不谋而合。就是这次拜访，坚定了阿里巴巴管理层对于组织架构调整的决心，也加速催化了阿里巴巴中台战略的正式诞生。&lt;/p&gt;
&lt;p&gt;随后不久，在 2015 年 12 月 7 日，时任阿里巴巴集团 CEO 的张勇通过一封内部信说道：“今天起，我们全面启动阿里巴巴集团 2018 年中台战略，构建符合 DT 时代的更创新灵活的‘大中台、小前台’组织机制和业务机制。”&lt;/p&gt;
&lt;p&gt;至此，阿里巴巴中台战略正式诞生，而之前的“厚平台，薄应用”也顺势变成了“大中台，小前台”。&lt;/p&gt;
&lt;p&gt;但当时大家面对的问题和困难也很多，像阿里巴巴或是滴滴出行这类的企业，在分享中台的时候，更多的是以自己发展历程的角度和自己的问题出发。这也毋容置疑，但是大家回头来审视自己企业的中台建设时，每家的情况都不一样，每家的问题也不同，自己的中台到底应该是什么样子？怎么建设？这些问题很多都是在书中、在分享中找不到直接的答案，只能靠自己一点一点摸索。&lt;/p&gt;
&lt;p&gt;至此，一些勇敢的先行者们就开始了各自的中台探索之旅，虽然这注定是一条布满荆棘的道路。&lt;/p&gt;
&lt;p&gt;现在回头再看，有些当时的探索最终失败了，有些探索仍在继续。但无论如何，这些先行者们的探索和经验得失，为我们现在理解和建设中台扫清了很多障碍，没有这些探索和思考，也不会有现在的这些经验与共识。&lt;/p&gt;
&lt;h2 id=&#34;13-2018-关键词全面爆发&#34;&gt;1.3 2018 关键词：全面爆发
&lt;/h2&gt;&lt;p&gt;2018 年年中，中台蓄势已久，终于迎来了全面爆发。&lt;/p&gt;
&lt;p&gt;2018 年 9 月 30 日，腾讯宣布了 7 年来最大规模的组织变革，新成立了云与智慧产业事业群（CSIG）。同时，腾讯新成立了技术委员会，宣布未来将打造技术中台。&lt;/p&gt;
&lt;p&gt;2018 年 11 月 26 日，阿里宣布进行组织升级，阿里云事业群升级为阿里云智能事业群，将中台智能化与阿里云全面结合。&lt;/p&gt;
&lt;p&gt;2018 年 12 月 21 日，京东集团人力资源部发布关于京东商城组织架构调整的公告，公告内容称：“在新的组织架构下，京东商城将围绕以客户为中心，划分为前中后台。中台为前台业务运营和创新提供专业能力的共享平台职能。”&lt;/p&gt;
&lt;p&gt;也正是这一波互联网大厂眼花缭乱的集体操作，纷纷为中台接力发声站台，才正式把中台推上了舞台，迎来了全面爆发。&lt;/p&gt;
&lt;h2 id=&#34;14-2019-迷雾仍然存在&#34;&gt;1.4 2019 迷雾仍然存在
&lt;/h2&gt;&lt;p&gt;中台的热度经过 2018 年底的爆发，延续到 2019 年，并没有消退的迹象，反而越发高涨。&lt;/p&gt;
&lt;p&gt;但爆发归爆发，不代表之前的问题都已经被解决，问题和困惑依然存在，丝毫没有因为概念的火爆而变得清晰，反而随着跟进的企业越来越多，问题不降反增，变得越来越多：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* 中台与平台的区别到底是什么？
* 中台到底有多少种？哪些是哪些不是？有建设顺序么？
* 中台到底怎么建？从哪开始？怎么算结束？
* 中台需要组织调整么？怎么调整？
* 中台如何验证建设效果？
* ……
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而这些问题这几年也一直困扰着我。如今，经过了这么长时间的探索、研究以及向前辈们取经，我也有了一些自己的思考和总结。现在，我把这些内容分享给你，跟你一起探讨这些问题的答案，帮你在自己的中台建设中扫清一些障碍。&lt;/p&gt;
&lt;h2 id=&#34;15-小结&#34;&gt;1.5 小结
&lt;/h2&gt;&lt;p&gt;今天，我带你回顾了中台的发展过程。最后，我们来看看是不是可以回答开篇的那个问题了：中台到底为什么会这么火？&lt;/p&gt;
&lt;p&gt;就像很多趋势不是一股力量形成的，我认为中台的火爆至少是因为以下这四个方面的契机凑在了一起。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;互联网企业的样板效应。这个毋容置疑，在当下，互联网公司，尤其是各个大厂的样板和标杆效应还是非常强的。更何况对于中台这件事情上，互联网企业们的态度又是这么的高度一致，在以往也是很少见的，而建设效果也实实在在被大家看在眼里，让人羡慕不已。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;那互联网企业为什么会这么一致地推动中台呢？背后还有一个更深层次的原因就是今年火爆的产业互联网，在消费互联网阶段的中后期，消费侧的战场日益白热化。互联网企业为了追求持续增长，纷纷将目光转向了供给侧，这就是今年 ToB 也异常火爆的原因。而云和中台战略正是互联网企业进入传统行业的一个非常好的切入点，所以我们看到越来越多的互联网企业参与进传统企业上云和企业数字化转型过程中，把自己的技术和实践带到传统行业，在整个过程中，中台确实是一个很好的抓手和利器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;正所谓一个巴掌拍不响，这个时间点确实也正好匹配到了一些行业从系统化向平台化转型的节点。通过这些年的信息化建设和积累，企业内信息化系统该建的也都建了，什么 ERP、CRM 等，该有的也都有了。信息化建设启动早一些的企业，内部的各个系统也开始出现前面提到的烟囱林立、数据孤岛等痛点。而信息化建设相对晚一些的企业，也正好想通过这波中台浪潮来个弯道超车，一步到位。此时再赶上一阵中台旋风袭来，家家企业都觉得自己有做中台的需求和痛点，开始了自己的中台规划与建设。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最后，我认为还有一点也非常重要，也是底层的原因，就是这两年整体的经济大势并不太好，不确定性和不可预测性正在不断地冲击着各个企业甚至行业，而企业的管理者们对于企业未来发展的恐惧与焦虑倍增。这时候，互联网企业通过中台战略，把能力进行沉淀与复用，用确定性来应对不确定性，拥有快速试错、快速创新的能力和思路，这让传统企业看到了一个突围的方向。经济形势好的时候，大家要么都在忙着快速拓展业务，兵贵神速，怎么快怎么来；要么就是守在自己的成熟业务上，到点收成，也没有很强的动力改变。但经济形势严峻了，压力与恐惧越来越严重了，为了能保持企业未来的生存和可持续发展，或者为下次形势转好继续冲刺做好准备。所以，效仿互联网行业，中台战略也成了越来越多传统企业和行业的选择。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总之所谓天时地利人和，多方的因素聚集在一起也就催生了这波中台热点。而中台的火热到底只是昙花一现？还是像云计算和微服务一样会成为 IT 发展的又一次重要的里程碑？目前仍未成定论，但我个人更相信后者会有非常大的可能性。&lt;/p&gt;
&lt;h1 id=&#34;2-中台种类你听说的中台真的是中台吗&#34;&gt;2. 中台种类：你听说的中台真的是中台吗？
&lt;/h1&gt;&lt;p&gt;上一讲我带着你一起重走了近十年的中台发展之路，从时间的维度了解了中台发展的背景，也帮你分析了中台兴起背后的一些原因。&lt;/p&gt;
&lt;p&gt;不过最后的时候我们聊到，直到目前，中台的概念仍然存在着很多迷雾，中台到底是什么？中台到底该长什么样子？有哪些种类？对企业到底有什么价值？我需不需要建中台？这些问题在你心中可能仍然没有确切的答案。&lt;/p&gt;
&lt;p&gt;今天我就带你一起看一看，截至目前出现过的一些不同种类的中台，看看从这些看似不同种类的中台背后，我们能不能找到一些共同的特点。下一讲我会带你一起来探寻中台的本质，来解答你心中的疑惑。&lt;/p&gt;
&lt;p&gt;至于中台的分类，我把目前出现的这些中台分为“主流”和“非主流”两类，下面就带你一一来看。&lt;/p&gt;
&lt;h2 id=&#34;21-主流代表业务数据双中台&#34;&gt;2.1 主流代表：业务数据双中台
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/%E8%AF%B4%E9%80%8F%E4%B8%AD%E5%8F%B0--%E6%A6%82%E5%BF%B5%E7%AF%87/01.jpg&#34;
	width=&#34;1317&#34;
	height=&#34;687&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/%E8%AF%B4%E9%80%8F%E4%B8%AD%E5%8F%B0--%E6%A6%82%E5%BF%B5%E7%AF%87/01_hu_f720ff6f7dd594d6.jpg 480w, https://zhenyu0324.github.io/p/%E8%AF%B4%E9%80%8F%E4%B8%AD%E5%8F%B0--%E6%A6%82%E5%BF%B5%E7%AF%87/01_hu_5a635676cc45f1b8.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;191&#34;
		data-flex-basis=&#34;460px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;业务中台&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;业务这个词，其实是有些宽泛的，我听到很多人口中说的业务都不是一个概念。为此，我还特地做了一些功课。业务，更白话一些来说，就是为了售出产品、换取利润，各行业中需要处理的商业上的相关事务。所以在早期我们通常会把于销售叫作业务员。&lt;/p&gt;
&lt;p&gt;网易副总裁汪源就曾在网易云创峰会上提到过：“所有的中台都是业务中台”。对于这个提法，我也是认同的，因为从广义上来看所有的中台，不论是业务中台还是数据中台，亦或其他，都是为业务，为企业可以更好地以更低的成本、更高的质量、更快的响应速度售出产品、换取利润服务的。&lt;/p&gt;
&lt;p&gt;换个角度看，从企业架构的层面看，应用架构、技术架构、数据架构都是要匹配公司的业务架构的，因为“业务”，即售出产品、换取利润是企业的核心目标。&lt;/p&gt;
&lt;p&gt;好，既然所有的中台都是业务中台，那我们经常提到的业务数据双中台中的业务中台，这里的究竟代表的是什么呢？依我来看，我们常提到的业务中台，是狭义层面的业务概念，业务中台需要具体承载支撑业务开展的必要业务元素，封装着为了保障业务可以顺利开展需要解决的必要问题空间的解决方案。&lt;/p&gt;
&lt;p&gt;这么说可能会比较空，我有一个技巧，当我思考业务中台时，我会不断地问自己一个问题：企业的业务能够顺利开展，需要解决哪些核心问题？&lt;/p&gt;
&lt;p&gt;比如电商的场景，如果我是一家电商企业，我业务要顺利开展，即把我的产品卖给用户，换取利润，一般要解决的核心问题无非包含：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;我的用户是谁？从哪里来？
我卖的产品是什么？从哪里来？
怎么让用户知道我卖的产品？
用户为什么会买我卖的产品？
用户怎么买？
货怎么送？
用户怎么退换货？
怎么才能让用户不断地买？
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这些就是一个电商业务能够正常开展所需要解决的最基本最核心的问题，在 DDD（领域驱动设计）中，对于这些企业业务开展需要关注的核心问题空间有个专有名词，就是问题域。大家常说的用户域、订单域等等的叫法也来源于此。&lt;/p&gt;
&lt;p&gt;而对于一家电商企业的不同业务线，大多是因为卖的产品不同，或是卖的区域不同，用户群体不同，但是这些问题也都是要解决的，大多数情况下解决的方法也是相通和类似的。这就是业务中台之所以能够存在的原因。&lt;/p&gt;
&lt;p&gt;所以，我们常提到的业务中台，可以理解成狭义的业务中台，通过将不同业务线解决相同问题域的解决方案进行抽象与封装，通过配置化、插件化、服务化等机制兼顾各条业务线的特性需求，实现对于不同业务线的业务支撑。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/%E8%AF%B4%E9%80%8F%E4%B8%AD%E5%8F%B0--%E6%A6%82%E5%BF%B5%E7%AF%87/02.jpg&#34;
	width=&#34;1920&#34;
	height=&#34;1080&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/%E8%AF%B4%E9%80%8F%E4%B8%AD%E5%8F%B0--%E6%A6%82%E5%BF%B5%E7%AF%87/02_hu_9a196938ed3cb4a8.jpg 480w, https://zhenyu0324.github.io/p/%E8%AF%B4%E9%80%8F%E4%B8%AD%E5%8F%B0--%E6%A6%82%E5%BF%B5%E7%AF%87/02_hu_c9b731b2a5c299dc.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;177&#34;
		data-flex-basis=&#34;426px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据中台&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;讲完了业务中台，我们再来看目前热度最高的数据中台。数据中台为什么这么火热？我总结下来主要是这么几个原因。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;见效快。目前大部分传统企业的问题还在于数据不通，“数据孤岛”现象比较严重，数据中台的建设对于痛点的解决直接，驱动力强。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;组织调整负担小。一般来说，有一定规模的企业都已经有了大数据团队或是 BI 团队，这个团队自然就承载着相关的职能，不需要再做大的组织调整。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有一定技术基础储备。大部分企业都进行了多年的数据仓库建设，或是随着前几年大数据的浪潮，已经构建了多年的大数据技术平台。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;大势所趋。大家都在讲 DT（Data Technology）时代，对于数据的价值，企业的认识也越来越深刻，大家已经意识到数据不再只是一种运营辅助分析的工具，而逐渐成为企业的核心资产和竞争力。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;组织变动小，技术也有了基础，痛点明显，成本低，见效快，又是大势所趋，那么数据中台成为人们关注的热点也就不为怪了。&lt;/p&gt;
&lt;p&gt;但是，既然现在都在提业务数据化，数据业务化，既然两个概念也在相互转化和融合，那数据中台与业务中台之间又是什么关系呢？究竟什么才是数据中台？跟过去建设的数据仓库和大数据平台又有什么区别和联系呢？&lt;/p&gt;
&lt;p&gt;相信，这些也是很多关注数据中台的同学特别在意的问题。&lt;/p&gt;
&lt;p&gt;关于业务中台与数据中台的关系，我比较赞同阿里巴巴技术方案总监谢纯良在一次 InfoQ 采访中提到的观点：“业务中台就是在产生数据，数据中台是做数据的二次加工，并将结果再服务于业务，为业务进行数据和智能的赋能。”&lt;/p&gt;
&lt;p&gt;而对于数据中台与传统数仓和数据平台的区别，关键在于数据中台相对于数仓、大数据平台，向前台、向业务又迈出了一步，不再只是关心技术层面大数据底座的打造，同时开始更多地关注企业层面的数据治理以及数据资产化的内容：包括但不限于数据的资产化管理（质量、成本、安全），数据服务的构建，数据的体系化建设（统一模型和指标）等。&lt;/p&gt;
&lt;p&gt;为了方便理解，在 ThoughtWorks 我们经常把数据中台比喻成一个数据工厂，通过收集到原材料仓库，经过厂房流水线的数据加工，最终作为数据产品进入到产品仓库，通过数据商店，以各种方式（例如数据 API 的方式）对于前台或是业务中台赋能，整个过程通过控制中心进行协调调度。&lt;/p&gt;
&lt;p&gt;这个比喻形象生动地体现了数据中台对于数据的二次加工的过程，同时还描述了通过数据实验室承载为数据赋予智能，通过办公室完成数据的治理与资产化的相关处理。&lt;/p&gt;
&lt;p&gt;介绍完了我们最常见的业务数据双中台，这里做个小结。&lt;/p&gt;
&lt;p&gt;业务中台与数据中台相辅相成，互相支撑，互为输入输出。业务中台承载了企业的通用业务能力，为多业务线赋能；数据中台通过对于业务数据的二次加工，并反馈回业务中台，为业务进行数据和智能方面的赋能。两者的紧密配合一起为企业构建起了商业战场强大的后方炮火群，这也就构成了最著名的业务数据双中台模式。&lt;/p&gt;
&lt;p&gt;##2.2 非主流系列&lt;/p&gt;
&lt;p&gt;在业务数据双中台之外，还出现过各式各样的中台，而这些中台的出现也让原本还比较清晰的中台概念变得有些模糊。那接下来我就快速为你介绍一些这几年我所接触过的中台，在我讲述的过程中，你也可以思考一下，这些中台中哪些是李逵，而哪些是李鬼，谁才真正配得上中台的称号，谁又是来蹭流量的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;技术中台&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除了业务数据双中台，最常被提到，在我看来介于主流和非主流之间的就得属技术中台了。技术中台相比业务中台和数据中台，边界也会更加清晰，简单来讲就是在 CloudNative 下将使用云或其他基础设施的能力、各种技术中间件的能力进行整合和包装。过滤掉技术细节，提供简单一致、易于使用的应用技术基础设施的能力接口，助力前台和业务中台、数据中台的快速建设。不过业界也有说法，认为技术中台没有很强的业务属性，只是一些中间件的集合，顶多算是个中间件平台而已，称不上中台，你怎么看呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;研发中台&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;软件开发是一项工程，涉及到管理、流程、测试、团队协作等等方面。如何将企业的开发流程、最佳实践沉淀成可重用的“能力”，从而助力创新性应用的快速开发迭代，也是我们看到的很多企业正在做的事情，我们可以管这种关注开发效能管理的平台叫作研发中台。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;移动中台&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在移动互联网时代，移动优先的原则已经成为不争的事实，将 App 开发过程中的通用技术组件进行封装沉淀到移动中台中，就可以在构建新的 App 时大量复用已有组件和能力，快速构建和响应。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;管理中台&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最近很多企业开始尝试把中台思维应用到企业内部，重新对“人”“事”“流程”“企业运营”进行平台化 / 中台化改造。试图通过中台化建设，加速企业管理标准化和提升运营能力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;组织中台&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在穆胜老师的书《释放潜能：平台型组织的进化路线图》中，通过分析了海尔平台化组织的演进过程，他提出了组织中台的概念。组织中台很像企业中的内部风投和创新孵化机构，为前台组织和团队构建创新型前台应用提供类似于投资评估（项目甄别）、投资管理、投后管理（孵化与风控），真正从组织和制度上支撑前台组织和应用的快速迭代和规模化创新。&lt;/p&gt;
&lt;h1 id=&#34;3-中台定义当我们谈中台时到底在谈些什么&#34;&gt;3. 中台定义：当我们谈中台时到底在谈些什么？
&lt;/h1&gt;&lt;h2 id=&#34;31-企业为什么要建中台&#34;&gt;3.1 企业为什么要建中台？
&lt;/h2&gt;&lt;p&gt;我们先来看企业为什么要建中台？想要回答这个问题，咱得先解决另一个问题，那就是企业为什么需要平台化？&lt;/p&gt;
&lt;p&gt;企业为什么需要平台化呢？先给我的答案：&lt;/p&gt;
&lt;p&gt;因为在当今这样一个互联网时代，用户才是商业战场的中心，为了快速响应用户的需求，借助平台化的力量可以事半功倍。&lt;/p&gt;
&lt;p&gt;这背后的逻辑很简单，不断地快速响应、探索、挖掘、引领用户的需求，才是企业得以生存和持续发展的关键因素。&lt;/p&gt;
&lt;p&gt;那些真正尊重用户，甚至不惜调整自己、颠覆自己来响应用户的企业，将在这场以用户为中心的商业战争中得以生存和发展。反之，那些在过去的成就上故步自封，存在侥幸心理希望用户会像之前一样继续追随自己的企业，则会被用户淘汰。&lt;/p&gt;
&lt;p&gt;很残酷，但这就是这个时代最基本的的企业生存法则。&lt;/p&gt;
&lt;p&gt;而平台化之所以重要，就是因为在这场以用户为中心的现代商业战争中，它赋予或加强了企业最核心的能力：用户响应力。平台化思想（Platform Thinking）恰好鼓励企业不断抽象沉淀自己核心的底层能力，通过平台化包装，得以更好地赋能前台业务，用底层的确定性来帮助企业应对前台业务以及最终用户需求的不确定性。&lt;/p&gt;
&lt;p&gt;从结果来看，在不确定性当道的当今商业战场，真正的弄潮儿也大多是那些具备平台化思维并很早就开始发力平台建设的企业，这也在一定层面上佐证了平台化对于一家企业的重要性。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/%E8%AF%B4%E9%80%8F%E4%B8%AD%E5%8F%B0--%E6%A6%82%E5%BF%B5%E7%AF%87/03.jpg&#34;
	width=&#34;1920&#34;
	height=&#34;1080&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/%E8%AF%B4%E9%80%8F%E4%B8%AD%E5%8F%B0--%E6%A6%82%E5%BF%B5%E7%AF%87/03_hu_c66d97cf79135c39.jpg 480w, https://zhenyu0324.github.io/p/%E8%AF%B4%E9%80%8F%E4%B8%AD%E5%8F%B0--%E6%A6%82%E5%BF%B5%E7%AF%87/03_hu_eb4eccf22cf89091.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;177&#34;
		data-flex-basis=&#34;426px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;好，现在我们想明白了第一个问题，企业为什么需要平台化。但是平台化并不是一个新概念，很多企业在这个方向上已经做了多年的努力和积淀。那为什么最近几年“中台”这个相对较新的概念又会异军突起？对于企业来讲，传统的“前台 + 后台（或是平台）”的平台化架构为什么不能满足企业的要求呢?&lt;/p&gt;
&lt;p&gt;这就引出了我们的核心问题：企业为什么要建中台？&lt;/p&gt;
&lt;p&gt;同样，先给我的答案：&lt;/p&gt;
&lt;p&gt;中台化是平台化的下一站，是平台不断对于自身治理演进、打破技术边界、逐渐拥抱业务、容纳业务、具备更强的业务属性的过程。中台关注为前台业务赋能，真正为前台而生。&lt;/p&gt;
&lt;p&gt;为了能够更清楚地讲解我的观点，这里需要先定义一下，在今天我们讨论的上下文下，前台和后台分别指什么。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;前台：由各类前台系统组成的前端业务平台。每个前台系统都是一个用户触点，大多是企业最终用户直接使用的系统，是企业与最终用户的交点。例如用户直接使用的网站、手机 App、微信公众号、小程序等都属于前台范畴。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;后台：由后台系统组成的后端支撑平台。每个后台系统一般管理了企业的一类核心资源（数据 + 计算），例如财务系统、产品系统、客户管理系统、仓库物流管理系统等，这类系统构成了企业的后台。（在和很多互联网的朋友聊过之后，在互联网企业很多并没有后台的概念，更多直接使用平台的概念，例如分为前台层和平台层，但位置和作用与传统企业里的后台相似，我这里直接统一使用后台这个概念来代表。）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;定义了前台和后台，我们再回过头来看企业为什么要建中台这个问题。&lt;/p&gt;
&lt;p&gt;我们看到很多企业的后台，在创建之初的目标，并不是主要服务于前台系统的业务创新，而更多的是为了实现后端资源的电子化管理，解决企业管理的效率问题。这类系统要不就是当年花大价钱采购的套装软件，需要每年支付大量的服务费，并且版本有的也已经非常老旧了，定制化困难；要不就是花大价钱自建，年久失修，一身的补丁，同样变更困难，基本改不动了，也是企业所谓的“遗留系统”的重灾区。&lt;/p&gt;
&lt;p&gt;可以这么说，大多数企业已有的后台，要么前台根本就用不了，要么不好用，要么变更速度就根本跟不上前台业务发展的节奏。总结下来就两个字“慢”和“贵”，对业务的响应慢，动不动改个小功能就还要花一大笔钱。&lt;/p&gt;
&lt;p&gt;有人会说了，你不能拿遗留系统说事儿啊，我们可以新建后台系统啊，整个 2.0，问题不就解决了？&lt;/p&gt;
&lt;p&gt;这是一种解决问题的思路，不过就算是新建的后台系统，因为后台管理的往往是企业的关键核心数据，考虑到企业安全、审计、合规、法律等限制，这样的系统也往往⽆法被前台系统直接使用，或是受到各类限制⽆法快速变化，不能⽀持前台快速的业务创新需求。&lt;/p&gt;
&lt;p&gt;此时的前台和后台就像是两个不同转速的齿轮，前台由于要快速响应前端用户的需求，讲究的是快速迭代创新，所以要求转速越快越好；而后台由于面对的是相对稳定的企业核心后端资源，而且往往系统陈旧复杂，甚至还受到法律法规、审计等相关合规约束，一般是追求稳定至上，越稳定越好， 转速也自然是越慢越安全。&lt;/p&gt;
&lt;p&gt;所以，随着企业业务的不断发展，这种“前台 + 后台”的齿轮速率“匹配失衡”的问题就逐步显现出来了。&lt;/p&gt;
&lt;p&gt;企业业务不断发展壮大，后台修改的成本和风险越来越⾼，这就驱使我们尽量保持后台系统的稳定性，但同时还要响应用户持续不断的需求，怎么办？最自然的就是将大量的业务逻辑（业务能力）直接塞到前台系统中，因为前台离用户近，响应也相对快。&lt;/p&gt;
&lt;p&gt;但是这样也是有代价的，这样的后果就是引入重复，同时还导致前台系统不断膨胀，变得臃肿，形成了一个个大泥球的“烟囱式单体应用”。这个局面的结果就是，前台系统的“用户响应力”被渐渐拖垮，用户满意度逐渐降低，企业竞争力也随之不断下降。&lt;/p&gt;
&lt;p&gt;对于这样的问题，Gatner 在 2016 年发布了一份报告 Pace-Layered Application Strategy。报告中给出了一种解决方案，即按照“步速”将企业的应用系统划分为三个层次（正好契合前中后台的三个层次），不同的层次采用完全不同的策略。&lt;/p&gt;
&lt;p&gt;而 Pace-Layered Application Strategy 也为“中台”产生的必然性，提供了理论上的支撑。&lt;/p&gt;
&lt;p&gt;回到之前说的后台与前台的两层架构，如果映射到这个模型上其实就是只有 SOR（后台）与 SOI（前台）的两层应用架构。这样的情况下，我们又要尽力保持后台（SOR）系统的稳定可靠，⼜要前台系统（SOI）能够⼩而美，快速迭代。因此就自然出现了上文提到的“齿轮匹配失衡”的问题，感觉鱼与熊掌不可兼得。&lt;/p&gt;
&lt;p&gt;怎么办？Pace-Layered 中的 SOD 就是答案，它提供了比前台（SOI）更强的稳定性，以及比后台（SOR）更高的灵活性，在稳定与灵活之间寻找到了⼀种美妙的平衡。&lt;/p&gt;
&lt;p&gt;中台就是 SOD。有了这层“中台”，我们既可以将早已臃肿不堪的前台系统中稳定通用的业务能力“沉降”到中台层，为前台减肥，恢复前台的响应力；又可以将后台系统中需要频繁变化或是需要被前台直接使用的业务能力“提取”到中台层，赋予这些业务能力更强的灵活度和更低的变更成本；或者干脆直接对于后台进行中台化改造，通过配置化、自助化、白屏化等形式为后台加速，从而为前台提供更强大、更迅捷、更易用的“能力炮火”支援。&lt;/p&gt;
&lt;p&gt;中台就像是在前台与后台之间添加的⼀组“变速齿轮”，将前台与后台的速率进行匹配，是前台与后台的桥梁和润滑剂。它为前台而生，易于前台使用，将后台资源顺滑地通过前台导流向用户，支撑企业更好地响应用户。&lt;/p&gt;
&lt;p&gt;好了，现在我们可以小结一下，回答企业为什么需要建中台这个问题了。很简单，企业在平台化的过程中，为了能不断地给前台业务提供更好的服务，来支撑企业对于用户的持续响应，增加企业的用户响应力，企业需要构建自己的中台。&lt;/p&gt;
&lt;h2 id=&#34;32-给中台下个定义&#34;&gt;3.2 给中台下个定义
&lt;/h2&gt;&lt;p&gt;讲了这么关于中台的来龙去脉，以及种种表现形式，也讲了我对于企业平台化与中台化的理解，但你可能仍然会觉得比较抽象，所以我想，一定要试着给中台下个定义。&lt;/p&gt;
&lt;p&gt;为什么需要一个定义呢？倒不是因为别的原因，我是觉得需要给自己一把简单的尺子，让我能轻易记住中台的特性，并能用它来快速判断一个所谓的中台是不是满足我对于中台的理解，所以我给中台的定义就是：&lt;/p&gt;
&lt;p&gt;企业级能力复用平台。&lt;/p&gt;
&lt;p&gt;很简单，是不是有点失望？但是为了找到一个我觉得还靠谱的定义，我几乎花了快两年的时间，期间有各种各样的定义曾浮现出来，但至少到目前为止，我觉得只有这个定义最贴切、最简单、也最准确，它能解释几乎所有我碰到的关于中台的问题，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;为什么会有那么多中台？&lt;/li&gt;
&lt;li&gt;中台化与平台化的区别是什么？&lt;/li&gt;
&lt;li&gt;中台化和服务化的区别是什么？&lt;/li&gt;
&lt;li&gt;中台该怎么建设？&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这 9 个字看起来简单，重要的是其背后对“中台”价值的阐释，下面就让我为你一一拆解来看。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;企业级&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;企业级定义了中台的范围。不是说一个企业只能有一个中台，也不代表一个中台就是只能包含一家企业，企业级更多代表的是中台处理的问题在企业级别，即至少包含多条业务线或服务多个前台产品（团队），如果一个中台只为了支持一条业务线或产品线，那就不是中台，即使它用了服务化或是大数据等技术。&lt;/p&gt;
&lt;p&gt;企业级这一点非常非常重要。它让我想清楚了，中台建设的事情并不是一个技术问题，而是一个要上升到企业架构的问题。做中台建设的时候，一定是跳出单条业务线、站在企业整体视角来审视业务全景。&lt;/p&gt;
&lt;p&gt;想清楚了这一点，我对中台的理解就有了一次质的变化，也终于知道为什么一开始用做系统服务化的方式做中台会面临那么多的问题，比如最常见的组织和干系方以及利益再分配的问题。&lt;/p&gt;
&lt;p&gt;从中台的兴起与爆发我们也能看到一个趋势，就是越来越多的企业，无论是想提升自身的运营效率，还是出于业务创新发展的需求，都已经把企业全局视角、跨业务线的能力沉淀，提到了前所未有的战略高度。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;能力&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;提到中台，最常听到的一个词就是“能力”。可能是因为能力这个词足够简单，又有着足够的包容度与宽度。&lt;/p&gt;
&lt;p&gt;能力定义了中台主要承载的对象。&lt;/p&gt;
&lt;p&gt;能力的抽象解释了为什么会有那么多种类中台的存在，也能解释为什么每家企业的中台都不一样，因为不同的企业之所以能够同时存在，就是因为其核心能力不同，可以满足用户不同层面的需求，也就是我们常说的差异化竞争力。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;复用&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;复用定义了中台的核心价值，也承载了上面讲到的从平台化到中台化的演进过程。传统的平台化对于“可复用性”和“易复用性”并没有给予足够的关注，更多关注的是如何消除掉重复的能力建设，既所谓的“去重”。&lt;/p&gt;
&lt;p&gt;但中台的提出和兴起，体现出一种对于前台业务的使用体验更加关注的趋势。让人们通过对于“可复用性”和“易复用性”的关注，将目光更多地从平台内部的建设转换到平台对于前台业务的支撑上。这里有一个从治理到赋能的视角转换，既从“去重”到“复用”的关注上。&lt;/p&gt;
&lt;p&gt;“去重”与“复用”虽然经常一起出现，一起被提及，但是谈论的完全不是一件事情，目的不同，难度也不同。“去重”讲的更多是向后看，是技术驱动的；“复用”讲的更多是向前看，是业务驱动和用户驱动的。而正这个视角的转变，我认为是理解中台概念的关键，所以&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;“复用”是中台更加关注的目标；
“可复用性”和“易复用性”是衡量中台建设好坏的重要指标；
“业务响应力”和“业务满意度”是考核中台建设进度的重要标准。
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这也能解释为什么很多互联网企业，将对于平台的治理，通过业务抽象以及可配置化和白屏化的改造升级，把这个过程称之为对于平台的中台化改造过程。&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;平台&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;平台定义了中台的主要形式。区别于传统应用系统拼凑的方式，中台通过对于更细粒度能力的识别与平台化沉淀，实现企业能力的柔性复用，更好地支撑前台业务，来满足对于业务的快速响应和复用的需求。&lt;/p&gt;
&lt;p&gt;“企业级能力复用平台”这个定义虽然看起来简单，但经过这么长时间对于中台的实践与思考，我觉得这个定义背后所代表的意义是目前对中台价值的最贴切的阐释。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;“企业级”定义了中台的范围，区分开了单系统的服务化与微服务；&lt;/li&gt;
&lt;li&gt;“能力”定义了中台的主要承载对象，能力的抽象解释了各种各样中台的存在；&lt;/li&gt;
&lt;li&gt;“复用”定义了中台的核心价值，传统的平台化对于易复用性和前台的用户体验并没有给予足够的关注，中台的提出和兴起，让人们通过可复用性将目光更多的从平台内部设计转换到平台对于前台业务的支撑上；&lt;/li&gt;
&lt;li&gt;“平台”定义了中台的主要形式，区别于传统的应用系统拼凑的方式，通过对于更细粒度能力的识别与平台化沉淀，实现企业能力的柔性复用，更好地支撑前台业务。&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Java性能调优5</title>
        <link>https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/</link>
        <pubDate>Wed, 03 Mar 2021 12:06:28 +0800</pubDate>
        
        <guid>https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/</guid>
        <description>&lt;h1 id=&#34;1如何写出高性能sql语句&#34;&gt;1.如何写出高性能SQL语句
&lt;/h1&gt;&lt;p&gt;我们知道，应用服务与数据库的交互主要是通过 SQL 语句来实现的。在开发初期，我们更加关注的是使用 SQL 实现业务功能，然而系统上线后，随着生产环境数据的快速增长，之前写的很多 SQL 语句就开始暴露出性能问题。&lt;/p&gt;
&lt;p&gt;在这个阶段中，我们应该尽量避免一些慢 SQL 语句的实现。但话说回来，SQL 语句慢的原因千千万，除了一些常规的慢 SQL 语句可以直接规避，其它的一味去规避也不是办法，我们还要学会如何去分析、定位到其根本原因，并总结一些常用的 SQL 调优方法，以备不时之需。&lt;/p&gt;
&lt;p&gt;那么今天我们就重点看看慢 SQL 语句的几种常见诱因，从这点出发，找到最佳方法，开启高性能 SQL 语句的大门。&lt;/p&gt;
&lt;h2 id=&#34;11-慢-sql-语句的几种常见诱因&#34;&gt;1.1 慢 SQL 语句的几种常见诱因
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;无索引、索引失效导致慢查询&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果在一张几千万数据的表中以一个没有索引的列作为查询条件，大部分情况下查询会非常耗时，这种查询毫无疑问是一个慢 SQL 查询。所以对于大数据量的查询，我们需要建立适合的索引来优化查询。&lt;/p&gt;
&lt;p&gt;虽然我们很多时候建立了索引，但在一些特定的场景下，索引还有可能会失效，所以索引失效也是导致慢查询的主要原因之一&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;锁等待&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们常用的存储引擎有 InnoDB 和 MyISAM，前者支持行锁和表锁，后者只支持表锁。&lt;/p&gt;
&lt;p&gt;如果数据库操作是基于表锁实现的，试想下，如果一张订单表在更新时，需要锁住整张表，那么其它大量数据库操作（包括查询）都将处于等待状态，这将严重影响到系统的并发性能。&lt;/p&gt;
&lt;p&gt;这时，InnoDB 存储引擎支持的行锁更适合高并发场景。但在使用 InnoDB 存储引擎时，我们要特别注意行锁升级为表锁的可能。在批量更新操作时，行锁就很可能会升级为表锁。&lt;/p&gt;
&lt;p&gt;MySQL 认为如果对一张表使用大量行锁，会导致事务执行效率下降，从而可能造成其它事务长时间锁等待和更多的锁冲突问题发生，致使性能严重下降，所以 MySQL 会将行锁升级为表锁。还有，行锁是基于索引加的锁，如果我们在更新操作时，条件索引失效，那么行锁也会升级为表锁。&lt;/p&gt;
&lt;p&gt;因此，基于表锁的数据库操作，会导致 SQL 阻塞等待，从而影响执行速度。在一些更新操作（insert\update\delete）大于或等于读操作的情况下，MySQL 不建议使用 MyISAM 存储引擎。&lt;/p&gt;
&lt;p&gt;除了锁升级之外，行锁相对表锁来说，虽然粒度更细，并发能力提升了，但也带来了新的问题，那就是死锁。因此，在使用行锁时，我们要注意避免死锁。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;不恰当的 SQL 语句
使用不恰当的 SQL 语句也是慢 SQL 最常见的诱因之一。例如，习惯使用 &amp;lt;SELECT &lt;em&gt;&amp;gt;，&amp;lt;SELECT COUNT(&lt;/em&gt;)&amp;gt; SQL 语句，在大数据表中使用 &amp;lt;LIMIT M,N&amp;gt; 分页查询，以及对非索引字段进行排序等等。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;12-优化-sql-语句的步骤&#34;&gt;1.2 优化 SQL 语句的步骤
&lt;/h2&gt;&lt;p&gt;通常，我们在执行一条 SQL 语句时，要想知道这个 SQL 先后查询了哪些表，是否使用了索引，这些数据从哪里获取到，获取到数据遍历了多少行数据等等，我们可以通过 EXPLAIN 命令来查看这些执行信息。这些执行信息被统称为执行计划。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过 EXPLAIN 分析 SQL 执行计划&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;假设现在我们使用 EXPLAIN 命令查看当前 SQL 是否使用了索引，先通过 SQL EXPLAIN 导出相应的执行计划如下：
&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/01.jpeg&#34;
	width=&#34;1974&#34;
	height=&#34;308&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/01_hu_4a3cfb2efb410682.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/01_hu_8f48356a52c3a97d.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;640&#34;
		data-flex-basis=&#34;1538px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;下面对图示中的每一个字段进行一个说明，从中你也能收获到很多零散的知识点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;id：每个执行计划都有一个 id，如果是一个联合查询，这里还将有多个 id。&lt;/li&gt;
&lt;li&gt;select_type：表示 SELECT 查询类型，常见的有 SIMPLE（普通查询，即没有联合查询、子查询）、PRIMARY（主查询）、UNION（UNION 中后面的查询）、SUBQUERY（子查询）等。&lt;/li&gt;
&lt;li&gt;table：当前执行计划查询的表，如果给表起别名了，则显示别名信息。&lt;/li&gt;
&lt;li&gt;partitions：访问的分区表信息。&lt;/li&gt;
&lt;li&gt;type：表示从表中查询到行所执行的方式，查询方式是 SQL 优化中一个很重要的指标，结果值从好到差依次是：system &amp;gt; const &amp;gt; eq_ref &amp;gt; ref &amp;gt; range &amp;gt; index &amp;gt; ALL。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/02.jpeg&#34;
	width=&#34;2240&#34;
	height=&#34;318&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/02_hu_f6beae0f66d75032.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/02_hu_cac629c8e80e6674.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;704&#34;
		data-flex-basis=&#34;1690px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;system/const：表中只有一行数据匹配，此时根据索引查询一次就能找到对应的数据。如果是 B + 树索引，我们知道此时索引构造成了多个层级的树，当查询的索引在树的底层时，查询效率就越低。const 表示此时索引在第一层，只需访问一层便能得到数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/03.jpeg&#34;
	width=&#34;2230&#34;
	height=&#34;352&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/03_hu_5e282e678ced78ff.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/03_hu_f51bba4a17e6b1c2.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;633&#34;
		data-flex-basis=&#34;1520px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;eq_ref：使用唯一索引扫描，常见于多表连接中使用主键和唯一索引作为关联条件。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/04.jpeg&#34;
	width=&#34;2232&#34;
	height=&#34;320&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/04_hu_761bf1a44064637b.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/04_hu_e00ed5884835a2ab.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;697&#34;
		data-flex-basis=&#34;1674px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ref：非唯一索引扫描，还可见于唯一索引最左原则匹配扫描。
&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/05.jpeg&#34;
	width=&#34;2230&#34;
	height=&#34;316&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/05_hu_485e343f93a065c8.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/05_hu_d33d0007f55c67ce.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;705&#34;
		data-flex-basis=&#34;1693px&#34;
	
&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;range：索引范围扫描，比如，&amp;lt;，&amp;gt;，between 等操作。
&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/06.jpeg&#34;
	width=&#34;2224&#34;
	height=&#34;322&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/06_hu_5a56fea10fb9b78d.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/06_hu_2893c57784755e5c.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;690&#34;
		data-flex-basis=&#34;1657px&#34;
	
&gt;
index：索引全表扫描，此时遍历整个索引树。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/07.jpeg&#34;
	width=&#34;2228&#34;
	height=&#34;326&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/07_hu_981451511c3b2cd4.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/07_hu_3b05d3463431d944.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;683&#34;
		data-flex-basis=&#34;1640px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ALL：表示全表扫描，需要遍历全表来找到对应的行。&lt;/li&gt;
&lt;li&gt;possible_keys：可能使用到的索引。&lt;/li&gt;
&lt;li&gt;key：实际使用到的索引。&lt;/li&gt;
&lt;li&gt;key_len：当前使用的索引的长度。&lt;/li&gt;
&lt;li&gt;ref：关联 id 等信息。&lt;/li&gt;
&lt;li&gt;rows：查找到记录所扫描的行数。&lt;/li&gt;
&lt;li&gt;filtered：查找到所需记录占总扫描记录数的比例。&lt;/li&gt;
&lt;li&gt;Extra：额外的信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;通过 Show Profile 分析 SQL 执行性能&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上述通过 EXPLAIN 分析执行计划，仅仅是停留在分析 SQL 的外部的执行情况，如果我们想要深入到 MySQL 内核中，从执行线程的状态和时间来分析的话，这个时候我们就可以选择 Profile。&lt;/p&gt;
&lt;p&gt;Profile 除了可以分析执行线程的状态和时间，还支持进一步选择 ALL、CPU、MEMORY、BLOCK IO、CONTEXT SWITCHES 等类型来查询 SQL 语句在不同系统资源上所消耗的时间。以下是相关命令的注释：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;SHOW PROFILE [type [, type] ... ]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[FOR QUERY n]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[LIMIT row_count [OFFSET offset]]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;type 参数：
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;| ALL：显示所有开销信息
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;| BLOCK IO：阻塞的输入输出次数
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;| CONTEXT SWITCHES：上下文切换相关开销信息
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;| CPU：显示 CPU 的相关开销信息 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;| IPC：接收和发送消息的相关开销信息
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;| MEMORY ：显示内存相关的开销，目前无用
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;| PAGE FAULTS ：显示页面错误相关开销信息
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;| SOURCE ：列出相应操作对应的函数名及其在源码中的调用位置 (行数) 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;| SWAPS：显示 swap 交换次数的相关开销信息
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Show Profiles 只显示最近发给服务器的 SQL 语句，默认情况下是记录最近已执行的 15 条记录，我们可以重新设置 profiling_history_size 增大该存储记录，最大值为 100。&lt;/p&gt;
&lt;h2 id=&#34;13-常用的-sql-优化&#34;&gt;1.3 常用的 SQL 优化
&lt;/h2&gt;&lt;p&gt;在使用一些常规的 SQL 时，如果我们通过一些方法和技巧来优化这些 SQL 的实现，在性能上就会比使用常规通用的实现方式更加优越，甚至可以将 SQL 语句的性能提升到另一个数量级。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;优化分页查询&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通常我们是使用 &amp;lt;LIMIT M,N&amp;gt; + 合适的 order by 来实现分页查询，这种实现方式在没有任何索引条件支持的情况下，需要做大量的文件排序操作（file sort），性能将会非常得糟糕。如果有对应的索引，通常刚开始的分页查询效率会比较理想，但越往后，分页查询的性能就越差。&lt;/p&gt;
&lt;p&gt;这是因为我们在使用 LIMIT 的时候，偏移量 M 在分页越靠后的时候，值就越大，数据库检索的数据也就越多。例如 LIMIT 10000,10 这样的查询，数据库需要查询 10010 条记录，最后返回 10 条记录。也就是说将会有 10000 条记录被查询出来没有被使用到。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;利用子查询优化分页查询&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;以上分页查询的问题在于，我们查询获取的 10020 行数据结果都返回给我们了，我们能否先查询出所需要的 20 行数据中的最小 ID 值，然后通过偏移量返回所需要的 20 行数据给我们呢？我们可以通过索引覆盖扫描，使用子查询的方式来实现分页查询：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-mysql&#34; data-lang=&#34;mysql&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;k&#34;&gt;select&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;from&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;demo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;order&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;where&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;select&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;from&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;demo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;order&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;order&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;by&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;order_no&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;limit&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;limit&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;通过 EXPLAIN 分析可知：子查询遍历索引的范围跟上一个查询差不多，而主查询扫描了更多的行数，但执行时间却减少了，只有 0.004s。这就是因为返回行数只有 20 行了，执行效率得到了明显的提升。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/08.jpeg&#34;
	width=&#34;2034&#34;
	height=&#34;318&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/08_hu_32a8986bc0c92c6c.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/08_hu_df53d49bd907ec8.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;639&#34;
		data-flex-basis=&#34;1535px&#34;
	
&gt;
&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/09.jpeg&#34;
	width=&#34;2070&#34;
	height=&#34;308&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/09_hu_3c7cb0307373a7fd.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/09_hu_4d0236fe87498faf.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;672&#34;
		data-flex-basis=&#34;1612px&#34;
	
&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;优化 SELECT COUNT(*)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;COUNT() 是一个聚合函数，主要用来统计行数，有时候也用来统计某一列的行数量（不统计 NULL 值的行）。我们平时最常用的就是 COUNT(*) 和 COUNT(1) 这两种方式了，其实两者没有明显的区别，在拥有主键的情况下，它们都是利用主键列实现了行数的统计。&lt;/p&gt;
&lt;p&gt;但 COUNT() 函数在 MyISAM 和 InnoDB 存储引擎所执行的原理是不一样的，通常在没有任何查询条件下的 COUNT(*)，MyISAM 的查询速度要明显快于 InnoDB。&lt;/p&gt;
&lt;p&gt;这是因为 MyISAM 存储引擎记录的是整个表的行数，在 COUNT(*) 查询操作时无需遍历表计算，直接获取该值即可。而在 InnoDB 存储引擎中就需要扫描表来统计具体的行数。而当带上 where 条件语句之后，MyISAM 跟 InnoDB 就没有区别了，它们都需要扫描表来进行行数的统计。&lt;/p&gt;
&lt;p&gt;如果对一张大表经常做 SELECT COUNT(*) 操作，这肯定是不明智的。那么我们该如何对大表的 COUNT() 进行优化呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用近似值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有时候某些业务场景并不需要返回一个精确的 COUNT 值，此时我们可以使用近似值来代替。我们可以使用 EXPLAIN 对表进行估算，要知道，执行 EXPLAIN 并不会真正去执行查询，而是返回一个估算的近似值。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;增加汇总统计&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果需要一个精确的 COUNT 值，我们可以额外新增一个汇总统计表或者缓存字段来统计需要的 COUNT 值，这种方式在新增和删除时有一定的成本，但却可以大大提升 COUNT() 的性能。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;优化 SELECT *&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我曾经看过很多同事习惯在只查询一两个字段时，都使用 select * from table where xxx 这样的 SQL 语句，这种写法在特定的环境下会存在一定的性能损耗。&lt;/p&gt;
&lt;p&gt;MySQL 常用的存储引擎有 MyISAM 和 InnoDB，其中 InnoDB 在默认创建主键时会创建主键索引，而主键索引属于聚族索引，即在存储数据时，索引是基于 B + 树构成的，具体的行数据则存储在叶子节点。&lt;/p&gt;
&lt;p&gt;而 MyISAM 默认创建的主键索引、二级索引以及 InnoDB 的二级索引都属于非聚族索引，即在存储数据时，索引是基于 B + 树构成的，而叶子节点存储的是主键值。&lt;/p&gt;
&lt;p&gt;假设我们的订单表是基于 InnoDB 存储引擎创建的，且存在 order_no、status 两列组成的组合索引。此时，我们需要根据订单号查询一张订单表的 status，如果我们使用 select * from order where order_no=&amp;lsquo;xxx’来查询，则先会查询组合索引，通过组合索引获取到主键 ID，再通过主键 ID 去主键索引中获取对应行所有列的值。&lt;/p&gt;
&lt;p&gt;如果我们使用 select order_no, status from order where order_no=&amp;lsquo;xxx’来查询，则只会查询组合索引，通过组合索引获取到对应的 order_no 和 status 的值。&lt;/p&gt;
&lt;h1 id=&#34;2-高并发场景下的数据库事务调优&#34;&gt;2. 高并发场景下的数据库事务调优
&lt;/h1&gt;&lt;p&gt;数据库事务是数据库系统执行过程中的一个逻辑处理单元，保证一个数据库操作要么成功，要么失败。谈到他，就不得不提 ACID 属性了。数据库事务具有以下四个基本属性：原子性（Atomicity）、一致性（Consistent）、隔离性（Isolation）以及持久性（Durable）。正是这些特性，才保证了数据库事务的安全性。而在 MySQL 中，鉴于 MyISAM 存储引擎不支持事务，所以接下来的内容都是在 InnoDB 存储引擎的基础上进行讲解的。&lt;/p&gt;
&lt;p&gt;我们知道，在 Java 并发编程中，可以多线程并发执行程序，然而并发虽然提高了程序的执行效率，却给程序带来了线程安全问题。事务跟多线程一样，为了提高数据库处理事务的吞吐量，数据库同样支持并发事务，而在并发运行中，同样也存在着安全性问题，例如，修改数据丢失，读取数据不一致等。&lt;/p&gt;
&lt;p&gt;在数据库事务中，事务的隔离是解决并发事务问题的关键， 今天我们就重点了解下事务隔离的实现原理，以及如何优化事务隔离带来的性能问题。&lt;/p&gt;
&lt;h2 id=&#34;21-并发事务带来的问题&#34;&gt;2.1 并发事务带来的问题
&lt;/h2&gt;&lt;p&gt;我们可以通过以下几个例子来了解下并发事务带来的几个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;数据丢失
&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/10.jpeg&#34;
	width=&#34;2530&#34;
	height=&#34;384&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/10_hu_d8449eb18bab9678.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/10_hu_d37d46fc2ddbab23.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;658&#34;
		data-flex-basis=&#34;1581px&#34;
	
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;脏读&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/11.jpeg&#34;
	width=&#34;2506&#34;
	height=&#34;384&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/11_hu_d87266ca6a26d000.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/11_hu_f45b48537b55243c.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;652&#34;
		data-flex-basis=&#34;1566px&#34;
	
&gt;
3. 不可重复读&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/12.jpeg&#34;
	width=&#34;2560&#34;
	height=&#34;372&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/12_hu_c7923ef0834f78d0.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/12_hu_b4188499219abfc7.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;688&#34;
		data-flex-basis=&#34;1651px&#34;
	
&gt;
4. 幻读&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/13.jpeg&#34;
	width=&#34;2598&#34;
	height=&#34;374&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/13_hu_4ad8dcc7dbe9b811.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/13_hu_701c28021803815e.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;694&#34;
		data-flex-basis=&#34;1667px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;22-事务隔离解决并发问题&#34;&gt;2.2 事务隔离解决并发问题
&lt;/h2&gt;&lt;p&gt;以上 4 个并发事务带来的问题，其中，数据丢失可以基于数据库中的悲观锁来避免发生，即在查询时通过在事务中使用 select xx for update 语句来实现一个排他锁，保证在该事务结束之前其他事务无法更新该数据。&lt;/p&gt;
&lt;p&gt;当然，我们也可以基于乐观锁来避免，即将某一字段作为版本号，如果更新时的版本号跟之前的版本一致，则更新，否则更新失败。剩下 3 个问题，其实是数据库读一致性造成的，需要数据库提供一定的事务隔离机制来解决。&lt;/p&gt;
&lt;p&gt;我们通过加锁的方式，可以实现不同的事务隔离机制。在了解事务隔离机制之前，我们不妨先来了解下 MySQL 都有哪些锁机制。&lt;/p&gt;
&lt;p&gt;InnoDB 实现了两种类型的锁机制：共享锁（S）和排他锁（X）。共享锁允许一个事务读数据，不允许修改数据，如果其他事务要再对该行加锁，只能加共享锁；排他锁是修改数据时加的锁，可以读取和修改数据，一旦一个事务对该行数据加锁，其他事务将不能再对该数据加任务锁。&lt;/p&gt;
&lt;p&gt;熟悉了以上 InnoDB 行锁的实现原理，我们就可以更清楚地理解下面的内容。&lt;/p&gt;
&lt;p&gt;在操作数据的事务中，不同的锁机制会产生以下几种不同的事务隔离级别，不同的隔离级别分别可以解决并发事务产生的几个问题，对应如下：&lt;/p&gt;
&lt;p&gt;未提交读（Read Uncommitted）：在事务 A 读取数据时，事务 B 读取和修改数据加了共享锁。这种隔离级别，会导致脏读、不可重复读以及幻读。&lt;/p&gt;
&lt;p&gt;已提交读（Read Committed）：在事务 A 读取数据时增加了共享锁，一旦读取，立即释放锁，事务 B 读取修改数据时增加了行级排他锁，直到事务结束才释放锁。也就是说，事务 A 在读取数据时，事务 B 只能读取数据，不能修改。当事务 A 读取到数据后，事务 B 才能修改。这种隔离级别，可以避免脏读，但依然存在不可重复读以及幻读的问题。&lt;/p&gt;
&lt;p&gt;可重复读（Repeatable Read）：在事务 A 读取数据时增加了共享锁，事务结束，才释放锁，事务 B 读取修改数据时增加了行级排他锁，直到事务结束才释放锁。也就是说，事务 A 在没有结束事务时，事务 B 只能读取数据，不能修改。当事务 A 结束事务，事务 B 才能修改。这种隔离级别，可以避免脏读、不可重复读，但依然存在幻读的问题。&lt;/p&gt;
&lt;p&gt;可序列化（Serializable）：在事务 A 读取数据时增加了共享锁，事务结束，才释放锁，事务 B 读取修改数据时增加了表级排他锁，直到事务结束才释放锁。可序列化解决了脏读、不可重复读、幻读等问题，但隔离级别越来越高的同时，并发性会越来越低。&lt;/p&gt;
&lt;p&gt;InnoDB 中的 RC 和 RR 隔离事务是基于多版本并发控制（MVVC）实现高性能事务。一旦数据被加上排他锁，其他事务将无法加入共享锁，且处于阻塞等待状态，如果一张表有大量的请求，这样的性能将是无法支持的。&lt;/p&gt;
&lt;p&gt;MVVC 对普通的 Select 不加锁，如果读取的数据正在执行 Delete 或 Update 操作，这时读取操作不会等待排它锁的释放，而是直接利用 MVVC 读取该行的数据快照（数据快照是指在该行的之前版本的数据，而数据快照的版本是基于 undo 实现的，undo 是用来做事务回滚的，记录了回滚的不同版本的行记录）。MVVC 避免了对数据重复加锁的过程，大大提高了读操作的性能。&lt;/p&gt;
&lt;h2 id=&#34;23-锁具体实现算法&#34;&gt;2.3 锁具体实现算法
&lt;/h2&gt;&lt;p&gt;我们知道，InnoDB 既实现了行锁，也实现了表锁。行锁是通过索引实现的，如果不通过索引条件检索数据，那么 InnoDB 将对表中所有的记录进行加锁，其实就是升级为表锁了。&lt;/p&gt;
&lt;p&gt;行锁的具体实现算法有三种：record lock、gap lock 以及 next-key lock。record lock 是专门对索引项加锁；gap lock 是对索引项之间的间隙加锁；next-key lock 则是前面两种的组合，对索引项以其之间的间隙加锁。&lt;/p&gt;
&lt;p&gt;只在可重复读或以上隔离级别下的特定操作才会取得 gap lock 或 next-key lock，在 Select 、Update 和 Delete 时，除了基于唯一索引的查询之外，其他索引查询时都会获取 gap lock 或 next-key lock，即锁住其扫描的范围。&lt;/p&gt;
&lt;h2 id=&#34;24-优化高并发事务&#34;&gt;2.4 优化高并发事务
&lt;/h2&gt;&lt;p&gt;通过以上讲解，相信你对事务、锁以及隔离级别已经有了一个透彻的了解了。清楚了问题，我们就可以聊聊高并发场景下的事务到底该如何调优了。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;结合业务场景，使用低级别事务隔离
在高并发业务中，为了保证业务数据的一致性，操作数据库时往往会使用到不同级别的事务隔离。隔离级别越高，并发性能就越低。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那换到业务场景中，我们如何判断用哪种隔离级别更合适呢？我们可以通过两个简单的业务来说下其中的选择方法。&lt;/p&gt;
&lt;p&gt;我们在修改用户最后登录时间的业务场景中，这里对查询用户的登录时间没有特别严格的准确性要求，而修改用户登录信息只有用户自己登录时才会修改，不存在一个事务提交的信息被覆盖的可能。所以我们允许该业务使用最低隔离级别。&lt;/p&gt;
&lt;p&gt;而如果是账户中的余额或积分的消费，就存在多个客户端同时消费一个账户的情况，此时我们应该选择 RR 级别来保证一旦有一个客户端在对账户进行消费，其他客户端就不可能对该账户同时进行消费了。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;避免行锁升级表锁
前面讲了，在 InnoDB 中，行锁是通过索引实现的，如果不通过索引条件检索数据，行锁将会升级到表锁。我们知道，表锁是会严重影响到整张表的操作性能的，所以我们应该避免他。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;控制事务的大小，减少锁定的资源量和锁定时间长度
你是否遇到过以下 SQL 异常呢？在抢购系统的日志中，在活动区间，我们经常可以看到这种异常日志：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;MySQLQueryInterruptedException: Query execution was interrupted
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;由于在抢购提交订单中开启了事务，在高并发时对一条记录进行更新的情况下，由于更新记录所在的事务还可能存在其他操作，导致一个事务比较长，当有大量请求进入时，就可能导致一些请求同时进入到事务中。&lt;/p&gt;
&lt;p&gt;又因为锁的竞争是不公平的，当多个事务同时对一条记录进行更新时，极端情况下，一个更新操作进去排队系统后，可能会一直拿不到锁，最后因超时被系统打断踢出。&lt;/p&gt;
&lt;p&gt;在用户购买商品时，首先我们需要查询库存余额，再新建一个订单，并扣除相应的库存。这一系列操作是处于同一个事务的。&lt;/p&gt;
&lt;p&gt;以上业务若是在两种不同的执行顺序下，其结果都是一样的，但在事务性能方面却不一样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/14.jpeg&#34;
	width=&#34;1358&#34;
	height=&#34;314&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/14_hu_e39e65c10ec0b770.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/14_hu_e62079dcd632d9e9.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;432&#34;
		data-flex-basis=&#34;1037px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;这是因为，虽然这些操作在同一个事务，但锁的申请在不同时间，只有当其他操作都执行完，才会释放所有锁。因为扣除库存是更新操作，属于行锁，这将会影响到其他操作该数据的事务，所以我们应该尽量避免长时间地持有该锁，尽快释放该锁。&lt;/p&gt;
&lt;p&gt;又因为先新建订单和先扣除库存都不会影响业务，所以我们可以将扣除库存操作放到最后，也就是使用执行顺序 1，以此尽量减小锁的持有时间。&lt;/p&gt;
&lt;h1 id=&#34;3-索引的失效与优化&#34;&gt;3. 索引的失效与优化
&lt;/h1&gt;&lt;p&gt;不知道你是否跟我有过同样的经历，那就是作为一个开发工程师，经常被 DBA 叫过去“批评”，而最常见的就是申请创建新的索引或发现慢 SQL 日志了。&lt;/p&gt;
&lt;p&gt;记得之前有一次迭代一个业务模块的开发，涉及到了一个新的查询业务，需要根据商品类型、订单状态筛选出需要的订单，并以订单时间进行排序。由于 sku 的索引已经存在了，我在完成业务开发之后，提交了一个创建 status 的索引的需求，理由是 SQL 查询需要使用到这两个索引：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;select * from order where status =1 and sku=10001 order by create_time asc
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;然而，DBA 很快就将这个需求驳回了，并给出了重建一个 sku、status 以及 create_time 组合索引的建议，查询顺序也改成了 sku=10001 and status=1。&lt;/p&gt;
&lt;h2 id=&#34;31-mysql-索引存储结构&#34;&gt;3.1 MySQL 索引存储结构
&lt;/h2&gt;&lt;p&gt;索引是优化数据库查询最重要的方式之一，它是在 MySQL 的存储引擎层中实现的，所以每一种存储引擎对应的索引不一定相同。我们可以通过下面这张表格，看看不同的存储引擎分别支持哪种索引类型：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/15.jpeg&#34;
	width=&#34;1334&#34;
	height=&#34;342&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/15_hu_bd4017151663c957.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/15_hu_55225218e8f35479.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;390&#34;
		data-flex-basis=&#34;936px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;B+Tree 索引和 Hash 索引是我们比较常用的两个索引数据存储结构，B+Tree 索引是通过 B+ 树实现的，是有序排列存储，所以在排序和范围查找方面都比较有优势。&lt;/p&gt;
&lt;p&gt;Hash 索引相对简单些，只有 Memory 存储引擎支持 Hash 索引。Hash 索引适合 key-value 键值对查询，无论表数据多大，查询数据的复杂度都是 O(1)，且直接通过 Hash 索引查询的性能比其它索引都要优越。&lt;/p&gt;
&lt;p&gt;在创建表时，无论使用 InnoDB 还是 MyISAM 存储引擎，默认都会创建一个主键索引，而创建的主键索引默认使用的是 B+Tree 索引。不过虽然这两个存储引擎都支持 B+Tree 索引，但它们在具体的数据存储结构方面却有所不同。&lt;/p&gt;
&lt;p&gt;InnoDB 默认创建的主键索引是聚族索引（Clustered Index），其它索引都属于辅助索引（Secondary Index），也被称为二级索引或非聚族索引。&lt;/p&gt;
&lt;p&gt;在了解了索引的实现原理后，我们再来详细了解下平时建立和使用索引时，都有哪些调优方法呢？&lt;/p&gt;
&lt;h2 id=&#34;32-索引调优建议&#34;&gt;3.2 索引调优建议
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;覆盖索引优化查询&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;假设我们只需要查询商品的名称、价格信息，我们有什么方式来避免回表呢？我们可以建立一个组合索引，即商品编码、名称、价格作为一个组合索引。如果索引中存在这些数据，查询将不会再次检索主键索引，从而避免回表。&lt;/p&gt;
&lt;p&gt;从辅助索引中查询得到记录，而不需要通过聚族索引查询获得，MySQL 中将其称为覆盖索引。使用覆盖索引的好处很明显，我们不需要查询出包含整行记录的所有信息，因此可以减少大量的 I/O 操作。&lt;/p&gt;
&lt;p&gt;通常在 InnoDB 中，除了查询部分字段可以使用覆盖索引来优化查询性能之外，统计数量也会用到。例如，在前面我们讲 SELECT COUNT(*) 时，如果不存在辅助索引，此时会通过查询聚族索引来统计行数，如果此时正好存在一个辅助索引，则会通过查询辅助索引来统计行数，减少 I/O 操作。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;自增字段作主键优化查询&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上面我们讲了 InnoDB 创建主键索引默认为聚族索引，数据被存放在了 B+ 树的叶子节点上。也就是说，同一个叶子节点内的各个数据是按主键顺序存放的，因此，每当有一条新的数据插入时，数据库会根据主键将其插入到对应的叶子节点中。&lt;/p&gt;
&lt;p&gt;如果我们使用自增主键，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为不需要重新移动数据，因此这种插入数据的方法效率非常高。&lt;/p&gt;
&lt;p&gt;如果我们使用非自增主键，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为页分裂。页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率。&lt;/p&gt;
&lt;p&gt;因此，在使用 InnoDB 存储引擎时，如果没有特别的业务需求，建议使用自增字段作为主键。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;前缀索引优化&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;前缀索引顾名思义就是使用某个字段中字符串的前几个字符建立索引，那我们为什么需要使用前缀来建立索引呢？&lt;/p&gt;
&lt;p&gt;我们知道，索引文件是存储在磁盘中的，而磁盘中最小分配单元是页，通常一个页的默认大小为 16KB，假设我们建立的索引的每个索引值大小为 2KB，则在一个页中，我们能记录 8 个索引值，假设我们有 8000 行记录，则需要 1000 个页来存储索引。如果我们使用该索引查询数据，可能需要遍历大量页，这显然会降低查询效率。&lt;/p&gt;
&lt;p&gt;减小索引字段大小，可以增加一个页中存储的索引项，有效提高索引的查询速度。在一些大字符串的字段作为索引时，使用前缀索引可以帮助我们减小索引项的大小。&lt;/p&gt;
&lt;p&gt;不过，前缀索引是有一定的局限性的，例如 order by 就无法使用前缀索引，无法把前缀索引用作覆盖索引。&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;防止索引失效
当我们习惯建立索引来实现查询 SQL 的性能优化后，是不是就万事大吉了呢？当然不是，有时候我们看似使用到了索引，但实际上并没有被优化器选择使用。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于 Hash 索引实现的列，如果使用到范围查询，那么该索引将无法被优化器使用到。也就是说 Memory 引擎实现的 Hash 索引只有在“=”的查询条件下，索引才会生效。我们将 order 表设置为 Memory 存储引擎，分析查询条件为 id&amp;lt;10 的 SQL，可以发现没有使用到索引。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果是以 % 开头的 LIKE 查询将无法利用节点查询数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当我们在使用复合索引时，需要使用索引中的最左边的列进行查询，才能使用到复合索引&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果查询条件中使用 or，且 or 的前后条件中有一个列没有索引，那么涉及的索引都不会被使用到&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，你懂了吗？作为一名开发人员，如果没有熟悉 MySQL，特别是 MySQL 索引的基础知识，很多时候都将被 DBA 批评到怀疑人生。&lt;/p&gt;
&lt;h1 id=&#34;4-什么时候需要分表分库&#34;&gt;4. 什么时候需要分表分库？
&lt;/h1&gt;&lt;p&gt;分区的底层虽然也是基于分表的原理实现的，即有多个底层表实现，但分区依然是在单库下进行的，在一些需要提高并发的场景中的优化空间非常有限，且一个表最多只能支持 1024 个分区。面对日益增长的海量数据，优化存储能力有限。不过在一些非海量数据的大表中，我们可以考虑使用分区来优化表性能。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;分区表是由多个相关的底层表实现的，这些底层表也是由句柄对象表示，所以我们也可以直接访问各个分区，存储引擎管理分区的各个底层表和管理普通表一样（所有的底层表都必须使用相同的存储引擎），分区表的索引只是在各个底层表上各自加上一个相同的索引，从存储引擎的角度来看，底层表和一个普通表没有任何不同，存储引擎也无须知道这是一个普通表，还是一个分区表的一部分。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;而 NoSQL 存储是基于键值对存储，虽然查询性能非常高，但在一些方面仍然存在短板。例如，不是关系型数据库，不支持事务以及稳定性方面相对 RDBMS 差一些。虽然有些 NoSQL 数据库也实现了事务，宣传具有可靠的稳定性，但目前 NoSQL 还是主要用作辅助存储。&lt;/p&gt;
&lt;h2 id=&#34;41-什么时候要分表分库&#34;&gt;4.1 什么时候要分表分库？
&lt;/h2&gt;&lt;p&gt;在我看来，能不分表分库就不要分表分库。在单表的情况下，当业务正常时，我们使用单表即可，而当业务出现了性能瓶颈时，我们首先考虑用分区的方式来优化，如果分区优化之后仍然存在后遗症，此时我们再来考虑分表分库。&lt;/p&gt;
&lt;p&gt;我们知道，如果在单表单库的情况下，当数据库表的数据量逐渐累积到一定的数量时（5000W 行或 100G 以上），操作数据库的性能会出现明显下降，即使我们使用索引优化或读写库分离，性能依然存在瓶颈。此时，如果每日数据增长量非常大，我们就应该考虑分表，避免单表数据量过大，造成数据库操作性能下降。&lt;/p&gt;
&lt;p&gt;面对海量数据，除了单表的性能比较差以外，我们在单表单库的情况下，数据库连接数、磁盘 I/O 以及网络吞吐等资源都是有限的，并发能力也是有限的。所以，在一些大数据量且高并发的业务场景中，我们就需要考虑分表分库来提升数据库的并发处理能力，从而提升应用的整体性能。&lt;/p&gt;
&lt;h2 id=&#34;42-如何分表分库&#34;&gt;4.2 如何分表分库？
&lt;/h2&gt;&lt;p&gt;通常，分表分库分为垂直切分和水平切分两种。&lt;/p&gt;
&lt;p&gt;垂直分库是指根据业务来分库，不同的业务使用不同的数据库。例如，订单和消费券在抢购业务中都存在着高并发，如果同时使用一个库，会占用一定的连接数，所以我们可以将数据库分为订单库和促销活动库。&lt;/p&gt;
&lt;p&gt;而垂直分表则是指根据一张表中的字段，将一张表划分为两张表，其规则就是将一些不经常使用的字段拆分到另一张表中。例如，一张订单详情表有一百多个字段，显然这张表的字段太多了，一方面不方便我们开发维护，另一方面还可能引起跨页问题。这时我们就可以拆分该表字段，解决上述两个问题。&lt;/p&gt;
&lt;p&gt;水平分表则是将表中的某一列作为切分的条件，按照某种规则（Range 或 Hash 取模）来切分为更小的表。&lt;/p&gt;
&lt;p&gt;水平分表只是在一个库中，如果存在连接数、I/O 读写以及网络吞吐等瓶颈，我们就需要考虑将水平切换的表分布到不同机器的库中，这就是水平分库分表了。&lt;/p&gt;
&lt;p&gt;结合以上垂直切分和水平切分，我们一般可以将数据库分为：单库单表 - 单库多表 - 多库多表。在平时的业务开发中，我们应该优先考虑单库单表；如果数据量比较大，且热点数据比较集中、历史数据很少访问，我们可以考虑表分区；如果访问热点数据分散，基本上所有的数据都会访问到，我们可以考虑单库多表；如果并发量比较高、海量数据以及每日新增数据量巨大，我们可以考虑多库多表。&lt;/p&gt;
&lt;p&gt;这里还需要注意一点，我刚刚强调过，能不分表分库，就不要分表分库。这是因为一旦分表，我们可能会涉及到多表的分页查询、多表的 JOIN 查询，从而增加业务的复杂度。而一旦分库了，除了跨库分页查询、跨库 JOIN 查询，还会存在跨库事务的问题。这些问题无疑会增加我们系统开发的复杂度。&lt;/p&gt;
&lt;h2 id=&#34;43-分表分库之后面临的问题&#34;&gt;4.3 分表分库之后面临的问题
&lt;/h2&gt;&lt;p&gt;然而，分表分库虽然存在着各种各样的问题，但在一些海量数据、高并发的业务中，分表分库仍是最常用的优化手段。所以，我们应该充分考虑分表分库操作后所面临的一些问题，接下我们就一起看看都有哪些应对之策。&lt;/p&gt;
&lt;p&gt;为了更容易理解这些问题，我们将对一个订单表进行分库分表，通过详细的业务来分析这些问题。&lt;/p&gt;
&lt;p&gt;假设我们有一张订单表以及一张订单详情表，每天的数据增长量在 60W 单，平时还会有一些促销类活动，订单增长量在千万单。为了提高系统的并发能力，我们考虑将订单表和订单详情表做分库分表。除了分表，因为用户一般查询的是最近的订单信息，所以热点数据比较集中，我们还可以考虑用表分区来优化单表查询。&lt;/p&gt;
&lt;p&gt;通常订单的分库分表要么基于订单号 Hash 取模实现，要么根据用户 ID Hash 取模实现。订单号 Hash 取模的好处是数据能均匀分布到各个表中，而缺陷则是一个用户查询所有订单时，需要去多个表中查询。&lt;/p&gt;
&lt;p&gt;由于订单表用户查询比较多，此时我们应该考虑使用用户 ID 字段做 Hash 取模，对订单表进行水平分表。如果需要考虑高并发时的订单处理能力，我们可以考虑基于用户 ID 字段 Hash 取模实现分库分表。这也是大部分公司对订单表分库分表的处理方式。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;分布式事务问题&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在提交订单时，除了创建订单之外，我们还需要扣除相应的库存。而订单表和库存表由于垂直分库，位于不同的库中，这时我们需要通过分布式事务来保证提交订单时的事务完整性。&lt;/p&gt;
&lt;p&gt;通常，我们解决分布式事务有两种通用的方式：两阶事务提交（2PC）以及补偿事务提交（TCC）。&lt;/p&gt;
&lt;p&gt;通常有一些中间件已经帮我们封装好了这两种方式的实现，例如 Spring 实现的 JTA，目前阿里开源的分布式事务中间件 Fescar，就很好地实现了与 Dubbo 的兼容。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;跨节点 JOIN 查询问题&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;用户在查询订单时，我们往往需要通过表连接获取到商品信息，而商品信息表可能在另外一个库中，这就涉及到了跨库 JOIN 查询。&lt;/p&gt;
&lt;p&gt;通常，我们会冗余表或冗余字段来优化跨库 JOIN 查询。对于一些基础表，例如商品信息表，我们可以在每一个订单分库中复制一张基础表，避免跨库 JOIN 查询。而对于一两个字段的查询，我们也可以将少量字段冗余在表中，从而避免 JOIN 查询，也就避免了跨库 JOIN 查询。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;跨节点分页查询问题&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们知道，当用户在订单列表中查询所有订单时，可以通过用户 ID 的 Hash 值来快速查询到订单信息，而运营人员在后台对订单表进行查询时，则是通过订单付款时间来进行查询的，这些数据都分布在不同的库以及表中，此时就存在一个跨节点分页查询的问题了。&lt;/p&gt;
&lt;p&gt;通常一些中间件是通过在每个表中先查询出一定的数据，然后在缓存中排序后，获取到对应的分页数据。这种方式在越往后面的查询，就越消耗性能。&lt;/p&gt;
&lt;p&gt;通常我们建议使用两套数据来解决跨节点分页查询问题，一套是基于分库分表的用户单条或多条查询数据，一套则是基于 Elasticsearch、Solr 存储的订单数据，主要用于运营人员根据其它字段进行分页查询。为了不影响提交订单的业务性能，我们一般使用异步消息来实现 Elasticsearch、Solr 订单数据的新增和修改。&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;全局主键 ID 问题&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在分库分表后，主键将无法使用自增长来实现了，在不同的表中我们需要统一全局主键 ID。因此，我们需要单独设计全局主键，避免不同表和库中的主键重复问题。&lt;/p&gt;
&lt;p&gt;使用 UUID 实现全局 ID 是最方便快捷的方式，即随机生成一个 32 位 16 进制数字，这种方式可以保证一个 UUID 的唯一性，水平扩展能力以及性能都比较高。但使用 UUID 最大的缺陷就是，它是一个比较长的字符串，连续性差，如果作为主键使用，性能相对来说会比较差。&lt;/p&gt;
&lt;p&gt;我们也可以基于 Redis 分布式锁实现一个递增的主键 ID，这种方式可以保证主键是一个整数且有一定的连续性，但分布式锁存在一定的性能消耗。&lt;/p&gt;
&lt;p&gt;我们还可以基于 Twitter 开源的分布式 ID 生产算法——snowflake 解决全局主键 ID 问题，snowflake 是通过分别截取时间、机器标识、顺序计数的位数组成一个 long 类型的主键 ID。这种算法可以满足每秒上万个全局 ID 生成，不仅性能好，而且低延时。&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;扩容问题&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;随着用户的订单量增加，根据用户 ID Hash 取模的分表中，数据量也在逐渐累积。此时，我们需要考虑动态增加表，一旦动态增加表了，就会涉及到数据迁移问题。&lt;/p&gt;
&lt;p&gt;我们在最开始设计表数据量时，尽量使用 2 的倍数来设置表数量。当我们需要扩容时，也同样按照 2 的倍数来扩容，这种方式可以减少数据的迁移量。&lt;/p&gt;
&lt;h1 id=&#34;5-mysql中innodb的知识点串讲&#34;&gt;5. MySQL中InnoDB的知识点串讲
&lt;/h1&gt;&lt;h2 id=&#34;51-innodb-体系架构&#34;&gt;5.1 InnoDB 体系架构
&lt;/h2&gt;&lt;p&gt;InnoDB 主要包括了内存池、后台线程以及存储文件。内存池又是由多个内存块组成的，主要包括缓存磁盘数据、redo log 缓冲等；后台线程则包括了 Master Thread、IO Thread 以及 Purge Thread 等；由 InnoDB 存储引擎实现的表的存储结构文件一般包括表结构文件（.frm）、共享表空间文件（ibdata1）、独占表空间文件（ibd）以及日志文件（redo 文件等）等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/16.jpeg&#34;
	width=&#34;1768&#34;
	height=&#34;1020&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/16_hu_b571e0385c1cd3f8.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/16_hu_f5b4f3072c4a3578.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;173&#34;
		data-flex-basis=&#34;416px&#34;
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;内存池
我们知道，如果客户端从数据库中读取数据是直接从磁盘读取的话，无疑会带来一定的性能瓶颈，缓冲池的作用就是提高整个数据库的读写性能。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;客户端读取数据时，如果数据存在于缓冲池中，客户端就会直接读取缓冲池中的数据，否则再去磁盘中读取；对于数据库中的修改数据，首先是修改在缓冲池中的数据，然后再通过 Master Thread 线程刷新到磁盘上。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;后台线程
Master Thread 主要负责将缓冲池中的数据异步刷新到磁盘中，除此之外还包括插入缓存、undo 页的回收等，IO Thread 是负责读写 IO 的线程，而 Purge Thread 主要用于回收事务已经提交了的 undo log，Pager Cleaner Thread 是新引入的一个用于协助 Master Thread 刷新脏页到磁盘的线程，它可以减轻 Master Thread 的工作压力，减少阻塞。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;存储文件
在 MySQL 中建立一张表都会生成一个.frm 文件，该文件是用来保存每个表的元数据信息的，主要包含表结构定义。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 InnoDB 中，存储数据都是按表空间进行存放的，默认为共享表空间，存储的文件即为共享表空间文件（ibdata1）。若设置了参数 innodb_file_per_table 为 1，则会将存储的数据、索引等信息单独存储在一个独占表空间，因此也会产生一个独占表空间文件（ibd）。如果你对共享表空间和独占表空间的理解还不够透彻，接下来我会详解。&lt;/p&gt;
&lt;h2 id=&#34;52-innodb-逻辑存储结构&#34;&gt;5.2 InnoDB 逻辑存储结构
&lt;/h2&gt;&lt;p&gt;InnoDB 逻辑存储结构分为表空间（Tablespace）、段 (Segment)、区 (Extent)、页 Page) 以及行 (row)。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/17.jpeg&#34;
	width=&#34;1290&#34;
	height=&#34;858&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/17_hu_5171f0d7967e48f.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%985/17_hu_6db082b9300058ed.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;150&#34;
		data-flex-basis=&#34;360px&#34;
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;表空间（Tablespace）
InnoDB 提供了两种表空间存储数据的方式，一种是共享表空间，一种是独占表空间。 InnoDB 默认会将其所有的表数据存储在一个共享表空间中，即 ibdata1。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们可以通过设置 innodb_file_per_table 参数为 1（1 代表独占方式）开启独占表空间模式。开启之后，每个表都有自己独立的表空间物理文件，所有的数据以及索引都会存储在该文件中，这样方便备份以及恢复数据。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;段 (Segment)
表空间是由各个段组成的，段一般分为数据段、索引段和回滚段等。我们知道，InnoDB 默认是基于 B + 树实现的数据存储。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里的索引段则是指的 B + 树的非叶子节点，而数据段则是 B + 树的叶子节点。而回滚段则指的是回滚数据，之前我们在讲事务隔离的时候就介绍到了 MVCC 利用了回滚段实现了多版本查询数据。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;区 (Extent) / 页（Page）
区是表空间的单元结构，每个区的大小为 1MB。而页是组成区的最小单元，页也是 InnoDB 存储引擎磁盘管理的最小单元，每个页的大小默认为 16KB。为了保证页的连续性，InnoDB 存储引擎每次从磁盘申请 4-5 个区。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;行（Row）
InnoDB 存储引擎是面向列的（row-oriented)，也就是说数据是按行进行存放的，每个页存放的行记录也是有硬性定义的，最多允许存放 16KB/2-200 行，即 7992 行记录。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;53-innodb-事务之-redo-log-工作原理&#34;&gt;5.3 InnoDB 事务之 redo log 工作原理
&lt;/h2&gt;&lt;p&gt;InnoDB 是一个事务性的存储引擎，而 InnoDB 的事务实现是基于事务日志 redo log 和 undo log 实现的。redo log 是重做日志，提供再写入操作，实现事务的持久性；undo log 是回滚日志，提供回滚操作，保证事务的一致性。&lt;/p&gt;
&lt;p&gt;redo log 又包括了内存中的日志缓冲（redo log buffer）以及保存在磁盘的重做日志文件（redo log file），前者存储在内存中，容易丢失，后者持久化在磁盘中，不会丢失。&lt;/p&gt;
&lt;p&gt;InnoDB 的更新操作采用的是 Write Ahead Log 策略，即先写日志，再写入磁盘。当一条记录更新时，InnoDB 会先把记录写入到 redo log buffer 中，并更新内存数据。我们可以通过参数 innodb_flush_log_at_trx_commit 自定义 commit 时，如何将 redo log buffer 中的日志刷新到 redo log file 中。&lt;/p&gt;
&lt;p&gt;在这里，我们需要注意的是 InnoDB 的 redo log 的大小是固定的，分别有多个日志文件采用循环方式组成一个循环闭环，当写到结尾时，会回到开头循环写日志。我们可以通过参数 innodb_log_files_in_group 和 innodb_log_file_size 配置日志文件数量和每个日志文件的大小。&lt;/p&gt;
&lt;p&gt;Buffer Pool 中更新的数据未刷新到磁盘中，该内存页我们称之为脏页。最终脏页的数据会刷新到磁盘中，将磁盘中的数据覆盖，这个过程与 redo log 不一定有关系。&lt;/p&gt;
&lt;p&gt;只有当 redo log 日志满了的情况下，才会主动触发脏页刷新到磁盘，而脏页不仅只有 redo log 日志满了的情况才会刷新到磁盘，以下几种情况同样会触发脏页的刷新：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统内存不足时，需要将一部分数据页淘汰掉，如果淘汰的是脏页，需要先将脏页同步到磁盘；&lt;/li&gt;
&lt;li&gt;MySQL 认为空闲的时间，这种情况没有性能问题；&lt;/li&gt;
&lt;li&gt;MySQL 正常关闭之前，会把所有的脏页刷入到磁盘，这种情况也没有性能问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在生产环境中，如果我们开启了慢 SQL 监控，你会发现偶尔会出现一些用时稍长的 SQL。这是因为脏页在刷新到磁盘时可能会给数据库带来性能开销，导致数据库操作抖动。&lt;/p&gt;
&lt;p&gt;LRU 淘汰策略&lt;/p&gt;
&lt;p&gt;以上我们了解了 InnoDB 的更新和插入操作的具体实现原理，接下来我们再来了解下读的实现和优化方式。&lt;/p&gt;
&lt;p&gt;InnoDB 存储引擎是基于集合索引实现的数据存储，也就是除了索引列以及主键是存储在 B + 树之外，其它列数据也存储在 B + 树的叶子节点中。而这里的索引页和数据页都会缓存在缓冲池中，在查询数据时，只要在缓冲池中存在该数据，InnoDB 就不用每次都去磁盘中读取页，从而提高数据库的查询性能。&lt;/p&gt;
&lt;p&gt;虽然缓冲池是一个很大的内存区域，但由于存放了各种类型的数据，加上存储数据量之大，缓冲池无法将所有的数据都存储在其中。因此，缓冲池需要通过 LRU 算法将最近且经常查询的数据缓存在其中，而不常查询的数据就淘汰出去。&lt;/p&gt;
&lt;p&gt;InnoDB 对 LRU 做了一些优化，我们熟悉的 LRU 算法通常是将最近查询的数据放到 LRU 列表的首部，而 InnoDB 则是将数据放在一个 midpoint 位置，通常这个 midpoint 为列表长度的 5/8。&lt;/p&gt;
&lt;p&gt;这种策略主要是为了避免一些不常查询的操作突然将热点数据淘汰出去，而热点数据被再次查询时，需要再次从磁盘中获取，从而影响数据库的查询性能。&lt;/p&gt;
&lt;p&gt;如果我们的热点数据比较多，我们可以通过调整 midpoint 值来增加热点数据的存储量，从而降低热点数据的淘汰率。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Java性能调优4</title>
        <link>https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/</link>
        <pubDate>Tue, 02 Mar 2021 12:51:07 +0800</pubDate>
        
        <guid>https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/</guid>
        <description>&lt;h1 id=&#34;1-了解jvm内存结构&#34;&gt;1. 了解JVM内存结构
&lt;/h1&gt;&lt;h2 id=&#34;11-为什么-jvm-在-java-中如此重要&#34;&gt;1.1 为什么 JVM 在 Java 中如此重要？
&lt;/h2&gt;&lt;p&gt;首先你应该知道，运行一个 Java 应用程序，我们必须要先安装 JDK 或者 JRE 包。这是因为 Java 应用在编译后会变成字节码，然后通过字节码运行在 JVM 中，而 JVM 是 JRE 的核心组成部分。&lt;/p&gt;
&lt;p&gt;JVM 不仅承担了 Java 字节码的分析（JIT compiler）和执行（Runtime），同时也内置了自动内存分配管理机制。这个机制可以大大降低手动分配回收机制可能带来的内存泄露和内存溢出风险，使 Java 开发人员不需要关注每个对象的内存分配以及回收，从而更专注于业务本身。&lt;/p&gt;
&lt;h2 id=&#34;12-从了解内存结构开始&#34;&gt;1.2 从了解内存结构开始
&lt;/h2&gt;&lt;p&gt;VM 自动内存分配管理机制的好处很多，但实则是把双刃剑。这个机制在提升 Java 开发效率的同时，也容易使 Java 开发人员过度依赖于自动化，弱化对内存的管理能力，这样系统就很容易发生 JVM 的堆内存异常，垃圾回收（GC）的方式不合适以及 GC 次数过于频繁等问题，这些都将直接影响到应用服务的性能。&lt;/p&gt;
&lt;p&gt;因此，要进行 JVM 层面的调优，就需要深入了解 JVM 内存分配和回收原理，这样在遇到问题时，我们才能通过日志分析快速地定位问题；也能在系统遇到性能瓶颈时，通过分析 JVM 调优来优化系统性能。这也是整个模块四的重点内容，今天我们就从 JVM 的内存模型学起，为后续的学习打下一个坚实的基础。&lt;/p&gt;
&lt;h2 id=&#34;13-jvm-内存结构的具体设计&#34;&gt;1.3 JVM 内存结构的具体设计
&lt;/h2&gt;&lt;p&gt;我们先通过一张 JVM 内存模型图，来熟悉下其具体设计。在 Java 中，JVM 内存模型主要分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;堆&lt;/li&gt;
&lt;li&gt;程序计数器&lt;/li&gt;
&lt;li&gt;方法区&lt;/li&gt;
&lt;li&gt;虚拟机栈&lt;/li&gt;
&lt;li&gt;本地方法栈&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/01.jpeg&#34;
	width=&#34;1022&#34;
	height=&#34;664&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/01_hu_27188a0106f4e18a.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/01_hu_a472ab4c97184c80.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;153&#34;
		data-flex-basis=&#34;369px&#34;
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;堆（Heap）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;堆是 JVM 内存中最大的一块内存空间，该内存被所有线程共享，几乎所有对象和数组都被分配到了堆内存中。堆被划分为新生代和老年代，新生代又被进一步划分为 Eden 和 Survivor 区，最后 Survivor 由 From Survivor 和 To Survivor 组成。&lt;/p&gt;
&lt;p&gt;在 Java6 版本中，永久代在非堆内存区；到了 Java7 版本，永久代的静态变量和运行时常量池被合并到了堆中；而到了 Java8，永久代被元空间取代了。 结构如下图所示：
&lt;img src=&#34;https://zhenyu0324.github.io/02.jpeg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;程序计数器（Program Counter Register）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;程序计数器是一块很小的内存空间，主要用来记录各个线程执行的字节码的地址，例如，分支、循环、跳转、异常、线程恢复等都依赖于计数器。&lt;/p&gt;
&lt;p&gt;由于 Java 是多线程语言，当执行的线程数量超过 CPU 数量时，线程之间会根据时间片轮询争夺 CPU 资源。如果一个线程的时间片用完了，或者是其它原因导致这个线程的 CPU 资源被提前抢夺，那么这个退出的线程就需要单独的一个程序计数器，来记录下一条运行的指令。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;方法区（Method Area）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;很多开发者都习惯将方法区称为“永久代”，其实这两者并不是等价的。&lt;/p&gt;
&lt;p&gt;HotSpot 虚拟机使用永久代来实现方法区，但在其它虚拟机中，例如，Oracle 的 JRockit、IBM 的 J9 就不存在永久代一说。因此，方法区只是 JVM 中规范的一部分，可以说，在 HotSpot 虚拟机中，设计人员使用了永久代来实现了 JVM 规范的方法区。&lt;/p&gt;
&lt;p&gt;方法区主要是用来存放已被虚拟机加载的类相关信息，包括类信息、运行时常量池、字符串常量池。类信息又包括了类的版本、字段、方法、接口和父类等信息。&lt;/p&gt;
&lt;p&gt;JVM 在执行某个类的时候，必须经过加载、连接、初始化，而连接又包括验证、准备、解析三个阶段。在加载类的时候，JVM 会先加载 class 文件，而在 class 文件中除了有类的版本、字段、方法和接口等描述信息外，还有一项信息是常量池 (Constant Pool Table)，用于存放编译期间生成的各种字面量和符号引用。&lt;/p&gt;
&lt;p&gt;字面量包括字符串（String a=“b”）、基本类型的常量（final 修饰的变量），符号引用则包括类和方法的全限定名（例如 String 这个类，它的全限定名就是 Java/lang/String）、字段的名称和描述符以及方法的名称和描述符。&lt;/p&gt;
&lt;p&gt;而当类加载到内存中后，JVM 就会将 class 文件常量池中的内容存放到运行时的常量池中；在解析阶段，JVM 会把符号引用替换为直接引用（对象的索引值）。&lt;/p&gt;
&lt;p&gt;例如，类中的一个字符串常量在 class 文件中时，存放在 class 文件常量池中的；在 JVM 加载完类之后，JVM 会将这个字符串常量放到运行时常量池中，并在解析阶段，指定该字符串对象的索引值。运行时常量池是全局共享的，多个类共用一个运行时常量池，class 文件中常量池多个相同的字符串在运行时常量池只会存在一份。&lt;/p&gt;
&lt;p&gt;方法区与堆空间类似，也是一个共享内存区，所以方法区是线程共享的。假如两个线程都试图访问方法区中的同一个类信息，而这个类还没有装入 JVM，那么此时就只允许一个线程去加载它，另一个线程必须等待。&lt;/p&gt;
&lt;p&gt;Java8 为什么使用元空间替代永久代，这样做有什么好处呢？
官方给出的解释是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;移除永久代是为了融合 HotSpot JVM 与 JRockit VM 而做出的努力，因为 JRockit 没有永久代，所以不需要配置永久代。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;永久代内存经常不够用或发生内存溢出，爆出异常 java.lang.OutOfMemoryError: PermGen。这是因为在 JDK1.7 版本中，指定的 PermGen 区大小为 8M，由于PermGen 中类的元数据信息在每次 FullGC 的时候都可能被收集，回收率都偏低，成绩很难令人满意；还有，为 PermGen 分配多大的空间很难确定，PermSize 的大小依赖于很多因素，比如，JVM 加载的 class 总数、常量池的大小和方法的大小等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;虚拟机栈（VM stack）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Java 虚拟机栈是线程私有的内存空间，它和 Java 线程一起创建。当创建一个线程时，会在虚拟机栈中申请一个线程栈，用来保存方法的局部变量、操作数栈、动态链接方法和返回地址等信息，并参与方法的调用和返回。每一个方法的调用都伴随着栈帧的入栈操作，方法的返回则是栈帧的出栈操作。&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;本地方法栈（Native Method Stack）
本地方法栈跟 Java 虚拟机栈的功能类似，Java 虚拟机栈用于管理 Java 函数的调用，而本地方法栈则用于管理本地方法的调用。但本地方法并不是用 Java 实现的，而是由 C 语言实现的。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;2-深入jvm即时编译器jit优化java编译&#34;&gt;2. 深入JVM即时编译器JIT，优化Java编译
&lt;/h1&gt;&lt;p&gt;说到编译，我猜你一定会想到 .java 文件被编译成 .class 文件的过程，这个编译我们一般称为前端编译。Java 的编译和运行过程非常复杂，除了前端编译，还有运行时编译。由于机器无法直接运行 Java 生成的字节码，所以在运行时，JIT 或解释器会将字节码转换成机器码，这个过程就叫运行时编译。&lt;/p&gt;
&lt;p&gt;类文件在运行时被进一步编译，它们可以变成高度优化的机器代码，由于 C/C++ 编译器的所有优化都是在编译期间完成的，运行期间的性能监控仅作为基础的优化措施则无法进行，例如，调用频率预测、分支频率预测、裁剪未被选择的分支等，而 Java 在运行时的再次编译，就可以进行基础的优化措施。因此，JIT 编译器可以说是 JVM 中运行时编译最重要的部分之一。&lt;/p&gt;
&lt;h2 id=&#34;21-类编译加载执行过程&#34;&gt;2.1 类编译加载执行过程
&lt;/h2&gt;&lt;p&gt;在这之前，我们先了解下 Java 从编译到运行的整个过程，为后面的学习打下基础。请看下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/03.jpeg&#34;
	width=&#34;2172&#34;
	height=&#34;410&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/03_hu_118a411ae7bf2b5b.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/03_hu_98fa125bb338ffa9.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;529&#34;
		data-flex-basis=&#34;1271px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;22-类编译&#34;&gt;2.2 类编译
&lt;/h2&gt;&lt;p&gt;在编写好代码之后，我们需要将 .java 文件编译成 .class 文件，才能在虚拟机上正常运行代码。文件的编译通常是由 JDK 中自带的 Javac 工具完成，一个简单的 .java 文件，我们可以通过 javac 命令来生成 .class 文件。&lt;/p&gt;
&lt;p&gt;编译后的字节码文件主要包括常量池和方法表集合这两部分。&lt;/p&gt;
&lt;p&gt;常量池主要记录的是类文件中出现的字面量以及符号引用。字面常量包括字符串常量（例如 String str=“abc”，其中&amp;quot;abc&amp;quot;就是常量），声明为 final 的属性以及一些基本类型（例如，范围在 -127-128 之间的整型）的属性。符号引用包括类和接口的全限定名、类引用、方法引用以及成员变量引用（例如 String str=“abc”，其中 str 就是成员变量引用）等。&lt;/p&gt;
&lt;p&gt;方法表集合中主要包含一些方法的字节码、方法访问权限（public、protect、prviate 等）、方法名索引（与常量池中的方法引用对应）、描述符索引、JVM 执行指令以及属性集合等。&lt;/p&gt;
&lt;h2 id=&#34;23-类加载&#34;&gt;2.3 类加载
&lt;/h2&gt;&lt;p&gt;当一个类被创建实例或者被其它对象引用时，虚拟机在没有加载过该类的情况下，会通过类加载器将字节码文件加载到内存中。&lt;/p&gt;
&lt;p&gt;不同的实现类由不同的类加载器加载，JDK 中的本地方法类一般由根加载器（Bootstrp loader）加载进来，JDK 中内部实现的扩展类一般由扩展加载器（ExtClassLoader ）实现加载，而程序中的类文件则由系统加载器（AppClassLoader ）实现加载。&lt;/p&gt;
&lt;p&gt;在类加载后，class 类文件中的常量池信息以及其它数据会被保存到 JVM 内存的方法区中。&lt;/p&gt;
&lt;h2 id=&#34;24-类连接&#34;&gt;2.4 类连接
&lt;/h2&gt;&lt;p&gt;类在加载进来之后，会进行连接、初始化，最后才会被使用。在连接过程中，又包括验证、准备和解析三个部分。&lt;/p&gt;
&lt;p&gt;验证：验证类符合 Java 规范和 JVM 规范，在保证符合规范的前提下，避免危害虚拟机安全。&lt;/p&gt;
&lt;p&gt;准备：为类的静态变量分配内存，初始化为系统的初始值。对于 final static 修饰的变量，直接赋值为用户的定义值。例如，private final static int value=123，会在准备阶段分配内存，并初始化值为 123，而如果是 private static int value=123，这个阶段 value 的值仍然为 0。&lt;/p&gt;
&lt;p&gt;解析：将符号引用转为直接引用的过程。我们知道，在编译时，Java 类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。类结构文件的常量池中存储了符号引用，包括类和接口的全限定名、类引用、方法引用以及成员变量引用等。如果要使用这些类和方法，就需要把它们转化为 JVM 可以直接获取的内存地址或指针，即直接引用。&lt;/p&gt;
&lt;h2 id=&#34;25-类初始化&#34;&gt;2.5 类初始化
&lt;/h2&gt;&lt;p&gt;类初始化阶段是类加载过程的最后阶段，在这个阶段中，JVM 首先将执行构造器 &lt;clinit&gt; 方法，编译器会在将 .java 文件编译成 .class 文件时，收集所有类初始化代码，包括静态变量赋值语句、静态代码块、静态方法，收集在一起成为 &lt;clinit&gt;() 方法。&lt;/p&gt;
&lt;p&gt;初始化类的静态变量和静态代码块为用户自定义的值，初始化的顺序和 Java 源码从上到下的顺序一致。例如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;private static int i=1；
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;static{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  i=0;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public static void main(String [] args){
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  System.out.println(i);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;此时运行结果为：&lt;/p&gt;
&lt;p&gt;0&lt;/p&gt;
&lt;p&gt;再来看看以下代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;tatic{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  i=0;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;private static int i=1；
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public static void main(String [] args){
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  System.out.println(i);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;此时运行结果为：&lt;/p&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;p&gt;JVM 会保证 &lt;clinit&gt;() 方法的线程安全，保证同一时间只有一个线程执行。&lt;/p&gt;
&lt;p&gt;JVM 在初始化执行代码时，如果实例化一个新对象，会调用 &lt;init&gt; 方法对实例变量进行初始化，并执行对应的构造方法内的代码。&lt;/p&gt;
&lt;h2 id=&#34;26-即时编译&#34;&gt;2.6 即时编译
&lt;/h2&gt;&lt;p&gt;初始化完成后，类在调用执行过程中，执行引擎会把字节码转为机器码，然后在操作系统中才能执行。在字节码转换为机器码的过程中，虚拟机中还存在着一道编译，那就是即时编译。&lt;/p&gt;
&lt;p&gt;最初，虚拟机中的字节码是由解释器（ Interpreter ）完成编译的，当虚拟机发现某个方法或代码块的运行特别频繁的时候，就会把这些代码认定为“热点代码”。&lt;/p&gt;
&lt;p&gt;为了提高热点代码的执行效率，在运行时，即时编译器（JIT）会把这些代码编译成与本地平台相关的机器码，并进行各层次的优化，然后保存到内存中。&lt;/p&gt;
&lt;h1 id=&#34;3-如何优化垃圾回收机制&#34;&gt;3. 如何优化垃圾回收机制？
&lt;/h1&gt;&lt;p&gt;我们知道，在 Java 开发中，开发人员是无需过度关注对象的回收与释放的，JVM 的垃圾回收机制可以减轻不少工作量。但完全交由 JVM 回收对象，也会增加回收性能的不确定性。在一些特殊的业务场景下，不合适的垃圾回收算法以及策略，都有可能导致系统性能下降。&lt;/p&gt;
&lt;p&gt;面对不同的业务场景，垃圾回收的调优策略也不一样。例如，在对内存要求苛刻的情况下，需要提高对象的回收效率；在 CPU 使用率高的情况下，需要降低高并发时垃圾回收的频率。可以说，垃圾回收的调优是一项必备技能。&lt;/p&gt;
&lt;h2 id=&#34;31-垃圾回收机制&#34;&gt;3.1 垃圾回收机制
&lt;/h2&gt;&lt;p&gt;掌握 GC 算法之前，我们需要先弄清楚 3 个问题。第一，回收发生在哪里？第二，对象在什么时候可以被回收？第三，如何回收这些对象？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;回收发生在哪里？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;JVM 的内存区域中，程序计数器、虚拟机栈和本地方法栈这 3 个区域是线程私有的，随着线程的创建而创建，销毁而销毁；栈中的栈帧随着方法的进入和退出进行入栈和出栈操作，每个栈帧中分配多少内存基本是在类结构确定下来的时候就已知的，因此这三个区域的内存分配和回收都具有确定性。&lt;/p&gt;
&lt;p&gt;那么垃圾回收的重点就是关注堆和方法区中的内存了，堆中的回收主要是对象的回收，方法区的回收主要是废弃常量和无用的类的回收。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;对象在什么时候可以被回收？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那 JVM 又是怎样判断一个对象是可以被回收的呢？一般一个对象不再被引用，就代表该对象可以被回收。目前有以下两种算法可以判断该对象是否可以被回收。&lt;/p&gt;
&lt;p&gt;引用计数算法：这种算法是通过一个对象的引用计数器来判断该对象是否被引用了。每当对象被引用，引用计数器就会加 1；每当引用失效，计数器就会减 1。当对象的引用计数器的值为 0 时，就说明该对象不再被引用，可以被回收了。这里强调一点，虽然引用计数算法的实现简单，判断效率也很高，但它存在着对象之间相互循环引用的问题。&lt;/p&gt;
&lt;p&gt;可达性分析算法：GC Roots 是该算法的基础，GC Roots 是所有对象的根对象，在 JVM 加载时，会创建一些普通对象引用正常对象。这些对象作为正常对象的起始点，在垃圾回收时，会从这些 GC Roots 开始向下搜索，当一个对象到 GC Roots 没有任何引用链相连时，就证明此对象是不可用的。目前 HotSpot 虚拟机采用的就是这种算法。&lt;/p&gt;
&lt;p&gt;以上两种算法都是通过引用来判断对象是否可以被回收。在 JDK 1.2 之后，Java 对引用的概念进行了扩充，将引用分为了以下四种：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/04.jpeg&#34;
	width=&#34;1358&#34;
	height=&#34;488&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/04_hu_9e20415f1ee4bda1.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/04_hu_eb7677aad4232ac7.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;278&#34;
		data-flex-basis=&#34;667px&#34;
	
&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;如何回收这些对象？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;了解完 Java 程序中对象的回收条件，那么垃圾回收线程又是如何回收这些对象的呢？JVM 垃圾回收遵循以下两个特性。&lt;/p&gt;
&lt;p&gt;自动性：Java 提供了一个系统级的线程来跟踪每一块分配出去的内存空间，当 JVM 处于空闲循环时，垃圾收集器线程会自动检查每一块分配出去的内存空间，然后自动回收每一块空闲的内存块。&lt;/p&gt;
&lt;p&gt;不可预期性：一旦一个对象没有被引用了，该对象是否立刻被回收呢？答案是不可预期的。我们很难确定一个没有被引用的对象是不是会被立刻回收掉，因为有可能当程序结束后，这个对象仍在内存中。&lt;/p&gt;
&lt;p&gt;垃圾回收线程在 JVM 中是自动执行的，Java 程序无法强制执行。我们唯一能做的就是通过调用 System.gc 方法来&amp;quot;建议&amp;quot;执行垃圾收集器，但是否可执行，什么时候执行？仍然不可预期。&lt;/p&gt;
&lt;h2 id=&#34;32-gc-算法&#34;&gt;3.2 GC 算法
&lt;/h2&gt;&lt;p&gt;JVM 提供了不同的回收算法来实现这一套回收机制，通常垃圾收集器的回收算法可以分为以下几种：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/05.jpeg&#34;
	width=&#34;1314&#34;
	height=&#34;404&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/05_hu_2085b8baea6f86ab.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/05_hu_e3f5043b963de166.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;325&#34;
		data-flex-basis=&#34;780px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现，JDK1.7 update14 之后 Hotspot 虚拟机所有的回收器整理如下（以下为服务端垃圾收集器）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/06.jpeg&#34;
	width=&#34;1896&#34;
	height=&#34;702&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/06_hu_e575263214828b62.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/06_hu_70f91eb992c700b1.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;270&#34;
		data-flex-basis=&#34;648px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;其实在 JVM 规范中并没有明确 GC 的运作方式，各个厂商可以采用不同的方式实现垃圾收集器。我们可以通过 JVM 工具查询当前 JVM 使用的垃圾收集器类型，首先通过 ps 命令查询出进程 ID，再通过 jmap -heap ID 查询出 JVM 的配置信息，其中就包括垃圾收集器的设置类型。&lt;/p&gt;
&lt;h2 id=&#34;33-gc-性能衡量指标&#34;&gt;3.3 GC 性能衡量指标
&lt;/h2&gt;&lt;p&gt;一个垃圾收集器在不同场景下表现出的性能也不一样，那么如何评价一个垃圾收集器的性能好坏呢？我们可以借助一些指标。&lt;/p&gt;
&lt;p&gt;吞吐量：这里的吞吐量是指应用程序所花费的时间和系统总运行时间的比值。我们可以按照这个公式来计算 GC 的吞吐量：系统总运行时间 = 应用程序耗时 +GC 耗时。如果系统运行了 100 分钟，GC 耗时 1 分钟，则系统吞吐量为 99%。GC 的吞吐量一般不能低于 95%。&lt;/p&gt;
&lt;p&gt;停顿时间：指垃圾收集器正在运行时，应用程序的暂停时间。对于串行回收器而言，停顿时间可能会比较长；而使用并发回收器，由于垃圾收集器和应用程序交替运行，程序的停顿时间就会变短，但其效率很可能不如独占垃圾收集器，系统的吞吐量也很可能会降低。&lt;/p&gt;
&lt;p&gt;垃圾回收频率：多久发生一次指垃圾回收呢？通常垃圾回收的频率越低越好，增大堆内存空间可以有效降低垃圾回收发生的频率，但同时也意味着堆积的回收对象越多，最终也会增加回收时的停顿时间。所以我们只要适当地增大堆内存空间，保证正常的垃圾回收频率即可。&lt;/p&gt;
&lt;h2 id=&#34;34-查看--分析-gc-日志&#34;&gt;3.4 查看 &amp;amp; 分析 GC 日志
&lt;/h2&gt;&lt;p&gt;已知了性能衡量指标，现在我们需要通过工具查询 GC 相关日志，统计各项指标的信息。首先，我们需要通过 JVM 参数预先设置 GC 日志，通常有以下几种 JVM 参数设置：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-XX:+PrintGC 输出 GC 日志
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-XX:+PrintGCDetails 输出 GC 的详细日志
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-XX:+PrintGCTimeStamps 输出 GC 的时间戳（以基准时间的形式）
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-XX:+PrintGCDateStamps 输出 GC 的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800）
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-XX:+PrintHeapAtGC 在进行 GC 的前后打印出堆的信息
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-Xloggc:../logs/gc.log 日志文件的输出路径
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这里使用如下参数来打印日志：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-XX:+PrintGCDateStamps -XX:+PrintGCDetails -Xloggc:./gclogs
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;打印后的日志为：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/07.png&#34;
	width=&#34;1333&#34;
	height=&#34;319&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/07_hu_71f816652c333640.png 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/07_hu_579665b48e662dde.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;417&#34;
		data-flex-basis=&#34;1002px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;上图是运行很短时间的 GC 日志，如果是长时间的 GC 日志，我们很难通过文本形式去查看整体的 GC 性能。&lt;/p&gt;
&lt;p&gt;这里我再推荐一个比较好用的 GC 日志分析工具，GCeasy是一款非常直观的 GC 日志分析工具，我们可以将日志文件压缩之后，上传到 GCeasy 官网即可看到非常清楚的 GC 日志分析结果。&lt;/p&gt;
&lt;h2 id=&#34;35-gc-调优策略&#34;&gt;3.5 GC 调优策略
&lt;/h2&gt;&lt;p&gt;找出问题后，就可以进行调优了，下面介绍几种常用的 GC 调优策略。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;降低 Minor GC 频率&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通常情况下，由于新生代空间较小，Eden 区很快被填满，就会导致频繁 Minor GC，因此我们可以通过增大新生代空间来降低 Minor GC 的频率。&lt;/p&gt;
&lt;p&gt;可能你会有这样的疑问，扩容 Eden 区虽然可以减少 Minor GC 的次数，但不会增加单次 Minor GC 的时间吗？如果单次 Minor GC 的时间增加，那也很难达到我们期待的优化效果呀。&lt;/p&gt;
&lt;p&gt;我们知道，单次 Minor GC 时间是由两部分组成：T1（扫描新生代）和 T2（复制存活对象）。假设一个对象在 Eden 区的存活时间为 500ms，Minor GC 的时间间隔是 300ms，那么正常情况下，Minor GC 的时间为 ：T1+T2。&lt;/p&gt;
&lt;p&gt;当我们增大新生代空间，Minor GC 的时间间隔可能会扩大到 600ms，此时一个存活 500ms 的对象就会在 Eden 区中被回收掉，此时就不存在复制存活对象了，所以再发生 Minor GC 的时间为：两次扫描新生代，即 2T1。&lt;/p&gt;
&lt;p&gt;可见，扩容后，Minor GC 时增加了 T1，但省去了 T2 的时间。通常在虚拟机中，复制对象的成本要远高于扫描成本。&lt;/p&gt;
&lt;p&gt;如果在堆内存中存在较多的长期存活的对象，此时增加年轻代空间，反而会增加 Minor GC 的时间。如果堆中的短期对象很多，那么扩容新生代，单次 Minor GC 时间不会显著增加。因此，单次 Minor GC 时间更多取决于 GC 后存活对象的数量，而非 Eden 区的大小。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;降低 Full GC 的频率&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;通常情况下，由于堆内存空间不足或老年代对象太多，会触发 Full GC，频繁的 Full GC 会带来上下文切换，增加系统的性能开销。我们可以使用哪些方法来降低 Full GC 的频率呢？&lt;/p&gt;
&lt;p&gt;减少创建大对象：在平常的业务场景中，我们习惯一次性从数据库中查询出一个大对象用于 web 端显示。例如，我之前碰到过一个一次性查询出 60 个字段的业务操作，这种大对象如果超过年轻代最大对象阈值，会被直接创建在老年代；即使被创建在了年轻代，由于年轻代的内存空间有限，通过 Minor GC 之后也会进入到老年代。这种大对象很容易产生较多的 Full GC。&lt;/p&gt;
&lt;p&gt;我们可以将这种大对象拆解出来，首次只查询一些比较重要的字段，如果还需要其它字段辅助查看，再通过第二次查询显示剩余的字段。&lt;/p&gt;
&lt;p&gt;增大堆内存空间：在堆内存不足的情况下，增大堆内存空间，且设置初始化堆内存为最大堆内存，也可以降低 Full GC 的频率。&lt;/p&gt;
&lt;h2 id=&#34;36-选择合适的-gc-回收器&#34;&gt;3.6 选择合适的 GC 回收器
&lt;/h2&gt;&lt;p&gt;假设我们有这样一个需求，要求每次操作的响应时间必须在 500ms 以内。这个时候我们一般会选择响应速度较快的 GC 回收器，CMS（Concurrent Mark Sweep）回收器和 G1 回收器都是不错的选择。&lt;/p&gt;
&lt;p&gt;而当我们的需求对系统吞吐量有要求时，就可以选择 Parallel Scavenge 回收器来提高系统的吞吐量。&lt;/p&gt;
&lt;h1 id=&#34;4-如何优化jvm内存分配&#34;&gt;4. 如何优化JVM内存分配？
&lt;/h1&gt;&lt;p&gt;JVM 调优是一个系统而又复杂的过程，但我们知道，在大多数情况下，我们基本不用去调整 JVM 内存分配，因为一些初始化的参数已经可以保证应用服务正常稳定地工作了。&lt;/p&gt;
&lt;p&gt;但所有的调优都是有目标性的，JVM 内存分配调优也一样。没有性能问题的时候，我们自然不会随意改变 JVM 内存分配的参数。那有了问题呢？有了什么样的性能问题我们需要对其进行调优呢？又该如何调优呢？这就是我今天要分享的内容。&lt;/p&gt;
&lt;h2 id=&#34;41-jvm-内存分配性能问题&#34;&gt;4.1 JVM 内存分配性能问题
&lt;/h2&gt;&lt;p&gt;谈到 JVM 内存表现出的性能问题时，你可能会想到一些线上的 JVM 内存溢出事故。但这方面的事故往往是应用程序创建对象导致的内存回收对象难，一般属于代码编程问题。&lt;/p&gt;
&lt;p&gt;但其实很多时候，在应用服务的特定场景下，JVM 内存分配不合理带来的性能表现并不会像内存溢出问题这么突出。可以说如果你没有深入到各项性能指标中去，是很难发现其中隐藏的性能损耗。&lt;/p&gt;
&lt;p&gt;JVM 内存分配不合理最直接的表现就是频繁的 GC，这会导致上下文切换等性能问题，从而降低系统的吞吐量、增加系统的响应时间。因此，如果你在线上环境或性能测试时，发现频繁的 GC，且是正常的对象创建和回收，这个时候就需要考虑调整 JVM 内存分配了，从而减少 GC 所带来的性能开销。&lt;/p&gt;
&lt;h2 id=&#34;42-对象在堆中的生存周期&#34;&gt;4.2 对象在堆中的生存周期
&lt;/h2&gt;&lt;p&gt;了解了性能问题，那需要做的势必就是调优了。但先别急，在了解 JVM 内存分配的调优过程之前，我们先来看看一个新创建的对象在堆内存中的生存周期，为后面的学习打下基础。&lt;/p&gt;
&lt;p&gt;我们知道，在 JVM 内存模型的堆中，堆被划分为新生代和老年代，新生代又被进一步划分为 Eden 区和 Survivor 区，最后 Survivor 由 From Survivor 和 To Survivor 组成。&lt;/p&gt;
&lt;p&gt;当我们新建一个对象时，对象会被优先分配到新生代的 Eden 区中，这时虚拟机会给对象定义一个对象年龄计数器（通过参数 -XX:MaxTenuringThreshold 设置）。&lt;/p&gt;
&lt;p&gt;同时，也有另外一种情况，当 Eden 空间不足时，虚拟机将会执行一个新生代的垃圾回收（Minor GC）。这时 JVM 会把存活的对象转移到 Survivor 中，并给对象的年龄 +1。对象在 Survivor 中同样也会经历 MinorGC，每经过一次 MinorGC，对象的年龄将会 +1。&lt;/p&gt;
&lt;p&gt;当然了，内存空间也是有设置阈值的，可以通过参数 -XX:PetenureSizeThreshold 设置直接被分配到老年代的最大对象，这时如果分配的对象超过了设置的阀值，对象就会直接被分配到老年代，这样做的好处就是可以减少新生代的垃圾回收。&lt;/p&gt;
&lt;h2 id=&#34;43-查看-jvm-堆内存分配&#34;&gt;4.3 查看 JVM 堆内存分配
&lt;/h2&gt;&lt;p&gt;我们知道了一个对象从创建至回收到堆中的过程，接下来我们再来了解下 JVM 堆内存是如何分配的。在默认不配置 JVM 堆内存大小的情况下，JVM 根据默认值来配置当前内存大小。我们可以通过以下命令来查看堆内存配置的默认值&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;java -XX:+PrintFlagsFinal -version | grep HeapSize
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;jmap -heap 17284
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/08.png&#34;
	width=&#34;803&#34;
	height=&#34;118&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/08_hu_7c5bced8d3273ff.png 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/08_hu_b253fedce401b7a7.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;680&#34;
		data-flex-basis=&#34;1633px&#34;
	
&gt;
&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/09.png&#34;
	width=&#34;704&#34;
	height=&#34;675&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/09_hu_550c57c5c3be77d4.png 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/09_hu_bde5f9933af8d61.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;104&#34;
		data-flex-basis=&#34;250px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;通过命令，我们可以获得在这台机器上启动的 JVM 默认最大堆内存为 1953MB，初始化大小为 124MB。&lt;/p&gt;
&lt;p&gt;在 JDK1.7 中，默认情况下年轻代和老年代的比例是 1:2，我们可以通过–XX:NewRatio 重置该配置项。年轻代中的 Eden 和 To Survivor、From Survivor 的比例是 8:1:1，我们可以通过 -XX:SurvivorRatio 重置该配置项。&lt;/p&gt;
&lt;p&gt;在 JDK1.7 中如果开启了 -XX:+UseAdaptiveSizePolicy 配置项，JVM 将会动态调整 Java 堆中各个区域的大小以及进入老年代的年龄，–XX:NewRatio 和 -XX:SurvivorRatio 将会失效，而 JDK1.8 是默认开启 -XX:+UseAdaptiveSizePolicy 配置项的。&lt;/p&gt;
&lt;p&gt;还有，在 JDK1.8 中，不要随便关闭 UseAdaptiveSizePolicy 配置项，除非你已经对初始化堆内存 / 最大堆内存、年轻代 / 老年代以及 Eden 区 /Survivor 区有非常明确的规划了。否则 JVM 将会分配最小堆内存，年轻代和老年代按照默认比例 1:2 进行分配，年轻代中的 Eden 和 Survivor 则按照默认比例 8:2 进行分配。这个内存分配未必是应用服务的最佳配置，因此可能会给应用服务带来严重的性能问题。&lt;/p&gt;
&lt;h2 id=&#34;44-jvm-内存分配的调优过程&#34;&gt;4.4 JVM 内存分配的调优过程
&lt;/h2&gt;&lt;p&gt;我们先使用 JVM 的默认配置，观察应用服务的运行情况，下面我将结合一个实际案例来讲述。现模拟一个抢购接口，假设需要满足一个 5W 的并发请求，且每次请求会产生 20KB 对象，我们可以通过千级并发创建一个 1MB 对象的接口来模拟万级并发请求产生大量对象的场景，具体代码如下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;@RequestMapping(value = &amp;#34;/test1&amp;#34;)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	public String test1(HttpServletRequest request) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		List&amp;lt;Byte[]&amp;gt; temp = new ArrayList&amp;lt;Byte[]&amp;gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		Byte[] b = new Byte[1024*1024];
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		temp.add(b);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		return &amp;#34;success&amp;#34;;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;441-ab-压测&#34;&gt;4.4.1 AB 压测
&lt;/h3&gt;&lt;p&gt;分别对应用服务进行压力测试，以下是请求接口的吞吐量和响应时间在不同并发用户数下的变化情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/10.jpeg&#34;
	width=&#34;980&#34;
	height=&#34;607&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/10_hu_75b7a89e65e02426.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/10_hu_1eeef079542fa6df.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;161&#34;
		data-flex-basis=&#34;387px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;可以看到，当并发数量到了一定值时，吞吐量就上不去了，响应时间也迅速增加。那么，在 JVM 内部运行又是怎样的呢？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;分析 GC 日志&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此时我们可以通过 GC 日志查看具体的回收日志。我们可以通过设置 VM 配置参数，将运行期间的 GC 日志 dump 下来，具体配置参数如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-XX:+PrintGCTimeStamps -XX:+PrintGCDetails -Xloggc:/log/heapTest.log
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;以下是各个配置项的说明：&lt;/p&gt;
&lt;p&gt;-XX:PrintGCTimeStamps：打印 GC 具体时间；
-XX:PrintGCDetails ：打印出 GC 详细日志；
-Xloggc: path：GC 日志生成路径。&lt;/p&gt;
&lt;h2 id=&#34;45-参考指标&#34;&gt;4.5 参考指标
&lt;/h2&gt;&lt;p&gt;我们可以将某些指标的预期值作为参考指标，上面的 GC 频率就是其中之一，那么还有哪些指标可以为我们提供一些具体的调优方向呢？&lt;/p&gt;
&lt;p&gt;GC 频率：高频的 FullGC 会给系统带来非常大的性能消耗，虽然 MinorGC 相对 FullGC 来说好了许多，但过多的 MinorGC 仍会给系统带来压力。&lt;/p&gt;
&lt;p&gt;内存：这里的内存指的是堆内存大小，堆内存又分为年轻代内存和老年代内存。首先我们要分析堆内存大小是否合适，其实是分析年轻代和老年代的比例是否合适。如果内存不足或分配不均匀，会增加 FullGC，严重的将导致 CPU 持续爆满，影响系统性能。&lt;/p&gt;
&lt;p&gt;吞吐量：频繁的 FullGC 将会引起线程的上下文切换，增加系统的性能开销，从而影响每次处理的线程请求，最终导致系统的吞吐量下降。&lt;/p&gt;
&lt;p&gt;延时：JVM 的 GC 持续时间也会影响到每次请求的响应时间。&lt;/p&gt;
&lt;h1 id=&#34;5-内存持续上升我该如何排查问题&#34;&gt;5. 内存持续上升，我该如何排查问题？
&lt;/h1&gt;&lt;p&gt;** 常用的监控和诊断内存工具**&lt;/p&gt;
&lt;p&gt;工欲善其事，必先利其器。平时排查内存性能瓶颈时，我们往往需要用到一些 Linux 命令行或者 JDK 工具来辅助我们监测系统或者虚拟机内存的使用情况，下面我就来介绍几种好用且常用的工具。&lt;/p&gt;
&lt;h2 id=&#34;51-linux-命令行工具&#34;&gt;5.1 Linux 命令行工具
&lt;/h2&gt;&lt;h3 id=&#34;511-top命令&#34;&gt;5.1.1 top命令
&lt;/h3&gt;&lt;p&gt;top 命令是我们在 Linux 下最常用的命令之一，它可以实时显示正在执行进程的 CPU 使用率、内存使用率以及系统负载等信息。其中上半部分显示的是系统的统计信息，下半部分显示的是进程的使用率统计信息。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/11.jpeg&#34;
	width=&#34;1778&#34;
	height=&#34;660&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/11_hu_a90cde2f784a289c.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/11_hu_51708e1708a17aa6.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;269&#34;
		data-flex-basis=&#34;646px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;除了简单的 top 之外，我们还可以通过 top -Hp pid 查看具体线程使用系统资源情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/12.jpeg&#34;
	width=&#34;1630&#34;
	height=&#34;780&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/12_hu_1e314327c118367f.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/12_hu_9661b471583eb2f2.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;208&#34;
		data-flex-basis=&#34;501px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;512-vmstat-命令&#34;&gt;5.1.2 vmstat 命令
&lt;/h3&gt;&lt;p&gt;vmstat 是一款指定采样周期和次数的功能性监测工具，我们可以看到，它不仅可以统计内存的使用情况，还可以观测到 CPU 的使用率、swap 的使用情况。但 vmstat 一般很少用来查看内存的使用情况，而是经常被用来观察进程的上下文切换。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/13.jpeg&#34;
	width=&#34;1488&#34;
	height=&#34;178&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/13_hu_d7d6c247949eab9.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/13_hu_b77e0e825c4b74df.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;835&#34;
		data-flex-basis=&#34;2006px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;r：等待运行的进程数；&lt;/li&gt;
&lt;li&gt;b：处于非中断睡眠状态的进程数；&lt;/li&gt;
&lt;li&gt;swpd：虚拟内存使用情况；&lt;/li&gt;
&lt;li&gt;free：空闲的内存；&lt;/li&gt;
&lt;li&gt;buff：用来作为缓冲的内存数；&lt;/li&gt;
&lt;li&gt;si：从磁盘交换到内存的交换页数量；&lt;/li&gt;
&lt;li&gt;so：从内存交换到磁盘的交换页数量；&lt;/li&gt;
&lt;li&gt;bi：发送到块设备的块数；&lt;/li&gt;
&lt;li&gt;bo：从块设备接收到的块数；&lt;/li&gt;
&lt;li&gt;in：每秒中断数；&lt;/li&gt;
&lt;li&gt;cs：每秒上下文切换次数；&lt;/li&gt;
&lt;li&gt;us：用户 CPU 使用时间；&lt;/li&gt;
&lt;li&gt;sy：内核 CPU 系统使用时间；&lt;/li&gt;
&lt;li&gt;id：空闲时间；&lt;/li&gt;
&lt;li&gt;wa：等待 I/O 时间；&lt;/li&gt;
&lt;li&gt;st：运行虚拟机窃取的时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;513-pidstat-命令&#34;&gt;5.1.3 pidstat 命令
&lt;/h3&gt;&lt;p&gt;pidstat 是 Sysstat 中的一个组件，也是一款功能强大的性能监测工具，我们可以通过命令：yum install sysstat 安装该监控组件。之前的 top 和 vmstat 两个命令都是监测进程的内存、CPU 以及 I/O 使用情况，而 pidstat 命令则是深入到线程级别。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/14.jpeg&#34;
	width=&#34;1562&#34;
	height=&#34;460&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/14_hu_1eb17303c131f777.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/14_hu_917f55bd1947fec2.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;339&#34;
		data-flex-basis=&#34;814px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;通过 pidstat -help 命令，我们可以查看到有以下几个常用的参数来监测线程的性能：&lt;/p&gt;
&lt;p&gt;常用参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-u：默认的参数，显示各个进程的 cpu 使用情况；&lt;/li&gt;
&lt;li&gt;-r：显示各个进程的内存使用情况；&lt;/li&gt;
&lt;li&gt;-d：显示各个进程的 I/O 使用情况；&lt;/li&gt;
&lt;li&gt;-w：显示每个进程的上下文切换情况；&lt;/li&gt;
&lt;li&gt;-p：指定进程号；&lt;/li&gt;
&lt;li&gt;-t：显示进程中线程的统计信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们可以通过相关命令（例如 ps 或 jps）查询到相关进程 ID，再运行以下命令来监测该进程的内存使用情况：&lt;/p&gt;
&lt;p&gt;其中 pidstat 的参数 -p 用于指定进程 ID，-r 表示监控内存的使用情况，1 表示每秒的意思，3 则表示采样次数。&lt;/p&gt;
&lt;p&gt;其中显示的几个关键指标的含义是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Minflt/s：任务每秒发生的次要错误，不需要从磁盘中加载页；&lt;/li&gt;
&lt;li&gt;Majflt/s：任务每秒发生的主要错误，需要从磁盘中加载页；&lt;/li&gt;
&lt;li&gt;VSZ：虚拟地址大小，虚拟内存使用 KB；&lt;/li&gt;
&lt;li&gt;RSS：常驻集合大小，非交换区内存使用 KB。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果我们需要继续查看该进程下的线程内存使用率，则在后面添加 -t 指令即可：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/15.jpeg&#34;
	width=&#34;1574&#34;
	height=&#34;694&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/15_hu_651e7163669b1030.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/15_hu_fb35cca37d11c631.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;226&#34;
		data-flex-basis=&#34;544px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;我们知道，Java 是基于 JVM 上运行的，大部分内存都是在 JVM 的用户内存中创建的，所以除了通过以上 Linux 命令来监控整个服务器内存的使用情况之外，我们更需要知道 JVM 中的内存使用情况。JDK 中就自带了很多命令工具可以监测到 JVM 的内存分配以及使用情况。&lt;/p&gt;
&lt;h2 id=&#34;52-jdk-工具&#34;&gt;5.2 JDK 工具
&lt;/h2&gt;&lt;h3 id=&#34;521-jstat-命令&#34;&gt;5.2.1 jstat 命令
&lt;/h3&gt;&lt;p&gt;jstat 可以监测 Java 应用程序的实时运行情况，包括堆内存信息以及垃圾回收信息。我们可以运行 jstat -help 查看一些关键参数信息：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/16.jpeg&#34;
	width=&#34;1550&#34;
	height=&#34;610&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/16_hu_f558e6978fd69ba0.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/16_hu_e249d14e30ae9383.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;254&#34;
		data-flex-basis=&#34;609px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;再通过 jstat -option 查看 jstat 有哪些操作：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/17.jpeg&#34;
	width=&#34;1506&#34;
	height=&#34;386&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/17_hu_54eac0f0130dd4e1.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/17_hu_6552ca536d064048.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;390&#34;
		data-flex-basis=&#34;936px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-class：显示 ClassLoad 的相关信息；&lt;/li&gt;
&lt;li&gt;-compiler：显示 JIT 编译的相关信息；&lt;/li&gt;
&lt;li&gt;-gc：显示和 gc 相关的堆信息；&lt;/li&gt;
&lt;li&gt;-gccapacity：显示各个代的容量以及使用情况；&lt;/li&gt;
&lt;li&gt;-gcmetacapacity：显示 Metaspace 的大小；&lt;/li&gt;
&lt;li&gt;-gcnew：显示新生代信息；&lt;/li&gt;
&lt;li&gt;-gcnewcapacity：显示新生代大小和使用情况；&lt;/li&gt;
&lt;li&gt;-gcold：显示老年代和永久代的信息；&lt;/li&gt;
&lt;li&gt;-gcoldcapacity ：显示老年代的大小；&lt;/li&gt;
&lt;li&gt;-gcutil：显示垃圾收集信息；&lt;/li&gt;
&lt;li&gt;-gccause：显示垃圾回收的相关信息（通 -gcutil），同时显示最后一次或当前正在发生的垃圾回收的诱因；&lt;/li&gt;
&lt;li&gt;-printcompilation：输出 JIT 编译的方法信息。
它的功能比较多，在这里我例举一个常用功能，如何使用 jstat 查看堆内存的使用情况。我们可以用 jstat -gc pid 查看：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/18.jpeg&#34;
	width=&#34;2464&#34;
	height=&#34;128&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/18_hu_d553fd3367241eff.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/18_hu_bb605c42b510e5e0.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;1925&#34;
		data-flex-basis=&#34;4620px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;S0C：年轻代中 To Survivor 的容量（单位 KB）；&lt;/li&gt;
&lt;li&gt;S1C：年轻代中 From Survivor 的容量（单位 KB）；&lt;/li&gt;
&lt;li&gt;S0U：年轻代中 To Survivor 目前已使用空间（单位 KB）；&lt;/li&gt;
&lt;li&gt;S1U：年轻代中 From Survivor 目前已使用空间（单位 KB）；&lt;/li&gt;
&lt;li&gt;EC：年轻代中 Eden 的容量（单位 KB）；&lt;/li&gt;
&lt;li&gt;EU：年轻代中 Eden 目前已使用空间（单位 KB）；&lt;/li&gt;
&lt;li&gt;OC：Old 代的容量（单位 KB）；&lt;/li&gt;
&lt;li&gt;OU：Old 代目前已使用空间（单位 KB）；&lt;/li&gt;
&lt;li&gt;MC：Metaspace 的容量（单位 KB）；&lt;/li&gt;
&lt;li&gt;MU：Metaspace 目前已使用空间（单位 KB）；&lt;/li&gt;
&lt;li&gt;YGC：从应用程序启动到采样时年轻代中 gc 次数；&lt;/li&gt;
&lt;li&gt;YGCT：从应用程序启动到采样时年轻代中 gc 所用时间 (s)；&lt;/li&gt;
&lt;li&gt;FGC：从应用程序启动到采样时 old 代（全 gc）gc 次数；&lt;/li&gt;
&lt;li&gt;FGCT：从应用程序启动到采样时 old 代（全 gc）gc 所用时间 (s)；&lt;/li&gt;
&lt;li&gt;GCT：从应用程序启动到采样时 gc 用的总时间 (s)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;522-jstack-命令&#34;&gt;5.2.2 jstack 命令
&lt;/h3&gt;&lt;p&gt;它是一种线程堆栈分析工具，最常用的功能就是使用 jstack pid 命令查看线程的堆栈信息，通常会结合 top -Hp pid 或 pidstat -p pid -t 一起查看具体线程的状态，也经常用来排查一些死锁的异常。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/19.jpeg&#34;
	width=&#34;2328&#34;
	height=&#34;414&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/19_hu_2e3bf420b16d8028.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/19_hu_6b9b9ec823350b6f.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;562&#34;
		data-flex-basis=&#34;1349px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;每个线程堆栈的信息中，都可以查看到线程 ID、线程的状态（wait、sleep、running 等状态）以及是否持有锁等。&lt;/p&gt;
&lt;h3 id=&#34;523-jmap-命令&#34;&gt;5.2.3 jmap 命令
&lt;/h3&gt;&lt;p&gt;我们可以用 jmap 来查看堆内存初始化配置信息以及堆内存的使用情况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/20.jpeg&#34;
	width=&#34;1206&#34;
	height=&#34;1304&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/20_hu_c8b4b2d72163df32.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/20_hu_777162f49b51462b.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;92&#34;
		data-flex-basis=&#34;221px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;我们可以使用 jmap -histo[:live] pid 查看堆内存中的对象数目、大小统计直方图，如果带上 live 则只统计活对象：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/21.jpeg&#34;
	width=&#34;1516&#34;
	height=&#34;1028&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/21_hu_31acdcda27f4dabd.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/21_hu_893606bc33d0228d.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;147&#34;
		data-flex-basis=&#34;353px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;我们可以通过 jmap 命令把堆内存的使用情况 dump 到文件中：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/22.jpeg&#34;
	width=&#34;1310&#34;
	height=&#34;144&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/22_hu_21ec6e093cf24eff.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%984/22_hu_d71ad6aa00e123cb.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;909&#34;
		data-flex-basis=&#34;2183px&#34;
	
&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Java性能调优3</title>
        <link>https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/</link>
        <pubDate>Fri, 26 Feb 2021 10:17:05 +0800</pubDate>
        
        <guid>https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/</guid>
        <description>&lt;h1 id=&#34;1多线程之锁优化&#34;&gt;1.多线程之锁优化
&lt;/h1&gt;&lt;h2 id=&#34;11-深入了解synchronized同步锁的优化方法&#34;&gt;1.1 深入了解Synchronized同步锁的优化方法
&lt;/h2&gt;&lt;p&gt;在并发编程中，多个线程访问同一个共享资源时，我们必须考虑如何维护数据的原子性。在 JDK1.5 之前，Java 是依靠 Synchronized 关键字实现锁功能来做到这点的。Synchronized 是 JVM 实现的一种内置锁，锁的获取和释放是由 JVM 隐式实现。&lt;/p&gt;
&lt;p&gt;到了 JDK1.5 版本，并发包中新增了 Lock 接口来实现锁功能，它提供了与 Synchronized 关键字类似的同步功能，只是在使用时需要显示获取和释放锁。&lt;/p&gt;
&lt;p&gt;Lock 同步锁是基于 Java 实现的，而 Synchronized 是基于底层操作系统的 Mutex Lock 实现的，每次获取和释放锁操作都会带来用户态和内核态的切换，从而增加系统性能开销。因此，在锁竞争激烈的情况下，Synchronized 同步锁在性能上就表现得非常糟糕，它也常被大家称为重量级锁。&lt;/p&gt;
&lt;p&gt;特别是在单个线程重复申请锁的情况下，JDK1.5 版本的 Synchronized 锁性能要比 Lock 的性能差很多。例如，在 Dubbo 基于 Netty 实现的通信中，消费端向服务端通信之后，由于接收返回消息是异步，所以需要一个线程轮询监听返回信息。而在接收消息时，就需要用到锁来确保 request session 的原子性。如果我们这里使用 Synchronized 同步锁，那么每当同一个线程请求锁资源时，都会发生一次用户态和内核态的切换。&lt;/p&gt;
&lt;p&gt;到了 JDK1.6 版本之后，Java 对 Synchronized 同步锁做了充分的优化，甚至在某些场景下，它的性能已经超越了 Lock 同步锁。这一讲我们就来看看 Synchronized 同步锁究竟是通过了哪些优化，实现了性能地提升。&lt;/p&gt;
&lt;h3 id=&#34;111-synchronized-同步锁实现原理&#34;&gt;1.1.1 Synchronized 同步锁实现原理
&lt;/h3&gt;&lt;p&gt;了解 Synchronized 同步锁优化之前，我们先来看看它的底层实现原理，这样可以帮助我们更好地理解后面的内容。&lt;/p&gt;
&lt;p&gt;通常 Synchronized 实现同步锁的方式有两种，一种是修饰方法，一种是修饰方法块。以下就是通过 Synchronized 实现的两种同步方法加锁的方式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 关键字在实例方法上，锁为当前实例
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	public synchronized void method1() {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    // code
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	// 关键字在代码块上，锁为括号里面的对象
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	public void method2() {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    Object o = new Object();
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    synchronized (o) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	        // code
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;下面我们可以通过反编译看下具体字节码的实现，运行以下反编译命令，就可以输出我们想要的字节码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;javac -encoding UTF-8 SyncTest.java  // 先运行编译 class 文件命令
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;javap -v SyncTest.class // 再通过 javap 打印出字节文件
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;通过输出的字节码，你会发现：Synchronized 在修饰同步代码块时，是由 monitorenter 和 monitorexit 指令来实现同步的。进入 monitorenter 指令后，线程将持有 Monitor 对象，退出 monitorenter 指令后，线程将释放该 Monitor 对象。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;66
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;67
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;68
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;69
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;70
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;71
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;72
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;73
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;74
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;75
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;76
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;77
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;78
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;79
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;80
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;81
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;82
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;83
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;84
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;85
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gdscript3&#34; data-lang=&#34;gdscript3&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;mi&#34;&gt;12&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;多线程之锁优化（上）：深入了解&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Synchronized同步锁的优化方法&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;mi&#34;&gt;2019&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;06&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;15&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;刘超&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Java性能调优实战&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;进入课程&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;讲述：李良&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;时长&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;13&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;11&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;大小&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;12.07&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;M&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;你好，我是刘超。从这讲开始，我们就正式进入到第三模块——多线程性能调优。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;在并发编程中，多个线程访问同一个共享资源时，我们必须考虑如何维护数据的原子性。在&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;JDK1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;之前，&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Java&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;是依靠&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Synchronized&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;关键字实现锁功能来做到这点的。&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Synchronized&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;是&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;JVM&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;实现的一种内置锁，锁的获取和释放是由&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;JVM&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;隐式实现。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;到了&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;JDK1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;版本，并发包中新增了&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Lock&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;接口来实现锁功能，它提供了与&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Synchronized&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;关键字类似的同步功能，只是在使用时需要显示获取和释放锁。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Lock&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;同步锁是基于&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Java&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;实现的，而&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Synchronized&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;是基于底层操作系统的&lt;/span&gt; &lt;span class=&#34;ne&#34;&gt;Mutex&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Lock&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;实现的，每次获取和释放锁操作都会带来用户态和内核态的切换，从而增加系统性能开销。因此，在锁竞争激烈的情况下，&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Synchronized&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;同步锁在性能上就表现得非常糟糕，它也常被大家称为重量级锁。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;特别是在单个线程重复申请锁的情况下，&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;JDK1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;版本的&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Synchronized&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;锁性能要比&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Lock&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;的性能差很多。例如，在&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Dubbo&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;基于&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Netty&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;实现的通信中，消费端向服务端通信之后，由于接收返回消息是异步，所以需要一个线程轮询监听返回信息。而在接收消息时，就需要用到锁来确保&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;request&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;session&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;的原子性。如果我们这里使用&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Synchronized&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;同步锁，那么每当同一个线程请求锁资源时，都会发生一次用户态和内核态的切换。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;到了&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;JDK1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;版本之后，&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Java&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;对&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Synchronized&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;同步锁做了充分的优化，甚至在某些场景下，它的性能已经超越了&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Lock&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;同步锁。这一讲我们就来看看&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Synchronized&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;同步锁究竟是通过了哪些优化，实现了性能地提升。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;Synchronized&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;同步锁实现原理&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;了解&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Synchronized&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;同步锁优化之前，我们先来看看它的底层实现原理，这样可以帮助我们更好地理解后面的内容。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;通常&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Synchronized&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;实现同步锁的方式有两种，一种是修饰方法，一种是修饰方法块。以下就是通过&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Synchronized&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;实现的两种同步方法加锁的方式：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;关键字在实例方法上，锁为当前实例&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;synchronized&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;method1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;code&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;关键字在代码块上，锁为括号里面的对象&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;method2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;ne&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;o&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;ne&#34;&gt;Object&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;n&#34;&gt;synchronized&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	        &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;code&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;下面我们可以通过反编译看下具体字节码的实现，运行以下反编译命令，就可以输出我们想要的字节码：&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;javac&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;encoding&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;UTF&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SyncTest&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;java&lt;/span&gt;  &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;先运行编译&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;文件命令&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;javap&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SyncTest&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;再通过&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;javap&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;打印出字节文件&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;通过输出的字节码，你会发现：&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Synchronized&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;在修饰同步代码块时，是由&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;monitorenter&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;和&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;monitorexit&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;指令来实现同步的。进入&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;monitorenter&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;指令后，线程将持有&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Monitor&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;对象，退出&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;monitorenter&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;指令后，线程将释放该&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Monitor&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;对象。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;method2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;descriptor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;V&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;flags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ACC_PUBLIC&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;Code&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;n&#34;&gt;stack&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;locals&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args_size&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;new&lt;/span&gt;           &lt;span class=&#34;c1&#34;&gt;#2                  &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dup&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;invokespecial&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;#1                  &lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;mi&#34;&gt;7&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;astore_1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;aload_1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;mi&#34;&gt;9&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dup&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;astore_2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;mi&#34;&gt;11&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;monitorenter&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;monitorenter&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;指令&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;mi&#34;&gt;12&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;aload_2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;mi&#34;&gt;13&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;monitorexit&lt;/span&gt;  &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;monitorexit&lt;/span&gt;  &lt;span class=&#34;err&#34;&gt;指令&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;mi&#34;&gt;14&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;goto&lt;/span&gt;          &lt;span class=&#34;mi&#34;&gt;22&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;mi&#34;&gt;17&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;astore_3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;mi&#34;&gt;18&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;aload_2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;mi&#34;&gt;19&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;monitorexit&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;aload_3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;mi&#34;&gt;21&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;athrow&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;mi&#34;&gt;22&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;table&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         &lt;span class=&#34;n&#34;&gt;from&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;to&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;type&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;mi&#34;&gt;12&lt;/span&gt;    &lt;span class=&#34;mi&#34;&gt;14&lt;/span&gt;    &lt;span class=&#34;mi&#34;&gt;17&lt;/span&gt;   &lt;span class=&#34;n&#34;&gt;any&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;mi&#34;&gt;17&lt;/span&gt;    &lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;    &lt;span class=&#34;mi&#34;&gt;17&lt;/span&gt;   &lt;span class=&#34;n&#34;&gt;any&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;n&#34;&gt;LineNumberTable&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;line&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;18&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;line&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;19&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;line&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;21&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;12&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;line&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;22&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;22&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;n&#34;&gt;StackMapTable&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;number_of_entries&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;frame_type&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;255&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;full_frame&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &lt;span class=&#34;n&#34;&gt;offset_delta&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;17&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &lt;span class=&#34;n&#34;&gt;locals&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;com&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;demo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;io&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SyncTest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;java&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lang&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;ne&#34;&gt;Object&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;java&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lang&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;ne&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &lt;span class=&#34;n&#34;&gt;stack&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;java&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lang&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Throwable&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;frame_type&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;250&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;chop&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;          &lt;span class=&#34;n&#34;&gt;offset_delta&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;再来看以下同步方法的字节码，你会发现：当 Synchronized 修饰同步方法时，并没有发现 monitorenter 和 monitorexit 指令，而是出现了一个 ACC_SYNCHRONIZED 标志。&lt;/p&gt;
&lt;p&gt;这是因为 JVM 使用了 ACC_SYNCHRONIZED 访问标志来区分一个方法是否是同步方法。当方法调用时，调用指令将会检查该方法是否被设置 ACC_SYNCHRONIZED 访问标志。如果设置了该标志，执行线程将先持有 Monitor 对象，然后再执行方法。在该方法运行期间，其它线程将无法获取到该 Mointor 对象，当方法执行完成后，再释放该 Monitor 对象。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public synchronized void method1();
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    descriptor: ()V
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    flags: ACC_PUBLIC, ACC_SYNCHRONIZED // ACC_SYNCHRONIZED 标志
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    Code:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      stack=0, locals=1, args_size=1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;         0: return
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      LineNumberTable:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        line 8: 0
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;通过以上的源码，我们再来看看 Synchronized 修饰方法是怎么实现锁原理的。&lt;/p&gt;
&lt;p&gt;JVM 中的同步是基于进入和退出管程（Monitor）对象实现的。每个对象实例都会有一个 Monitor，Monitor 可以和对象一起创建、销毁。Monitor 是由 ObjectMonitor 实现，而 ObjectMonitor 是由 C++ 的 ObjectMonitor.hpp 文件实现，如下所示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ObjectMonitor() {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   _header = NULL;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   _count = 0; // 记录个数
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   _waiters = 0,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   _recursions = 0;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   _object = NULL;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   _owner = NULL;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   _WaitSet = NULL; // 处于 wait 状态的线程，会被加入到 _WaitSet
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   _WaitSetLock = 0 ;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   _Responsible = NULL ;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   _succ = NULL ;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   _cxq = NULL ;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   FreeNext = NULL ;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   _EntryList = NULL ; // 处于等待锁 block 状态的线程，会被加入到该列表
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   _SpinFreq = 0 ;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   _SpinClock = 0 ;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;   OwnerIsThread = 0 ;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;当多个线程同时访问一段同步代码时，多个线程会先被存放在 EntryList 集合中，处于 block 状态的线程，都会被加入到该列表。接下来当线程获取到对象的 Monitor 时，Monitor 是依靠底层操作系统的 Mutex Lock 来实现互斥的，线程申请 Mutex 成功，则持有该 Mutex，其它线程将无法获取到该 Mutex。&lt;/p&gt;
&lt;p&gt;如果线程调用 wait() 方法，就会释放当前持有的 Mutex，并且该线程会进入 WaitSet 集合中，等待下一次被唤醒。如果当前线程顺利执行完方法，也将释放 Mutex。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/01.jpeg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;看完上面的讲解，相信你对同步锁的实现原理已经有个深入的了解了。总结来说就是，同步锁在这种实现方式中，因 Monitor 是依赖于底层的操作系统实现，存在用户态与内核态之间的切换，所以增加了性能开销。&lt;/p&gt;
&lt;h3 id=&#34;112-锁升级优化&#34;&gt;1.1.2 锁升级优化
&lt;/h3&gt;&lt;p&gt;为了提升性能，JDK1.6 引入了&lt;strong&gt;偏向锁、轻量级锁、重量级&lt;/strong&gt;锁概念，来减少锁竞争带来的上下文切换，而正是新增的 Java 对象头实现了锁升级功能。&lt;/p&gt;
&lt;p&gt;当 Java 对象被 Synchronized 关键字修饰成为同步锁后，围绕这个锁的一系列升级操作都将和 Java 对象头有关。&lt;/p&gt;
&lt;h4 id=&#34;1121-java-对象头&#34;&gt;1.1.2.1 Java 对象头
&lt;/h4&gt;&lt;p&gt;在 JDK1.6 JVM 中，对象实例在堆内存中被分为了三个部分：对象头、实例数据和对齐填充。其中 Java 对象头由 Mark Word、指向类的指针以及数组长度三部分组成。&lt;/p&gt;
&lt;p&gt;Mark Word 记录了对象和锁有关的信息。Mark Word 在 64 位 JVM 中的长度是 64bit，我们可以一起看下 64 位 JVM 的存储结构是怎么样的。如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/02.jpeg&#34;
	width=&#34;998&#34;
	height=&#34;364&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/02_hu_36e938dc7874938f.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/02_hu_cf1851ffee1ec19.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;274&#34;
		data-flex-basis=&#34;658px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;锁升级功能主要依赖于 Mark Word 中的锁标志位和释放偏向锁标志位，Synchronized 同步锁就是从偏向锁开始的，随着竞争越来越激烈，偏向锁升级到轻量级锁，最终升级到重量级锁。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;偏向锁
偏向锁主要用来优化同一线程多次申请同一个锁的竞争。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在某些情况下，大部分时间是同一个线程竞争锁资源，例如，在创建一个线程并在线程中执行循环监听的场景下，或单线程操作一个线程安全集合时，同一线程每次都需要获取和释放锁，每次操作都会发生用户态与内核态的切换。&lt;/p&gt;
&lt;p&gt;偏向锁的作用就是，当一个线程再次访问这个同步代码或方法时，该线程只需去对象头的 Mark Word 中去判断一下是否有偏向锁指向它的 ID，无需再进入 Monitor 去竞争对象了。当对象被当做同步锁并有一个线程抢到了锁时，锁标志位还是 01，“是否偏向锁”标志位设置为 1，并且记录抢到锁的线程 ID，表示进入偏向锁状态。&lt;/p&gt;
&lt;p&gt;一旦出现其它线程竞争锁资源时，偏向锁就会被撤销。偏向锁的撤销需要等待全局安全点，暂停持有该锁的线程，同时检查该线程是否还在执行该方法，如果是，则升级锁，反之则被其它线程抢占。&lt;/p&gt;
&lt;p&gt;下图中红线流程部分为偏向锁获取和撤销流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/03.jpeg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;因此，在高并发场景下，当大量线程同时竞争同一个锁资源时，偏向锁就会被撤销，发生 stop the word 后， 开启偏向锁无疑会带来更大的性能开销，这时我们可以通过添加 JVM 参数关闭偏向锁来调优系统性能，示例代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-XX:-UseBiasedLocking // 关闭偏向锁（默认打开）
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;或&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-XX:+UseHeavyMonitors  // 设置重量级锁
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;轻量级锁&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当有另外一个线程竞争获取这个锁时，由于该锁已经是偏向锁，当发现对象头 Mark Word 中的线程 ID 不是自己的线程 ID，就会进行 CAS 操作获取锁，如果获取成功，直接替换 Mark Word 中的线程 ID 为自己的 ID，该锁会保持偏向锁状态；如果获取锁失败，代表当前锁有一定的竞争，偏向锁将升级为轻量级锁。&lt;/p&gt;
&lt;p&gt;轻量级锁适用于线程交替执行同步块的场景，绝大部分的锁在整个同步周期内都不存在长时间的竞争。&lt;/p&gt;
&lt;p&gt;下图中红线流程部分为升级轻量级锁及操作流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/04.jpeg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;自旋锁与重量级锁&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;轻量级锁 CAS 抢锁失败，线程将会被挂起进入阻塞状态。如果正在持有锁的线程在很短的时间内释放资源，那么进入阻塞状态的线程无疑又要申请锁资源。&lt;/p&gt;
&lt;p&gt;JVM 提供了一种自旋锁，可以通过自旋方式不断尝试获取锁，从而避免线程被挂起阻塞。这是基于大多数情况下，线程持有锁的时间都不会太长，毕竟线程被挂起阻塞可能会得不偿失。&lt;/p&gt;
&lt;p&gt;从 JDK1.7 开始，自旋锁默认启用，自旋次数由 JVM 设置决定，这里我不建议设置的重试次数过多，因为 CAS 重试操作意味着长时间地占用 CPU。&lt;/p&gt;
&lt;p&gt;自旋锁重试之后如果抢锁依然失败，同步锁就会升级至重量级锁，锁标志位改为 10。在这个状态下，未抢到锁的线程都会进入 Monitor，之后会被阻塞在 _WaitSet 队列中。&lt;/p&gt;
&lt;p&gt;下图中红线流程部分为自旋后升级为重量级锁的流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/05.jpeg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;在锁竞争不激烈且锁占用时间非常短的场景下，自旋锁可以提高系统性能。一旦锁竞争激烈或锁占用的时间过长，自旋锁将会导致大量的线程一直处于 CAS 重试状态，占用 CPU 资源，反而会增加系统性能开销。所以自旋锁和重量级锁的使用都要结合实际场景。&lt;/p&gt;
&lt;p&gt;在高负载、高并发的场景下，我们可以通过设置 JVM 参数来关闭自旋锁，优化系统性能，示例代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-XX:-UseSpinning // 参数关闭自旋锁优化 (默认打开) 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;-XX:PreBlockSpin // 参数修改默认的自旋次数。JDK1.7 后，去掉此参数，由 jvm 控制
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;113-动态编译实现锁消除--锁粗化&#34;&gt;1.1.3 动态编译实现锁消除 / 锁粗化
&lt;/h3&gt;&lt;p&gt;除了锁升级优化，Java 还使用了编译器对锁进行优化。JIT 编译器在动态编译同步块的时候，借助了一种被称为逃逸分析的技术，来判断同步块使用的锁对象是否只能够被一个线程访问，而没有被发布到其它线程。&lt;/p&gt;
&lt;p&gt;确认是的话，那么 JIT 编译器在编译这个同步块的时候不会生成 synchronized 所表示的锁的申请与释放的机器码，即消除了锁的使用。在 Java7 之后的版本就不需要手动配置了，该操作可以自动实现。&lt;/p&gt;
&lt;p&gt;锁粗化同理，就是在 JIT 编译器动态编译时，如果发现几个相邻的同步块使用的是同一个锁实例，那么 JIT 编译器将会把这几个同步块合并为一个大的同步块，从而避免一个线程“反复申请、释放同一个锁“所带来的性能开销。&lt;/p&gt;
&lt;h4 id=&#34;1131-减小锁粒度&#34;&gt;1.1.3.1 减小锁粒度
&lt;/h4&gt;&lt;p&gt;除了锁内部优化和编译器优化之外，我们还可以通过代码层来实现锁优化，减小锁粒度就是一种惯用的方法。&lt;/p&gt;
&lt;p&gt;当我们的锁对象是一个数组或队列时，集中竞争一个对象的话会非常激烈，锁也会升级为重量级锁。我们可以考虑将一个数组和队列对象拆成多个小对象，来降低锁竞争，提升并行度。&lt;/p&gt;
&lt;p&gt;最经典的减小锁粒度的案例就是 JDK1.8 之前实现的 ConcurrentHashMap 版本。我们知道，HashTable 是基于一个数组 + 链表实现的，所以在并发读写操作集合时，存在激烈的锁资源竞争，也因此性能会存在瓶颈。而 ConcurrentHashMap 就很很巧妙地使用了分段锁 Segment 来降低锁资源竞争，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/06.jpeg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;减少锁竞争，是优化 Synchronized 同步锁的关键。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;114-本节问题&#34;&gt;1.1.4 本节问题
&lt;/h3&gt;&lt;p&gt;请问以下 Synchronized 同步锁对普通方法和静态方法的修饰有什么区别？&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;/ 修饰普通方法
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	public synchronized void method1() {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    // code
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	// 修饰静态方法
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	public  synchronized static void method2() {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    // code
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;12-深入了解lock同步锁的优化方法&#34;&gt;1.2 深入了解Lock同步锁的优化方法
&lt;/h2&gt;&lt;p&gt;在 JDK1.5 之后，Java 还提供了 Lock 同步锁。那么它有什么优势呢？&lt;/p&gt;
&lt;p&gt;相对于需要 JVM 隐式获取和释放锁的 Synchronized 同步锁，Lock 同步锁（以下简称 Lock 锁）需要的是显示获取和释放锁，这就为获取和释放锁提供了更多的灵活性。Lock 锁的基本操作是通过乐观锁来实现的，但由于 Lock 锁也会在阻塞时被挂起，因此它依然属于悲观锁。我们可以通过一张图来简单对比下两个同步锁，了解下各自的特点：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/07.jpeg&#34;
	width=&#34;1238&#34;
	height=&#34;660&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/07_hu_d5568fe0c3d2f78e.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/07_hu_5ce86b7886c5d03c.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;187&#34;
		data-flex-basis=&#34;450px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;从性能方面上来说，在并发量不高、竞争不激烈的情况下，Synchronized 同步锁由于具有分级锁的优势，性能上与 Lock 锁差不多；但在高负载、高并发的情况下，Synchronized 同步锁由于竞争激烈会升级到重量级锁，性能则没有 Lock 锁稳定。&lt;/p&gt;
&lt;h3 id=&#34;121-lock-锁的实现原理&#34;&gt;1.2.1 Lock 锁的实现原理
&lt;/h3&gt;&lt;p&gt;Lock 锁是基于 Java 实现的锁，Lock 是一个接口类，常用的实现类有 ReentrantLock、ReentrantReadWriteLock（RRW），它们都是依赖 AbstractQueuedSynchronizer（AQS）类实现的。&lt;/p&gt;
&lt;p&gt;AQS 类结构中包含一个基于链表实现的等待队列（CLH 队列），用于存储所有阻塞的线程，AQS 中还有一个 state 变量，该变量对 ReentrantLock 来说表示加锁状态。&lt;/p&gt;
&lt;p&gt;该队列的操作均通过 CAS 操作实现，我们可以通过一张图来看下整个获取锁的流程。
&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/08.jpeg&#34;
	width=&#34;836&#34;
	height=&#34;1240&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/08_hu_d0aea007cb099749.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/08_hu_d3a38632105b066a.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;67&#34;
		data-flex-basis=&#34;161px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;122-锁分离优化-lock-同步锁&#34;&gt;1.2.2 锁分离优化 Lock 同步锁
&lt;/h3&gt;&lt;p&gt;虽然 Lock 锁的性能稳定，但也并不是所有的场景下都默认使用 ReentrantLock 独占锁来实现线程同步。&lt;/p&gt;
&lt;p&gt;我们知道，对于同一份数据进行读写，如果一个线程在读数据，而另一个线程在写数据，那么读到的数据和最终的数据就会不一致；如果一个线程在写数据，而另一个线程也在写数据，那么线程前后看到的数据也会不一致。这个时候我们可以在读写方法中加入互斥锁，来保证任何时候只能有一个线程进行读或写操作。&lt;/p&gt;
&lt;p&gt;在大部分业务场景中，读业务操作要远远大于写业务操作。而在多线程编程中，读操作并不会修改共享资源的数据，如果多个线程仅仅是读取共享资源，那么这种情况下其实没有必要对资源进行加锁。如果使用互斥锁，反倒会影响业务的并发性能，那么在这种场景下，有没有什么办法可以优化下锁的实现方式呢？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;读写锁 ReentrantReadWriteLock&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;针对这种读多写少的场景，Java 提供了另外一个实现 Lock 接口的读写锁 RRW。我们已知 ReentrantLock 是一个独占锁，同一时间只允许一个线程访问，而 RRW 允许多个读线程同时访问，但不允许写线程和读线程、写线程和写线程同时访问。读写锁内部维护了两个锁，一个是用于读操作的 ReadLock，一个是用于写操作的 WriteLock。&lt;/p&gt;
&lt;p&gt;那读写锁又是如何实现锁分离来保证共享资源的原子性呢？&lt;/p&gt;
&lt;p&gt;RRW 也是基于 AQS 实现的，它的自定义同步器（继承 AQS）需要在同步状态 state 上维护多个读线程和一个写线程的状态，该状态的设计成为实现读写锁的关键。RRW 很好地使用了高低位，来实现一个整型控制两种状态的功能，读写锁将变量切分成了两个部分，高 16 位表示读，低 16 位表示写。&lt;/p&gt;
&lt;p&gt;一个线程尝试获取写锁时，会先判断同步状态 state 是否为 0。如果 state 等于 0，说明暂时没有其它线程获取锁；如果 state 不等于 0，则说明有其它线程获取了锁。&lt;/p&gt;
&lt;p&gt;此时再判断同步状态 state 的低 16 位（w）是否为 0，如果 w 为 0，则说明其它线程获取了读锁，此时进入 CLH 队列进行阻塞等待；如果 w 不为 0，则说明其它线程获取了写锁，此时要判断获取了写锁的是不是当前线程，若不是就进入 CLH 队列进行阻塞等待；若是，就应该判断当前线程获取写锁是否超过了最大次数，若超过，抛异常，反之更新同步状态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/09.jpeg&#34;
	width=&#34;870&#34;
	height=&#34;1392&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/09_hu_526252f3ddfeccfa.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/09_hu_d141afa923c55702.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;62&#34;
		data-flex-basis=&#34;150px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;一个线程尝试获取读锁时，同样会先判断同步状态 state 是否为 0。如果 state 等于 0，说明暂时没有其它线程获取锁，此时判断是否需要阻塞，如果需要阻塞，则进入 CLH 队列进行阻塞等待；如果不需要阻塞，则 CAS 更新同步状态为读状态。&lt;/p&gt;
&lt;p&gt;如果 state 不等于 0，会判断同步状态低 16 位，如果存在写锁，则获取读锁失败，进入 CLH 阻塞队列；反之，判断当前线程是否应该被阻塞，如果不应该阻塞则尝试 CAS 同步状态，获取成功更新同步锁为读状态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/10.jpeg&#34;
	width=&#34;884&#34;
	height=&#34;1380&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/10_hu_76186ae8df70765e.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/10_hu_1abf3ca905e2b2af.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;64&#34;
		data-flex-basis=&#34;153px&#34;
	
&gt;&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;读写锁再优化之 StampedLock&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;RRW 被很好地应用在了读大于写的并发场景中，然而 RRW 在性能上还有可提升的空间。在读取很多、写入很少的情况下，RRW 会使写入线程遭遇饥饿（Starvation）问题，也就是说写入线程会因迟迟无法竞争到锁而一直处于等待状态。&lt;/p&gt;
&lt;p&gt;在 JDK1.8 中，Java 提供了 StampedLock 类解决了这个问题。StampedLock 不是基于 AQS 实现的，但实现的原理和 AQS 是一样的，都是基于队列和锁状态实现的。与 RRW 不一样的是，StampedLock 控制锁有三种模式: 写、悲观读以及乐观读，并且 StampedLock 在获取锁时会返回一个票据 stamp，获取的 stamp 除了在释放锁时需要校验，在乐观读模式下，stamp 还会作为读取共享资源后的二次校验，后面我会讲解 stamp 的工作原理。&lt;/p&gt;
&lt;p&gt;我们先通过一个官方的例子来了解下 StampedLock 是如何使用的，代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public class Point {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    private double x, y;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    private final StampedLock s1 = new StampedLock();
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    void move(double deltaX, double deltaY) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        // 获取写锁
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        long stamp = s1.writeLock();
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        try {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            x += deltaX;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            y += deltaY;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        } finally {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            // 释放写锁
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            s1.unlockWrite(stamp);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    double distanceFormOrigin() {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        // 乐观读操作
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        long stamp = s1.tryOptimisticRead();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        // 拷贝变量
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        double currentX = x, currentY = y;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        // 判断读期间是否有写操作
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        if (!s1.validate(stamp)) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            // 升级为悲观读
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            stamp = s1.readLock();
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            try {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                currentX = x;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                currentY = y;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            } finally {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                s1.unlockRead(stamp);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        return Math.sqrt(currentX * currentX + currentY * currentY);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;我们可以发现：一个写线程获取写锁的过程中，首先是通过 WriteLock 获取一个票据 stamp，WriteLock 是一个独占锁，同时只有一个线程可以获取该锁，当一个线程获取该锁后，其它请求的线程必须等待，当没有线程持有读锁或者写锁的时候才可以获取到该锁。请求该锁成功后会返回一个 stamp 票据变量，用来表示该锁的版本，当释放该锁的时候，需要 unlockWrite 并传递参数 stamp。&lt;/p&gt;
&lt;p&gt;接下来就是一个读线程获取锁的过程。首先线程会通过乐观锁 tryOptimisticRead 操作获取票据 stamp ，如果当前没有线程持有写锁，则返回一个非 0 的 stamp 版本信息。线程获取该 stamp 后，将会拷贝一份共享资源到方法栈，在这之前具体的操作都是基于方法栈的拷贝数据。&lt;/p&gt;
&lt;p&gt;之后方法还需要调用 validate，验证之前调用 tryOptimisticRead 返回的 stamp 在当前是否有其它线程持有了写锁，如果是，那么 validate 会返回 0，升级为悲观锁；否则就可以使用该 stamp 版本的锁对数据进行操作。&lt;/p&gt;
&lt;p&gt;相比于 RRW，StampedLock 获取读锁只是使用与或操作进行检验，不涉及 CAS 操作，即使第一次乐观锁获取失败，也会马上升级至悲观锁，这样就可以避免一直进行 CAS 操作带来的 CPU 占用性能的问题，因此 StampedLock 的效率更高。&lt;/p&gt;
&lt;h2 id=&#34;13-使用乐观锁优化并行操作&#34;&gt;1.3 使用乐观锁优化并行操作
&lt;/h2&gt;&lt;h3 id=&#34;131-什么是乐观锁&#34;&gt;1.3.1 什么是乐观锁
&lt;/h3&gt;&lt;p&gt;开始优化前，我们先来简单回顾下乐观锁的定义。&lt;/p&gt;
&lt;p&gt;乐观锁，顾名思义，就是说在操作共享资源时，它总是抱着乐观的态度进行，它认为自己可以成功地完成操作。但实际上，当多个线程同时操作一个共享资源时，只有一个线程会成功，那么失败的线程呢？它们不会像悲观锁一样在操作系统中挂起，而仅仅是返回，并且系统允许失败的线程重试，也允许自动放弃退出操作。&lt;/p&gt;
&lt;p&gt;所以，乐观锁相比悲观锁来说，不会带来死锁、饥饿等活性故障问题，线程间的相互影响也远远比悲观锁要小。更为重要的是，乐观锁没有因竞争造成的系统开销，所以在性能上也是更胜一筹。&lt;/p&gt;
&lt;h3 id=&#34;132-乐观锁的实现原理&#34;&gt;1.3.2 乐观锁的实现原理
&lt;/h3&gt;&lt;p&gt;相信你对上面的内容是有一定的了解的，下面我们来看看乐观锁的实现原理，有助于我们从根本上总结优化方法。&lt;/p&gt;
&lt;p&gt;CAS 是实现乐观锁的核心算法，它包含了 3 个参数：V（需要更新的变量）、E（预期值）和 N（最新值）。&lt;/p&gt;
&lt;p&gt;只有当需要更新的变量等于预期值时，需要更新的变量才会被设置为最新值，如果更新值和预期值不同，则说明已经有其它线程更新了需要更新的变量，此时当前线程不做操作，返回 V 的真实值。&lt;/p&gt;
&lt;p&gt;1.CAS 如何实现原子操作&lt;/p&gt;
&lt;p&gt;在 JDK 中的 concurrent 包中，atomic 路径下的类都是基于 CAS 实现的。AtomicInteger 就是基于 CAS 实现的一个线程安全的整型类。下面我们通过源码来了解下如何使用 CAS 实现原子操作。&lt;/p&gt;
&lt;p&gt;我们可以看到 AtomicInteger 的自增方法 getAndIncrement 是用了 Unsafe 的 getAndAddInt 方法，显然 AtomicInteger 依赖于本地方法 Unsafe 类，Unsafe 类中的操作方法会调用 CPU 底层指令实现原子操作。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 基于 CAS 操作更新值
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    public final boolean compareAndSet(int expect, int update) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    // 基于 CAS 操作增 1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    public final int getAndIncrement() {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        return unsafe.getAndAddInt(this, valueOffset, 1);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    // 基于 CAS 操作减 1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    public final int getAndDecrement() {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        return unsafe.getAndAddInt(this, valueOffset, -1);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;处理器如何实现原子操作&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;CAS 是调用处理器底层指令来实现原子操作，那么处理器底层又是如何实现原子操作的呢？&lt;/p&gt;
&lt;p&gt;处理器和物理内存之间的通信速度要远慢于处理器间的处理速度，所以处理器有自己的内部缓存。如下图所示，在执行操作时，频繁使用的内存数据会缓存在处理器的 L1、L2 和 L3 高速缓存中，以加快频繁读取的速度。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/11.jepg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;一般情况下，一个单核处理器能自我保证基本的内存操作是原子性的，当一个线程读取一个字节时，所有进程和线程看到的字节都是同一个缓存里的字节，其它线程不能访问这个字节的内存地址。&lt;/p&gt;
&lt;p&gt;但现在的服务器通常是多处理器，并且每个处理器都是多核的。每个处理器维护了一块字节的内存，每个内核维护了一块字节的缓存，这时候多线程并发就会存在缓存不一致的问题，从而导致数据不一致。&lt;/p&gt;
&lt;p&gt;这个时候，处理器提供了总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。&lt;/p&gt;
&lt;p&gt;当处理器要操作一个共享变量的时候，其在总线上会发出一个 Lock 信号，这时其它处理器就不能操作共享变量了，该处理器会独享此共享内存中的变量。但总线锁定在阻塞其它处理器获取该共享变量的操作请求时，也可能会导致大量阻塞，从而增加系统的性能开销。&lt;/p&gt;
&lt;p&gt;于是，后来的处理器都提供了缓存锁定机制，也就说当某个处理器对缓存中的共享变量进行了操作，就会通知其它处理器放弃存储该共享资源或者重新读取该共享资源。目前最新的处理器都支持缓存锁定机制。&lt;/p&gt;
&lt;h3 id=&#34;133-优化-cas-乐观锁&#34;&gt;1.3.3 优化 CAS 乐观锁
&lt;/h3&gt;&lt;p&gt;虽然乐观锁在并发性能上要比悲观锁优越，但是在写大于读的操作场景下，CAS 失败的可能性会增大，如果不放弃此次 CAS 操作，就需要循环做 CAS 重试，这无疑会长时间地占用 CPU。&lt;/p&gt;
&lt;p&gt;在 Java7 中，通过以下代码我们可以看到：AtomicInteger 的 getAndSet 方法中使用了 for 循环不断重试 CAS 操作，如果长时间不成功，就会给 CPU 带来非常大的执行开销。到了 Java8，for 循环虽然被去掉了，但我们反编译 Unsafe 类时就可以发现该循环其实是被封装在了 Unsafe 类中，CPU 的执行开销依然存在。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  public final int getAndSet(int newValue) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        for (;;) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            int current = get();
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            if (compareAndSet(current, newValue))
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                return current;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在 JDK1.8 中，Java 提供了一个新的原子类 LongAdder。LongAdder 在高并发场景下会比 AtomicInteger 和 AtomicLong 的性能更好，代价就是会消耗更多的内存空间。&lt;/p&gt;
&lt;p&gt;LongAdder 的原理就是降低操作共享变量的并发数，也就是将对单一共享变量的操作压力分散到多个变量值上，将竞争的每个写线程的 value 值分散到一个数组中，不同线程会命中到数组的不同槽中，各个线程只对自己槽中的 value 值进行 CAS 操作，最后在读取值的时候会将原子操作的共享变量与各个分散在数组的 value 值相加，返回一个近似准确的数值。&lt;/p&gt;
&lt;p&gt;LongAdder 内部由一个 base 变量和一个 cell[] 数组组成。当只有一个写线程，没有竞争的情况下，LongAdder 会直接使用 base 变量作为原子操作变量，通过 CAS 操作修改变量；当有多个写线程竞争的情况下，除了占用 base 变量的一个写线程之外，其它各个线程会将修改的变量写入到自己的槽 cell[] 数组中，最终结果可通过以下公式计算得出：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/12.jpeg&#34;
	width=&#34;688&#34;
	height=&#34;194&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/12_hu_e8d9bc9023a9b9d1.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/12_hu_6fd9c14dd29c1057.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;354&#34;
		data-flex-basis=&#34;851px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;我们可以发现，LongAdder 在操作后的返回值只是一个近似准确的数值，但是 LongAdder 最终返回的是一个准确的数值， 所以在一些对实时性要求比较高的场景下，LongAdder 并不能取代 AtomicInteger 或 AtomicLong。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在日常开发中，使用乐观锁最常见的场景就是数据库的更新操作了。为了保证操作数据库的原子性，我们常常会为每一条数据定义一个版本号，并在更新前获取到它，到了更新数据库的时候，还要判断下已经获取的版本号是否被更新过，如果没有，则执行该操作。&lt;/p&gt;
&lt;p&gt;CAS 乐观锁在平常使用时比较受限，它只能保证单个变量操作的原子性，当涉及到多个变量时，CAS 就无能为力了，但前两讲讲到的悲观锁可以通过对整个代码块加锁来做到这点。&lt;/p&gt;
&lt;p&gt;CAS 乐观锁在高并发写大于读的场景下，大部分线程的原子操作会失败，失败后的线程将会不断重试 CAS 原子操作，这样就会导致大量线程长时间地占用 CPU 资源，给系统带来很大的性能开销。在 JDK1.8 中，Java 新增了一个原子类 LongAdder，它使用了空间换时间的方法，解决了上述问题。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h1 id=&#34;2-多线程调优&#34;&gt;2. 多线程调优
&lt;/h1&gt;&lt;h2 id=&#34;21-哪些操作导致了上下文切换&#34;&gt;2.1 哪些操作导致了上下文切换？
&lt;/h2&gt;&lt;p&gt;从实践中总结经验，我知道了在并发程序中，并不是启动更多的线程就能让程序最大限度地并发执行。线程数量设置太小，会导致程序不能充分地利用系统资源；线程数量设置太大，又可能带来资源的过度竞争，导致上下文切换带来额外的系统开销。&lt;/p&gt;
&lt;h3 id=&#34;211-初识上下文切换&#34;&gt;2.1.1 初识上下文切换
&lt;/h3&gt;&lt;p&gt;我们首先得明白，上下文切换到底是什么。&lt;/p&gt;
&lt;p&gt;其实在单个处理器的时期，操作系统就能处理多线程并发任务。处理器给每个线程分配 CPU 时间片（Time Slice），线程在分配获得的时间片内执行任务。&lt;/p&gt;
&lt;p&gt;CPU 时间片是 CPU 分配给每个线程执行的时间段，一般为几十毫秒。在这么短的时间内线程互相切换，我们根本感觉不到，所以看上去就好像是同时进行的一样。&lt;/p&gt;
&lt;p&gt;时间片决定了一个线程可以连续占用处理器运行的时长。当一个线程的时间片用完了，或者因自身原因被迫暂停运行了，这个时候，另外一个线程（可以是同一个线程或者其它进程的线程）就会被操作系统选中，来占用处理器。这种一个线程被暂停剥夺使用权，另外一个线程被选中开始或者继续运行的过程就叫做上下文切换（Context Switch）。&lt;/p&gt;
&lt;p&gt;具体来说，一个线程被剥夺处理器的使用权而被暂停运行，就是“切出”；一个线程被选中占用处理器开始或者继续运行，就是“切入”。在这种切出切入的过程中，操作系统需要保存和恢复相应的进度信息，这个进度信息就是“上下文”了。&lt;/p&gt;
&lt;p&gt;那上下文都包括哪些内容呢？具体来说，它包括了寄存器的存储内容以及程序计数器存储的指令内容。CPU 寄存器负责存储已经、正在和将要执行的任务，程序计数器负责存储 CPU 正在执行的指令位置以及即将执行的下一条指令的位置。&lt;/p&gt;
&lt;p&gt;在当前 CPU 数量远远不止一个的情况下，操作系统将 CPU 轮流分配给线程任务，此时的上下文切换就变得更加频繁了，并且存在跨 CPU 上下文切换，比起单核上下文切换，跨核切换更加昂贵。&lt;/p&gt;
&lt;h3 id=&#34;212-多线程上下文切换诱因&#34;&gt;2.1.2 多线程上下文切换诱因
&lt;/h3&gt;&lt;p&gt;在操作系统中，上下文切换的类型还可以分为进程间的上下文切换和线程间的上下文切换。而在多线程编程中，我们主要面对的就是线程间的上下文切换导致的性能问题，下面我们就重点看看究竟是什么原因导致了多线程的上下文切换。开始之前，先看下 Java 线程的生命周期状态。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/13.jpeg&#34;
	width=&#34;1646&#34;
	height=&#34;622&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/13_hu_dad8579cdae10b90.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/13_hu_535b3c0c9a208137.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;264&#34;
		data-flex-basis=&#34;635px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;结合图示可知，线程主要有“新建”（NEW）、“就绪”（RUNNABLE）、“运行”（RUNNING）、“阻塞”（BLOCKED）、“死亡”（DEAD）五种状态。&lt;/p&gt;
&lt;p&gt;在这个运行过程中，线程由 RUNNABLE 转为非 RUNNABLE 的过程就是线程上下文切换。&lt;/p&gt;
&lt;p&gt;一个线程的状态由 RUNNING 转为 BLOCKED ，再由 BLOCKED 转为 RUNNABLE ，然后再被调度器选中执行，这就是一个上下文切换的过程。&lt;/p&gt;
&lt;p&gt;当一个线程从 RUNNING 状态转为 BLOCKED 状态时，我们称为一个线程的暂停，线程暂停被切出之后，操作系统会保存相应的上下文，以便这个线程稍后再次进入 RUNNABLE 状态时能够在之前执行进度的基础上继续执行。&lt;/p&gt;
&lt;p&gt;当一个线程从 BLOCKED 状态进入到 RUNNABLE 状态时，我们称为一个线程的唤醒，此时线程将获取上次保存的上下文继续完成执行。&lt;/p&gt;
&lt;p&gt;通过线程的运行状态以及状态间的相互切换，我们可以了解到，多线程的上下文切换实际上就是由多线程两个运行状态的互相切换导致的。&lt;/p&gt;
&lt;p&gt;那么在线程运行时，线程状态由 RUNNING 转为 BLOCKED 或者由 BLOCKED 转为 RUNNABLE，这又是什么诱发的呢？&lt;/p&gt;
&lt;p&gt;我们可以分两种情况来分析，一种是程序本身触发的切换，这种我们称为自发性上下文切换，另一种是由系统或者虚拟机诱发的非自发性上下文切换。&lt;/p&gt;
&lt;p&gt;自发性上下文切换指线程由 Java 程序调用导致切出，在多线程编程中，执行调用以下方法或关键字，常常就会引发自发性上下文切换。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;sleep()&lt;/li&gt;
&lt;li&gt;wait()&lt;/li&gt;
&lt;li&gt;yield()&lt;/li&gt;
&lt;li&gt;join()&lt;/li&gt;
&lt;li&gt;park()&lt;/li&gt;
&lt;li&gt;synchronized&lt;/li&gt;
&lt;li&gt;lock&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;非自发性上下文切换指线程由于调度器的原因被迫切出。常见的有：线程被分配的时间片用完，虚拟机垃圾回收导致或者执行优先级的问题导致。&lt;/p&gt;
&lt;p&gt;这里重点说下“虚拟机垃圾回收为什么会导致上下文切换”。在 Java 虚拟机中，对象的内存都是由虚拟机中的堆分配的，在程序运行过程中，新的对象将不断被创建，如果旧的对象使用后不进行回收，堆内存将很快被耗尽。Java 虚拟机提供了一种回收机制，对创建后不再使用的对象进行回收，从而保证堆内存的可持续性分配。而这种垃圾回收机制的使用有可能会导致 stop-the-world 事件的发生，这其实就是一种线程暂停行为。&lt;/p&gt;
&lt;h3 id=&#34;213-发现上下文切换&#34;&gt;2.1.3 发现上下文切换
&lt;/h3&gt;&lt;p&gt;我们总说上下文切换会带来系统开销，那它带来的性能问题是不是真有这么糟糕呢？我们又该怎么去监测到上下文切换？上下文切换到底开销在哪些环节？接下来我将给出一段代码，来对比串联执行和并发执行的速度，然后一一解答这些问题。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;66
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;67
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;68
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;69
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;70
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;71
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;72
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;73
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;74
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;75
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;76
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;77
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;78
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gdscript3&#34; data-lang=&#34;gdscript3&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;DemoApplication&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;       &lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;ne&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;运行多线程&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;n&#34;&gt;MultiThreadTester&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;test1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MultiThreadTester&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;n&#34;&gt;test1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;运行单线程&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;n&#34;&gt;SerialTester&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;test2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SerialTester&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;n&#34;&gt;test2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;       &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;       
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;       
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;       &lt;span class=&#34;k&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MultiThreadTester&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ThreadContextSwitchTester&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;err&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Override&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                     &lt;span class=&#34;n&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;start&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;currentTimeMillis&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                     &lt;span class=&#34;n&#34;&gt;MyRunnable&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;myRunnable1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MyRunnable&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                     &lt;span class=&#34;ne&#34;&gt;Thread&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;threads&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;ne&#34;&gt;Thread&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                     &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;创建多个线程&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                     &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;ne&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                           &lt;span class=&#34;n&#34;&gt;threads&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;ne&#34;&gt;Thread&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;myRunnable1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                           &lt;span class=&#34;n&#34;&gt;threads&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                     &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                     &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;ne&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                           &lt;span class=&#34;n&#34;&gt;try&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                                  &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;等待一起运行完&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                                  &lt;span class=&#34;n&#34;&gt;threads&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;join&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                           &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;catch&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;InterruptedException&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                                  &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;TODO&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Auto&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;generated&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;catch&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;block&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                                  &lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;printStackTrace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                           &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                     &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                     &lt;span class=&#34;n&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;end&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;currentTimeMillis&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                     &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;multi thread exce time: &amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;s&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                     &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;counter: &amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;counter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;创建一个实现&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Runnable&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;的类&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MyRunnable&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;implements&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Runnable&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                     &lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;run&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                           &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;counter&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100000000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                                  &lt;span class=&#34;n&#34;&gt;synchronized&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                                         &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;counter&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100000000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                                                &lt;span class=&#34;n&#34;&gt;increaseCounter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                                         &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                                         
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                                  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                           &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                     &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;       &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;       
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;创建一个单线程&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;       &lt;span class=&#34;k&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SerialTester&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ThreadContextSwitchTester&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;err&#34;&gt;@&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Override&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                     &lt;span class=&#34;n&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;start&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;currentTimeMillis&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                     &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                           &lt;span class=&#34;n&#34;&gt;increaseCounter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                     &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                     &lt;span class=&#34;n&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;end&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;currentTimeMillis&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                     &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;serial exec time: &amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;end&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;s&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                     &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;counter: &amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;counter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;       &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;       &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;父类&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;       &lt;span class=&#34;k&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;abstract&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ThreadContextSwitchTester&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;ne&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;count&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100000000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;volatile&lt;/span&gt; &lt;span class=&#34;ne&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;counter&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;ne&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;getCount&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                     &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;counter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;increaseCounter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                     
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                     &lt;span class=&#34;n&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;counter&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;              &lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;abstract&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Start&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;       &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;执行之后，看一下两者的时间测试结果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/14.jpeg&#34;
	width=&#34;1546&#34;
	height=&#34;198&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/14_hu_244139c7668f0279.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/14_hu_ac1fa874a2e0add8.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;780&#34;
		data-flex-basis=&#34;1873px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;通过数据对比我们可以看到：串联的执行速度比并发的执行速度要快。这就是因为线程的上下文切换导致了额外的开销，使用 Synchronized 锁关键字，导致了资源竞争，从而引起了上下文切换，但即使不使用 Synchronized 锁关键字，并发的执行速度也无法超越串联的执行速度，这是因为多线程同样存在着上下文切换。Redis、NodeJS 的设计就很好地体现了单线程串行的优势。&lt;/p&gt;
&lt;p&gt;在 Linux 系统下，可以使用 Linux 内核提供的 vmstat 命令，来监视 Java 程序运行过程中系统的上下文切换频率，cs 如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/15.jpeg&#34;
	width=&#34;1408&#34;
	height=&#34;334&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/15_hu_459a6fd71f85f283.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/15_hu_174d1e4a9dc755d7.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;421&#34;
		data-flex-basis=&#34;1011px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;如果是监视某个应用的上下文切换，就可以使用 pidstat 命令监控指定进程的 Context Switch 上下文切换。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/16.jpeg&#34;
	width=&#34;1564&#34;
	height=&#34;582&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/16_hu_6b46ba763e17ea4c.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/16_hu_dc315d07c694e97d.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;268&#34;
		data-flex-basis=&#34;644px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;至于系统开销具体发生在切换过程中的哪些具体环节，总结如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作系统保存和恢复上下文；&lt;/li&gt;
&lt;li&gt;调度器进行线程调度；&lt;/li&gt;
&lt;li&gt;处理器高速缓存重新加载；&lt;/li&gt;
&lt;li&gt;上下文切换也可能导致整个高速缓存区被冲刷，从而带来时间开销。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;22-如何优化多线程上下文切换&#34;&gt;2.2 如何优化多线程上下文切换？
&lt;/h2&gt;&lt;h3 id=&#34;221-竞争锁优化&#34;&gt;2.2.1 竞争锁优化
&lt;/h3&gt;&lt;p&gt;大多数人在多线程编程中碰到性能问题，第一反应多是想到了锁。&lt;/p&gt;
&lt;p&gt;多线程对锁资源的竞争会引起上下文切换，还有锁竞争导致的线程阻塞越多，上下文切换就越频繁，系统的性能开销也就越大。由此可见，在多线程编程中，锁其实不是性能开销的根源，竞争锁才是。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;减少锁的持有时间
我们知道，锁的持有时间越长，就意味着有越多的线程在等待该竞争资源释放。如果是 Synchronized 同步锁资源，就不仅是带来线程间的上下文切换，还有可能会增加进程间的上下文切换。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;优化前&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public synchronized void mySyncMethod(){  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        businesscode1();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        mutextMethod();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        businesscode2();
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;优化后&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public void mySyncMethod(){  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        businesscode1();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        synchronized(this)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            mutextMethod();  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        businesscode2();
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;降低锁的粒度&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;同步锁可以保证对象的原子性，我们可以考虑将锁粒度拆分得更小一些，以此避免所有线程对一个锁资源的竞争过于激烈。具体方式有以下两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;锁分离&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;与传统锁不同的是，读写锁实现了锁分离，也就是说读写锁是由“读锁”和“写锁”两个锁实现的，其规则是可以共享读，但只有一个写。&lt;/p&gt;
&lt;p&gt;这样做的好处是，在多线程读的时候，读读是不互斥的，读写是互斥的，写写是互斥的。而传统的独占锁在没有区分读写锁的时候，读写操作一般是：读读互斥、读写互斥、写写互斥。所以在读远大于写的多线程场景中，锁分离避免了在高并发读情况下的资源竞争，从而避免了上下文切换。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;锁分段&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们在使用锁来保证集合或者大对象原子性时，可以考虑将锁对象进一步分解。例如，我之前讲过的 Java1.8 之前版本的 ConcurrentHashMap 就使用了锁分段。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;非阻塞乐观锁替代竞争锁&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;volatile 关键字的作用是保障可见性及有序性，volatile 的读写操作不会导致上下文切换，因此开销比较小。 但是，volatile 不能保证操作变量的原子性，因为没有锁的排他性。&lt;/p&gt;
&lt;p&gt;而 CAS 是一个原子的 if-then-act 操作，CAS 是一个无锁算法实现，保障了对一个共享变量读写操作的一致性。CAS 操作中有 3 个操作数，内存值 V、旧的预期值 A 和要修改的新值 B，当且仅当 A 和 V 相同时，将 V 修改为 B，否则什么都不做，CAS 算法将不会导致上下文切换。Java 的 Atomic 包就使用了 CAS 算法来更新数据，就不需要额外加锁。&lt;/p&gt;
&lt;p&gt;上面我们了解了如何从编码层面去优化竞争锁，那么除此之外，JVM 内部其实也对 Synchronized 同步锁做了优化，我在 12 讲中有详细地讲解过，这里简单回顾一下。&lt;/p&gt;
&lt;p&gt;在 JDK1.6 中，JVM 将 Synchronized 同步锁分为了偏向锁、轻量级锁、偏向锁以及重量级锁，优化路径也是按照以上顺序进行。JIT 编译器在动态编译同步块的时候，也会通过锁消除、锁粗化的方式来优化该同步锁。&lt;/p&gt;
&lt;h3 id=&#34;222-waitnotify-优化&#34;&gt;2.2.2 wait/notify 优化
&lt;/h3&gt;&lt;p&gt;在 Java 中，我们可以通过配合调用 Object 对象的 wait() 方法和 notify() 方法或 notifyAll() 方法来实现线程间的通信。&lt;/p&gt;
&lt;p&gt;在线程中调用 wait() 方法，将阻塞等待其它线程的通知（其它线程调用 notify() 方法或 notifyAll() 方法），在线程中调用 notify() 方法或 notifyAll() 方法，将通知其它线程从 wait() 方法处返回。&lt;/p&gt;
&lt;p&gt;下面我们通过 wait() / notify() 来实现一个简单的生产者和消费者的案例，代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;66
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;67
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;68
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;69
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;70
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;71
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;72
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;73
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;74
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;75
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;76
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;77
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;78
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;79
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;80
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;81
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;82
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;83
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;84
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;85
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;86
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;87
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;88
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public class WaitNotifyTest {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    public static void main(String[] args) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        Vector&amp;lt;Integer&amp;gt; pool=new Vector&amp;lt;Integer&amp;gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        Producer producer=new Producer(pool, 10);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        Consumer consumer=new Consumer(pool);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        new Thread(producer).start();
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        new Thread(consumer).start();
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	/**
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	 * 生产者
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	 * @author admin
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	 *
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	 */
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	class Producer implements Runnable{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    private Vector&amp;lt;Integer&amp;gt; pool;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    private Integer size;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    public Producer(Vector&amp;lt;Integer&amp;gt;  pool, Integer size) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	        this.pool = pool;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	        this.size = size;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    public void run() {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	        for(;;){
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	            try {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	                System.out.println(&amp;#34; 生产一个商品 &amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	                produce(1);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	            } catch (InterruptedException e) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	                // TODO Auto-generated catch block
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	                e.printStackTrace();
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	            }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	        }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    private void produce(int i) throws InterruptedException{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	        while(pool.size()==size){
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	            synchronized (pool) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	                System.out.println(&amp;#34; 生产者等待消费者消费商品, 当前商品数量为 &amp;#34;+pool.size());
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	                pool.wait();// 等待消费者消费
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	            }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	        }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	        synchronized (pool) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	            pool.add(i);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	            pool.notifyAll();// 生产成功，通知消费者消费
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	        }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	/**
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	 * 消费者
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	 * @author admin
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	 *
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	 */
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	class Consumer implements Runnable{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    private Vector&amp;lt;Integer&amp;gt;  pool;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    public Consumer(Vector&amp;lt;Integer&amp;gt;  pool) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	        this.pool = pool;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    public void run() {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	        for(;;){
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	            try {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	                System.out.println(&amp;#34; 消费一个商品 &amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	                consume();
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	            } catch (InterruptedException e) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	                // TODO Auto-generated catch block
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	                e.printStackTrace();
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	            }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	        }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    private void consume() throws InterruptedException{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	        while(pool.isEmpty()){
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	            synchronized (pool) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	                System.out.println(&amp;#34; 消费者等待生产者生产商品, 当前商品数量为 &amp;#34;+pool.size());
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	                pool.wait();// 等待生产者生产商品
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	            }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	        }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	        synchronized (pool) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	            pool.remove(0);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	            pool.notifyAll();// 通知生产者生产商品
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	            
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	        }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	    }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;wait/notify 的使用导致了较多的上下文切换
结合以下图片，我们可以看到，在消费者第一次申请到锁之前，发现没有商品消费，此时会执行 Object.wait() 方法，这里会导致线程挂起，进入阻塞状态，这里为一次上下文切换。&lt;/p&gt;
&lt;p&gt;当生产者获取到锁并执行 notifyAll() 之后，会唤醒处于阻塞状态的消费者线程，此时这里又发生了一次上下文切换。&lt;/p&gt;
&lt;p&gt;被唤醒的等待线程在继续运行时，需要再次申请相应对象的内部锁，此时等待线程可能需要和其它新来的活跃线程争用内部锁，这也可能会导致上下文切换。&lt;/p&gt;
&lt;p&gt;如果有多个消费者线程同时被阻塞，用 notifyAll() 方法，将会唤醒所有阻塞的线程。而某些商品依然没有库存，过早地唤醒这些没有库存的商品的消费线程，可能会导致线程再次进入阻塞状态，从而引起不必要的上下文切换。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/17.jpeg&#34;
	width=&#34;1324&#34;
	height=&#34;1210&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/17_hu_19a3e03d94e9260d.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/17_hu_710447b4d3891ed8.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;109&#34;
		data-flex-basis=&#34;262px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;优化 wait/notify 的使用，减少上下文切换&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;首先，我们在多个不同消费场景中，可以使用 Object.notify() 替代 Object.notifyAll()。 因为 Object.notify() 只会唤醒指定线程，不会过早地唤醒其它未满足需求的阻塞线程，所以可以减少相应的上下文切换。&lt;/p&gt;
&lt;p&gt;其次，在生产者执行完 Object.notify() / notifyAll() 唤醒其它线程之后，应该尽快地释放内部锁，以避免其它线程在唤醒之后长时间地持有锁处理业务操作，这样可以避免被唤醒的线程再次申请相应内部锁的时候等待锁的释放。&lt;/p&gt;
&lt;p&gt;最后，为了避免长时间等待，我们常会使用 Object.wait (long）设置等待超时时间，但线程无法区分其返回是由于等待超时还是被通知线程唤醒，从而导致线程再次尝试获取锁操作，增加了上下文切换。&lt;/p&gt;
&lt;p&gt;这里我建议使用 Lock 锁结合 Condition 接口替代 Synchronized 内部锁中的 wait / notify，实现等待／通知。这样做不仅可以解决上述的 Object.wait(long) 无法区分的问题，还可以解决线程被过早唤醒的问题。&lt;/p&gt;
&lt;p&gt;Condition 接口定义的 await 方法 、signal 方法和 signalAll 方法分别相当于 Object.wait()、 Object.notify() 和 Object.notifyAll()。&lt;/p&gt;
&lt;h3 id=&#34;223-合理地设置线程池大小避免创建过多线程&#34;&gt;2.2.3 合理地设置线程池大小，避免创建过多线程
&lt;/h3&gt;&lt;p&gt;线程池的线程数量设置不宜过大，因为一旦线程池的工作线程总数超过系统所拥有的处理器数量，就会导致过多的上下文切换。&lt;/p&gt;
&lt;p&gt;还有一种情况就是，在有些创建线程池的方法里，线程数量设置不会直接暴露给我们。比如，用 Executors.newCachedThreadPool() 创建的线程池，该线程池会复用其内部空闲的线程来处理新提交的任务，如果没有，再创建新的线程（不受 MAX_VALUE 限制），这样的线程池如果碰到大量且耗时长的任务场景，就会创建非常多的工作线程，从而导致频繁的上下文切换。因此，这类线程池就只适合处理大量且耗时短的非阻塞任务。&lt;/p&gt;
&lt;h3 id=&#34;224-使用协程实现非阻塞等待&#34;&gt;2.2.4 使用协程实现非阻塞等待
&lt;/h3&gt;&lt;p&gt;相信很多人一听到协程（Coroutines），马上想到的就是 Go 语言。协程对于大部分 Java 程序员来说可能还有点陌生，但其在 Go 中的使用相对来说已经很成熟了。&lt;/p&gt;
&lt;p&gt;协程是一种比线程更加轻量级的东西，相比于由操作系统内核来管理的进程和线程，协程则完全由程序本身所控制，也就是在用户态执行。协程避免了像线程切换那样产生的上下文切换，在性能方面得到了很大的提升。&lt;/p&gt;
&lt;h3 id=&#34;225-减少-java-虚拟机的垃圾回收&#34;&gt;2.2.5 减少 Java 虚拟机的垃圾回收
&lt;/h3&gt;&lt;p&gt;我们在上一讲讲上下文切换的诱因时，曾提到过“垃圾回收会导致上下文切换”。&lt;/p&gt;
&lt;p&gt;很多 JVM 垃圾回收器（serial 收集器、ParNew 收集器）在回收旧对象时，会产生内存碎片，从而需要进行内存整理，在这个过程中就需要移动存活的对象。而移动内存对象就意味着这些对象所在的内存地址会发生变化，因此在移动对象前需要暂停线程，在移动完成后需要再次唤醒该线程。因此减少 JVM 垃圾回收的频率可以有效地减少上下文切换。&lt;/p&gt;
&lt;h1 id=&#34;3-并发容器的使用识别不同场景下最优容器&#34;&gt;3. 并发容器的使用：识别不同场景下最优容器
&lt;/h1&gt;&lt;h2 id=&#34;31-并发场景下的-map-容器&#34;&gt;3.1 并发场景下的 Map 容器
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;HashMap&lt;/li&gt;
&lt;li&gt;Hashtable&lt;/li&gt;
&lt;li&gt;ConcurrentHashMap&lt;/li&gt;
&lt;li&gt;ConcurrentSkipListMap&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Hashtable、ConcurrentHashMap 是基于 HashMap 实现的，对于小数据量的存取比较有优势。&lt;/p&gt;
&lt;p&gt;ConcurrentSkipListMap 是基于 TreeMap 的设计原理实现的，略有不同的是前者基于跳表实现，后者基于红黑树实现，ConcurrentSkipListMap 的特点是存取平均时间复杂度是 O（log（n）），适用于大数据量存取的场景，最常见的是基于跳跃表实现的数据量比较大的缓存。&lt;/p&gt;
&lt;h3 id=&#34;311-hashtable--concurrenthashmap&#34;&gt;3.1.1 Hashtable 🆚 ConcurrentHashMap
&lt;/h3&gt;&lt;p&gt;Hashtable 使用 Synchronized 同步锁修饰了 put、get、remove 等方法，因此在高并发场景下，读写操作都会存在大量锁竞争，给系统带来性能开销。&lt;/p&gt;
&lt;p&gt;相比 Hashtable，ConcurrentHashMap 在保证线程安全的基础上兼具了更好的并发性能。在 JDK1.7 中，ConcurrentHashMap 就使用了分段锁 Segment 减小了锁粒度，最终优化了锁的并发操作。&lt;/p&gt;
&lt;p&gt;到了 JDK1.8，ConcurrentHashMap 做了大量的改动，摒弃了 Segment 的概念。由于 Synchronized 锁在 Java6 之后的性能已经得到了很大的提升，所以在 JDK1.8 中，Java 重新启用了 Synchronized 同步锁，通过 Synchronized 实现 HashEntry 作为锁粒度。这种改动将数据结构变得更加简单了，操作也更加清晰流畅。&lt;/p&gt;
&lt;p&gt;与 JDK1.7 的 put 方法一样，JDK1.8 在添加元素时，在没有哈希冲突的情况下，会使用 CAS 进行添加元素操作；如果有冲突，则通过 Synchronized 将链表锁定，再执行接下来的操作。&lt;/p&gt;
&lt;p&gt;但要注意一点，虽然 ConcurrentHashMap 的整体性能要优于 Hashtable，但在某些场景中，ConcurrentHashMap 依然不能代替 Hashtable。例如，在强一致的场景中 ConcurrentHashMap 就不适用，原因是 ConcurrentHashMap 中的 get、size 等方法没有用到锁，ConcurrentHashMap 是弱一致性的，因此有可能会导致某次读无法马上获取到写入的数据。&lt;/p&gt;
&lt;h3 id=&#34;312-concurrenthashmap--concurrentskiplistmap&#34;&gt;3.1.2 ConcurrentHashMap 🆚 ConcurrentSkipListMap
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;什么是跳跃表&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;跳跃表是基于链表扩展实现的一种特殊链表，类似于树的实现，跳跃表不仅实现了横向链表，还实现了垂直方向的分层索引。&lt;/p&gt;
&lt;p&gt;一个跳跃表由若干层链表组成，每一层都实现了一个有序链表索引，只有最底层包含了所有数据，每一层由下往上依次通过一个指针指向上层相同值的元素，每层数据依次减少，等到了最顶层就只会保留部分数据了。&lt;/p&gt;
&lt;p&gt;跳跃表的这种结构，是利用了空间换时间的方法来提高了查询效率。程序总是从最顶层开始查询访问，通过判断元素值来缩小查询范围。我们可以通过以下几张图来了解下跳跃表的具体实现原理。&lt;/p&gt;
&lt;p&gt;首先是一个初始化的跳跃表：
&lt;img src=&#34;https://zhenyu0324.github.io/18.jepg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;当查询 key 值为 9 的节点时，此时查询路径为：
&lt;img src=&#34;https://zhenyu0324.github.io/19.jepg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;当新增一个 key 值为 8 的节点时，首先新增一个节点到最底层的链表中，根据概率算出 level 值，再根据 level 值新建索引层，最后链接索引层的新节点。新增节点和链接索引都是基于 CAS 操作实现。
&lt;img src=&#34;https://zhenyu0324.github.io/20.jepg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;当删除一个 key 值为 7 的结点时，首先找到待删除结点，将其 value 值设置为 null；之后再向待删除结点的 next 位置新增一个标记结点，以便减少并发冲突；然后让待删结点的前驱节点直接越过本身指向的待删结点，直接指向后继结点，中间要被删除的结点最终将会被 JVM 垃圾回收处理掉；最后判断此次删除后是否导致某一索引层没有其它节点了，并视情况删除该层索引 。
&lt;img src=&#34;https://zhenyu0324.github.io/21.jepg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;通过以上两个案例，我想你应该清楚了 Hashtable、ConcurrentHashMap 以及 ConcurrentSkipListMap 这三种容器的适用场景了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果对数据有强一致要求，则需使用 Hashtable；在大部分场景通常都是弱一致性的情况下，使用 ConcurrentHashMap 即可；如果数据量在千万级别，且存在大量增删改操作，则可以考虑使用 ConcurrentSkipListMap。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;32-并发场景下的-list-容器&#34;&gt;3.2 并发场景下的 List 容器
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;ArrayList&lt;/li&gt;
&lt;li&gt;Vector&lt;/li&gt;
&lt;li&gt;CopyOnWriteArrayList&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ArrayList 是非线程安全容器，在并发场景下使用很可能会导致线程安全问题。&lt;/p&gt;
&lt;p&gt;Vector 也是基于 Synchronized 同步锁实现的线程安全，Synchronized 关键字几乎修饰了所有对外暴露的方法，所以在读远大于写的操作场景中，Vector 将会发生大量锁竞争，从而给系统带来性能开销。&lt;/p&gt;
&lt;p&gt;相比之下，CopyOnWriteArrayList 是 java.util.concurrent 包提供的方法，它实现了读操作无锁，写操作则通过操作底层数组的新副本来实现，是一种读写分离的并发策略。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/22.jepg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;h1 id=&#34;4-如何设置线程池大小&#34;&gt;4. 如何设置线程池大小？
&lt;/h1&gt;&lt;h2 id=&#34;41-线程池原理&#34;&gt;4.1 线程池原理
&lt;/h2&gt;&lt;p&gt;在 HotSpot VM 的线程模型中，Java 线程被一对一映射为内核线程。Java 在使用线程执行程序时，需要创建一个内核线程；当该 Java 线程被终止时，这个内核线程也会被回收。因此 Java 线程的创建与销毁将会消耗一定的计算机资源，从而增加系统的性能开销。&lt;/p&gt;
&lt;p&gt;除此之外，大量创建线程同样会给系统带来性能问题，因为内存和 CPU 资源都将被线程抢占，如果处理不当，就会发生内存溢出、CPU 使用率超负荷等问题。&lt;/p&gt;
&lt;p&gt;为了解决上述两类问题，Java 提供了线程池概念，对于频繁创建线程的业务场景，线程池可以创建固定的线程数量，并且在操作系统底层，轻量级进程将会把这些线程映射到内核。&lt;/p&gt;
&lt;p&gt;线程池可以提高线程复用，又可以固定最大线程使用量，防止无限制地创建线程。当程序提交一个任务需要一个线程时，会去线程池中查找是否有空闲的线程，若有，则直接使用线程池中的线程工作，若没有，会去判断当前已创建的线程数量是否超过最大线程数量，如未超过，则创建新线程，如已超过，则进行排队等待或者直接抛出异常。&lt;/p&gt;
&lt;h2 id=&#34;42-线程池框架-executor&#34;&gt;4.2 线程池框架 Executor
&lt;/h2&gt;&lt;p&gt;Java 最开始提供了 ThreadPool 实现了线程池，为了更好地实现用户级的线程调度，更有效地帮助开发人员进行多线程开发，Java 提供了一套 Executor 框架。&lt;/p&gt;
&lt;p&gt;这个框架中包括了 ScheduledThreadPoolExecutor 和 ThreadPoolExecutor 两个核心线程池。前者是用来定时执行任务，后者是用来执行被提交的任务。鉴于这两个线程池的核心原理是一样的，下面我们就重点看看 ThreadPoolExecutor 类是如何实现线程池的。&lt;/p&gt;
&lt;p&gt;Executors 实现了以下四种类型的 ThreadPoolExecutor：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/23.jpeg&#34;
	width=&#34;1240&#34;
	height=&#34;486&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/23_hu_2b1ef3c3edc867d6.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/23_hu_e600493caecdc7be.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;255&#34;
		data-flex-basis=&#34;612px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;Executors 利用工厂模式实现的四种线程池，我们在使用的时候需要结合生产环境下的实际场景。不过我不太推荐使用它们，因为选择使用 Executors 提供的工厂类，将会忽略很多线程池的参数设置，工厂类一旦选择设置默认参数，就很容易导致无法调优参数设置，从而产生性能问题或者资源浪费。&lt;/p&gt;
&lt;p&gt;这里我建议你使用 ThreadPoolExecutor 自我定制一套线程池。进入四种工厂类后，我们可以发现除了 newScheduledThreadPool 类，其它类均使用了 ThreadPoolExecutor 类进行实现，你可以通过以下代码简单看下该方法：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public ThreadPoolExecutor(int corePoolSize,// 线程池的核心线程数量
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                              int maximumPoolSize,// 线程池的最大线程数
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                              long keepAliveTime,// 当线程数大于核心线程数时，多余的空闲线程存活的最长时间
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                              TimeUnit unit,// 时间单位
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                              BlockingQueue&amp;lt;Runnable&amp;gt; workQueue,// 任务队列，用来储存等待执行任务的队列
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                              ThreadFactory threadFactory,// 线程工厂，用来创建线程，一般默认即可
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                              RejectedExecutionHandler handler) // 拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;我们还可以通过下面这张图来了解下线程池中各个参数的相互关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/24.jpeg&#34;
	width=&#34;1666&#34;
	height=&#34;1042&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/24_hu_a576fae3649e8ccf.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/24_hu_d786bb834a98e802.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;159&#34;
		data-flex-basis=&#34;383px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;通过上图，我们发现线程池有两个线程数的设置，一个为核心线程数，一个为最大线程数。在创建完线程池之后，默认情况下，线程池中并没有任何线程，等到有任务来才创建线程去执行任务。&lt;/p&gt;
&lt;p&gt;但有一种情况排除在外，就是调用 prestartAllCoreThreads() 或者 prestartCoreThread() 方法的话，可以提前创建等于核心线程数的线程数量，这种方式被称为预热，在抢购系统中就经常被用到。&lt;/p&gt;
&lt;p&gt;当创建的线程数等于 corePoolSize 时，提交的任务会被加入到设置的阻塞队列中。当队列满了，会创建线程执行任务，直到线程池中的数量等于 maximumPoolSize。&lt;/p&gt;
&lt;p&gt;当线程数量已经等于 maximumPoolSize 时， 新提交的任务无法加入到等待队列，也无法创建非核心线程直接执行，我们又没有为线程池设置拒绝策略，这时线程池就会抛出 RejectedExecutionException 异常，即线程池拒绝接受这个任务。&lt;/p&gt;
&lt;p&gt;当线程池中创建的线程数量超过设置的 corePoolSize，在某些线程处理完任务后，如果等待 keepAliveTime 时间后仍然没有新的任务分配给它，那么这个线程将会被回收。线程池回收线程时，会对所谓的“核心线程”和“非核心线程”一视同仁，直到线程池中线程的数量等于设置的 corePoolSize 参数，回收过程才会停止。&lt;/p&gt;
&lt;p&gt;即使是 corePoolSize 线程，在一些非核心业务的线程池中，如果长时间地占用线程数量，也可能会影响到核心业务的线程池，这个时候就需要把没有分配任务的线程回收掉。&lt;/p&gt;
&lt;p&gt;我们可以通过 allowCoreThreadTimeOut 设置项要求线程池：将包括“核心线程”在内的，没有任务分配的所有线程，在等待 keepAliveTime 时间后全部回收掉。&lt;/p&gt;
&lt;p&gt;我们可以通过下面这张图来了解下线程池的线程分配流程：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/25.jpeg&#34;
	width=&#34;746&#34;
	height=&#34;950&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/25_hu_c725fbc2c23cb59d.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/25_hu_d484fad123825f27.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;78&#34;
		data-flex-basis=&#34;188px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;43-计算线程数量&#34;&gt;4.3 计算线程数量
&lt;/h2&gt;&lt;p&gt;我们知道，环境具有多变性，设置一个绝对精准的线程数其实是不大可能的，但我们可以通过一些实际操作因素来计算出一个合理的线程数，避免由于线程池设置不合理而导致的性能问题。下面我们就来看看具体的计算方法。&lt;/p&gt;
&lt;p&gt;一般多线程执行的任务类型可以分为 CPU 密集型和 I/O 密集型，根据不同的任务类型，我们计算线程数的方法也不一样。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU 密集型任务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1，比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;I/O 密集型任务&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。&lt;/p&gt;
&lt;p&gt;看完以上两种情况下的线程计算方法，你可能还想说，在平常的应用场景中，我们常常遇不到这两种极端情况，那么碰上一些常规的业务操作，比如，通过一个线程池实现向用户定时推送消息的业务，我们又该如何设置线程池的数量呢？&lt;/p&gt;
&lt;p&gt;此时我们可以参考以下公式来计算线程数：&lt;/p&gt;
&lt;p&gt;$线程数 =N（CPU 核数）*（1+WT（线程等待时间）/ST（线程时间运行时间））$&lt;/p&gt;
&lt;p&gt;我们可以通过 JDK 自带的工具 VisualVM 来查看 WT/ST 比例，以下例子是基于运行纯 CPU 运算的例子，我们可以看到：&lt;/p&gt;
&lt;p&gt;$WT（线程等待时间）= 36788ms [线程运行总时间] - 36788ms[ST（线程时间运行时间）]= 0$
$线程数 =N（CPU 核数）*（1+ 0 [WT（线程等待时间）]/36788ms[ST（线程时间运行时间）]）= N（CPU 核数）$&lt;/p&gt;
&lt;h1 id=&#34;5-如何用协程来优化多线程业务&#34;&gt;5. 如何用协程来优化多线程业务？
&lt;/h1&gt;&lt;p&gt;近一两年，国内很多互联网公司开始使用或转型 Go 语言，其中一个很重要的原因就是 Go 语言优越的性能表现，而这个优势与 Go 实现的轻量级线程 Goroutines（协程 Coroutine）不无关系。那么 Go 协程的实现与 Java 线程的实现有什么区别呢？&lt;/p&gt;
&lt;h2 id=&#34;51-线程实现模型&#34;&gt;5.1 线程实现模型
&lt;/h2&gt;&lt;p&gt;了解协程和线程的区别之前，我们不妨先来了解下底层实现线程几种方式，为后面的学习打个基础。&lt;/p&gt;
&lt;p&gt;实现线程主要有三种方式：轻量级进程和内核线程一对一相互映射实现的 1:1 线程模型、用户线程和内核线程实现的 N:1 线程模型以及用户线程和轻量级进程混合实现的 N:M 线程模型。&lt;/p&gt;
&lt;p&gt;1:1 线程模型&lt;/p&gt;
&lt;p&gt;以上我提到的内核线程（Kernel-Level Thread, KLT）是由操作系统内核支持的线程，内核通过调度器对线程进行调度，并负责完成线程的切换。&lt;/p&gt;
&lt;p&gt;我们知道在 Linux 操作系统编程中，往往都是通过 fork() 函数创建一个子进程来代表一个内核中的线程。一个进程调用 fork() 函数后，系统会先给新的进程分配资源，例如，存储数据和代码的空间。然后把原来进程的所有值都复制到新的进程中，只有少数值与原来进程的值（比如 PID）不同，这相当于复制了一个主进程。&lt;/p&gt;
&lt;p&gt;采用 fork() 创建子进程的方式来实现并行运行，会产生大量冗余数据，即占用大量内存空间，又消耗大量 CPU 时间用来初始化内存空间以及复制数据。&lt;/p&gt;
&lt;p&gt;如果是一份一样的数据，为什么不共享主进程的这一份数据呢？这时候轻量级进程（Light Weight Process，即 LWP）出现了。&lt;/p&gt;
&lt;p&gt;相对于 fork() 系统调用创建的线程来说，LWP 使用 clone() 系统调用创建线程，该函数是将部分父进程的资源的数据结构进行复制，复制内容可选，且没有被复制的资源可以通过指针共享给子进程。因此，轻量级进程的运行单元更小，运行速度更快。LWP 是跟内核线程一对一映射的，每个 LWP 都是由一个内核线程支持。&lt;/p&gt;
&lt;p&gt;N:1 线程模型&lt;/p&gt;
&lt;p&gt;1:1 线程模型由于跟内核是一对一映射，所以在线程创建、切换上都存在用户态和内核态的切换，性能开销比较大。除此之外，它还存在局限性，主要就是指系统的资源有限，不能支持创建大量的 LWP。&lt;/p&gt;
&lt;p&gt;N:1 线程模型就可以很好地解决 1:1 线程模型的这两个问题。&lt;/p&gt;
&lt;p&gt;N:M 线程模型&lt;/p&gt;
&lt;p&gt;N:1 线程模型的缺点在于操作系统不能感知用户态的线程，因此容易造成某一个线程进行系统调用内核线程时被阻塞，从而导致整个进程被阻塞。&lt;/p&gt;
&lt;p&gt;N:M 线程模型是基于上述两种线程模型实现的一种混合线程管理模型，即支持用户态线程通过 LWP 与内核线程连接，用户态的线程数量和内核态的 LWP 数量是 N:M 的映射关系。&lt;/p&gt;
&lt;p&gt;了解完这三个线程模型，你就可以清楚地了解到 Go 协程的实现与 Java 线程的实现有什么区别了。&lt;/p&gt;
&lt;p&gt;JDK 1.8 Thread.java 中 Thread#start 方法的实现，实际上是通过 Native 调用 start0 方法实现的；在 Linux 下， JVM Thread 的实现是基于 pthread_create 实现的，而 pthread_create 实际上是调用了 clone() 完成系统调用创建线程的。&lt;/p&gt;
&lt;p&gt;所以，目前 Java 在 Linux 操作系统下采用的是用户线程加轻量级线程，一个用户线程映射到一个内核线程，即 1:1 线程模型。由于线程是通过内核调度，从一个线程切换到另一个线程就涉及到了上下文切换。&lt;/p&gt;
&lt;p&gt;而 Go 语言是使用了 N:M 线程模型实现了自己的调度器，它在 N 个内核线程上多路复用（或调度）M 个协程，协程的上下文切换是在用户态由协程调度器完成的，因此不需要陷入内核，相比之下，这个代价就很小了。&lt;/p&gt;
&lt;h2 id=&#34;52-协程的实现原理&#34;&gt;5.2 协程的实现原理
&lt;/h2&gt;&lt;p&gt;协程不只在 Go 语言中实现了，其实目前大部分语言都实现了自己的一套协程，包括 C#、erlang、python、lua、javascript、ruby 等。&lt;/p&gt;
&lt;p&gt;相对于协程，你可能对进程和线程更为熟悉。进程一般代表一个应用服务，在一个应用服务中可以创建多个线程，而协程与进程、线程的概念不一样，我们可以将协程看作是一个类函数或者一块函数中的代码，我们可以在一个主线程里面轻松创建多个协程。&lt;/p&gt;
&lt;p&gt;程序调用协程与调用函数不一样的是，协程可以通过暂停或者阻塞的方式将协程的执行挂起，而其它协程可以继续执行。这里的挂起只是在程序中（用户态）的挂起，同时将代码执行权转让给其它协程使用，待获取执行权的协程执行完成之后，将从挂起点唤醒挂起的协程。 协程的挂起和唤醒是通过一个调度器来完成的。&lt;/p&gt;
&lt;p&gt;结合下图，你可以更清楚地了解到基于 N:M 线程模型实现的协程是如何工作的。&lt;/p&gt;
&lt;p&gt;假设程序中默认创建两个线程为协程使用，在主线程中创建协程 ABCD…，分别存储在就绪队列中，调度器首先会分配一个工作线程 A 执行协程 A，另外一个工作线程 B 执行协程 B，其它创建的协程将会放在队列中进行排队等待。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/26.jpeg&#34;
	width=&#34;666&#34;
	height=&#34;870&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/26_hu_89f9a5ec2a7ebda.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/26_hu_2817f33c9ca5d3d2.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;76&#34;
		data-flex-basis=&#34;183px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;当协程 A 调用暂停方法或被阻塞时，协程 A 会进入到挂起队列，调度器会调用等待队列中的其它协程抢占线程 A 执行。当协程 A 被唤醒时，它需要重新进入到就绪队列中，通过调度器抢占线程，如果抢占成功，就继续执行协程 A，失败则继续等待抢占线程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/27.jpeg&#34;
	width=&#34;656&#34;
	height=&#34;874&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/27_hu_c4a1285de746dbff.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/27_hu_e094d41c5977cd05.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;75&#34;
		data-flex-basis=&#34;180px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;相比线程，协程少了由于同步资源竞争带来的 CPU 上下文切换，I/O 密集型的应用比较适合使用，特别是在网络请求中，有较多的时间在等待后端响应，协程可以保证线程不会阻塞在等待网络响应中，充分利用了多核多线程的能力。而对于 CPU 密集型的应用，由于在多数情况下 CPU 都比较繁忙，协程的优势就不是特别明显了。&lt;/p&gt;
&lt;h2 id=&#34;53-kilim-协程框架&#34;&gt;5.3 Kilim 协程框架
&lt;/h2&gt;&lt;p&gt;虽然这么多的语言都实现了协程，但目前 Java 原生语言暂时还不支持协程。不过你也不用泄气，我们可以通过协程框架在 Java 中使用协程。&lt;/p&gt;
&lt;p&gt;目前 Kilim 协程框架在 Java 中应用得比较多，通过这个框架，开发人员就可以低成本地在 Java 中使用协程了。&lt;/p&gt;
&lt;p&gt;在 Java 中引入 Kilim ，和我们平时引入第三方组件不太一样，除了引入 jar 包之外，还需要通过 Kilim 提供的织入（Weaver）工具对 Java 代码编译生成的字节码进行增强处理，比如，识别哪些方式是可暂停的，对相关的方法添加上下文处理。通常有以下四种方式可以实现这种织入操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在编译时使用 maven 插件；&lt;/li&gt;
&lt;li&gt;在运行时调用 kilim.tools.Weaver 工具；&lt;/li&gt;
&lt;li&gt;在运行时使用 kilim.tools.Kilim invoking 调用 Kilim 的类文件；&lt;/li&gt;
&lt;li&gt;在 main 函数添加 if (kilim.tools.Kilim.trampoline(false,args)) return。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Kilim 框架包含了四个核心组件，分别为：任务载体（Task）、任务上下文（Fiber）、任务调度器（Scheduler）以及通信载体（Mailbox）。&lt;/p&gt;
&lt;h1 id=&#34;6-什么是数据的强弱一致性&#34;&gt;6. 什么是数据的强、弱一致性？
&lt;/h1&gt;&lt;p&gt;说到一致性，其实在系统的很多地方都存在数据一致性的相关问题。除了在并发编程中保证共享变量数据的一致性之外，还有数据库的 ACID 中的 C（Consistency 一致性）、分布式系统的 CAP 理论中的 C（Consistency 一致性）。&lt;/p&gt;
&lt;p&gt;在并发编程中，Java 是通过共享内存来实现共享变量操作的，所以在多线程编程中就会涉及到数据一致性的问题。&lt;/p&gt;
&lt;p&gt;我先通过一个经典的案例来说明下多线程操作共享变量可能出现的问题，假设我们有两个线程（线程 1 和线程 2）分别执行下面的方法，x 是共享变量：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;// 代码 1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public class Example {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    int x = 0;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    public void count() {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        x++;                     //1
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        System.out.println(x)//2
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;线程1 调用 count(),x++;&lt;/p&gt;
&lt;p&gt;线程2 调用 count(),x++;
如果两个线程同时运行，两个线程的变量的值可能会出现以下三种结果：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;1,1&lt;/li&gt;
&lt;li&gt;2,1&lt;/li&gt;
&lt;li&gt;1,2&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;61-java-内存模型&#34;&gt;6.1 Java 内存模型
&lt;/h2&gt;&lt;p&gt;2,1 和 1,2 的结果我们很好理解，那为什么会出现以上 1,1 的结果呢？&lt;/p&gt;
&lt;p&gt;我们知道，Java 采用共享内存模型来实现多线程之间的信息交换和数据同步。在解释为什么会出现这样的结果之前，我们先通过下图来简单了解下 Java 的内存模型，程序在运行时，局部变量将会存放在虚拟机栈中，而共享变量将会被保存在堆内存中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/28.jpeg&#34;
	width=&#34;1022&#34;
	height=&#34;664&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/28_hu_27188a0106f4e18a.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%983/28_hu_a472ab4c97184c80.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;153&#34;
		data-flex-basis=&#34;369px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;由于局部变量是跟随线程的创建而创建，线程的销毁而销毁，所以存放在栈中，由上图我们可知，Java 栈数据不是所有线程共享的，所以不需要关心其数据的一致性。&lt;/p&gt;
&lt;p&gt;共享变量存储在堆内存或方法区中，由上图可知，堆内存和方法区的数据是线程共享的。而堆内存中的共享变量在被不同线程操作时，会被加载到自己的工作内存中，也就是 CPU 中的高速缓存。&lt;/p&gt;
&lt;p&gt;CPU 缓存可以分为一级缓存（L1）、二级缓存（L2）和三级缓存（L3），每一级缓存中所储存的全部数据都是下一级缓存的一部分。当 CPU 要读取一个缓存数据时，首先会从一级缓存中查找；如果没有找到，再从二级缓存中查找；如果还是没有找到，就从三级缓存或内存中查找。&lt;/p&gt;
&lt;p&gt;如果是单核 CPU 运行多线程，多个线程同时访问进程中的共享数据，CPU 将共享变量加载到高速缓存后，不同线程在访问缓存数据的时候，都会映射到相同的缓存位置，这样即使发生线程的切换，缓存仍然不会失效。&lt;/p&gt;
&lt;p&gt;如果是多核 CPU 运行多线程，每个核都有一个 L1 缓存，如果多个线程运行在不同的内核上访问共享变量时，每个内核的 L1 缓存将会缓存一份共享变量。&lt;/p&gt;
&lt;p&gt;假设线程 A 操作 CPU 从堆内存中获取一个缓存数据，此时堆内存中的缓存数据值为 0，该缓存数据会被加载到 L1 缓存中，在操作后，缓存数据的值变为 1，然后刷新到堆内存中。&lt;/p&gt;
&lt;p&gt;在正好刷新到堆内存中之前，又有另外一个线程 B 将堆内存中为 0 的缓存数据加载到了另外一个内核的 L1 缓存中，此时线程 A 将堆内存中的数据刷新到了 1，而线程 B 实际拿到的缓存数据的值为 0。&lt;/p&gt;
&lt;p&gt;此时，内核缓存中的数据和堆内存中的数据就不一致了，且线程 B 在刷新缓存到堆内存中的时候也将覆盖线程 A 中修改的数据。这时就产生了数据不一致的问题。&lt;/p&gt;
&lt;h2 id=&#34;62-重排序&#34;&gt;6.2 重排序
&lt;/h2&gt;&lt;p&gt;在不影响运算结果的前提下，编译器有可能会改变顺序代码的指令执行顺序，特别是在一些可以优化的场景。&lt;/p&gt;
&lt;p&gt;例如，在以下案例中，编译器为了尽可能地减少寄存器的读取、存储次数，会充分复用寄存器的存储值。如果没有进行重排序优化，正常的执行顺序是步骤 1\2\3，而在编译期间进行了重排序优化之后，执行的步骤有可能就变成了步骤 1/3/2 或者 2/1/3，这样就能减少一次寄存器的存取次数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;int x = 1;// 步骤 1：加载 x 变量的内存地址到寄存器中，加载 1 到寄存器中，CPU 通过 mov 指令把 1 写入到寄存器指定的内存中
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;boolean flag = true; // 步骤 2 加载 flag 变量的内存地址到寄存器中，加载 true 到寄存器中，CPU 通过 mov 指令把 1 写入到寄存器指定的内存中
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;int y = x + 1;// 步骤 3 重新加载 a 变量的内存地址到寄存器中，加载 1 到寄存器中，CPU 通过 mov 指令把 1 写入到寄存器指定的内存中
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在 JVM 中，重排序是十分重要的一环，特别是在并发编程中。可 JVM 要是能对它们进行任意排序的话，也可能会给并发编程带来一系列的问题，其中就包括了一致性的问题。&lt;/p&gt;
&lt;h2 id=&#34;63-happens-before-规则&#34;&gt;6.3 Happens-before 规则
&lt;/h2&gt;&lt;p&gt;为了解决这个问题，Java 提出了 Happens-before 规则来规范线程的执行顺序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序次序规则：在单线程中，代码的执行是有序的，虽然可能会存在运行指令的重排序，但最终执行的结果和顺序执行的结果是一致的；&lt;/li&gt;
&lt;li&gt;锁定规则：一个锁处于被一个线程锁定占用状态，那么只有当这个线程释放锁之后，其它线程才能再次获取锁操作；&lt;/li&gt;
&lt;li&gt;volatile 变量规则：如果一个线程正在写 volatile 变量，其它线程读取该变量会发生在写入之后；&lt;/li&gt;
&lt;li&gt;线程启动规则：Thread 对象的 start() 方法先行发生于此线程的其它每一个动作；&lt;/li&gt;
&lt;li&gt;线程终结规则：线程中的所有操作都先行发生于对此线程的终止检测；&lt;/li&gt;
&lt;li&gt;对象终结规则：一个对象的初始化完成先行发生于它的 finalize() 方法的开始；&lt;/li&gt;
&lt;li&gt;传递性：如果操作 A happens-before 操作 B，操作 B happens-before 操作 C，那么操作 A happens-before 操作 C；&lt;/li&gt;
&lt;li&gt;线程中断规则：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;结合这些规则，我们可以将一致性分为以下几个级别：&lt;/p&gt;
&lt;p&gt;严格一致性（强一致性）：所有的读写操作都按照全局时钟下的顺序执行，且任何时刻线程读取到的缓存数据都是一样的，Hashtable 就是严格一致性&lt;/p&gt;
&lt;p&gt;顺序一致性：多个线程的整体执行可能是无序的，但对于单个线程而言执行是有序的，要保证任何一次读都能读到最近一次写入的数据，volatile 可以阻止指令重排序，所以修饰的变量的程序属于顺序一致性；&lt;/p&gt;
&lt;p&gt;弱一致性：不能保证任何一次读都能读到最近一次写入的数据，但能保证最终可以读到写入的数据，单个写锁 + 无锁读，就是弱一致性的一种实现。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Java性能调优2</title>
        <link>https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/</link>
        <pubDate>Wed, 24 Feb 2021 19:51:41 +0800</pubDate>
        
        <guid>https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/</guid>
        <description>&lt;h1 id=&#34;java性能调优2---java编程性能调优&#34;&gt;Java性能调优2 &amp;mdash;- Java编程性能调优
&lt;/h1&gt;&lt;h1 id=&#34;1-字符串性能优化&#34;&gt;1. 字符串性能优化
&lt;/h1&gt;&lt;p&gt;String 对象是我们使用最频繁的一个对象类型，但它的性能问题却是最容易被忽略的。String 对象作为 Java 语言中重要的数据类型，是内存中占据空间最大的一个对象。高效地使用字符串，可以提升系统的整体性能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思考题&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;String str1= &amp;#34;abc&amp;#34;;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;String str2= new String(&amp;#34;abc&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;String str3= str2.intern();
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;assertSame(str1==str2); //false
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;assertSame(str2==str3);//false
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;assertSame(str1==str3)//true
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;11-string-对象是如何实现的&#34;&gt;1.1 String 对象是如何实现的？
&lt;/h2&gt;&lt;p&gt;在 Java 语言中，Sun 公司的工程师们对 String 对象做了大量的优化，来节约内存空间，提升 String 对象在系统中的性能。一起来看看优化过程，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/01.jpeg&#34;
	width=&#34;1632&#34;
	height=&#34;636&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/01_hu_a03605954967e478.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/01_hu_a2eaba0a6b99c4e3.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;256&#34;
		data-flex-basis=&#34;615px&#34;
	
&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 Java6 以及之前的版本中，String 对象是对 char 数组进行了封装实现的对象，主要有四个成员变量：char 数组、偏移量 offset、字符数量 count、哈希值 hash。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;String 对象是通过 offset 和 count 两个属性来定位 char[] 数组，获取字符串。这么做可以高效、快速地共享数组对象，同时节省内存空间，但这种方式很有可能会导致内存泄漏。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;
&lt;p&gt;从 Java7 版本开始到 Java8 版本，Java 对 String 类做了一些改变。String 类中不再有 offset 和 count 两个变量了。这样的好处是 String 对象占用的内存稍微少了些，同时，String.substring 方法也不再共享 char[]，从而解决了使用该方法可能导致的内存泄漏问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从 Java9 版本开始，工程师将 char[] 字段改为了 byte[] 字段，又维护了一个新的属性 coder，它是一个编码格式的标识。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为什么这样修改呢？&lt;/p&gt;
&lt;p&gt;我们知道一个 char 字符占 16 位，2 个字节。这个情况下，存储单字节编码内的字符（占一个字节的字符）就显得非常浪费。JDK1.9 的 String 类为了节约内存空间，于是使用了占 8 位，1 个字节的 byte 数组来存放字符串。&lt;/p&gt;
&lt;p&gt;而新属性 coder 的作用是，在计算字符串长度或者使用 indexOf（）函数时，我们需要根据这个字段，判断如何计算字符串长度。coder 属性默认有 0 和 1 两个值，0 代表 Latin-1（单字节编码），1 代表 UTF-16。如果 String 判断字符串只包含了 Latin-1，则 coder 属性值为 0，反之则为 1。&lt;/p&gt;
&lt;h2 id=&#34;12-string-对象的不可变性&#34;&gt;1.2 String 对象的不可变性
&lt;/h2&gt;&lt;p&gt;了解了 String 对象的实现后，你有没有发现在实现代码中 String 类被 final 关键字修饰了，而且变量 char 数组也被 final 修饰了。&lt;/p&gt;
&lt;p&gt;我们知道类被 final 修饰代表该类不可继承，而 char[] 被 final+private 修饰，代表了 String 对象不可被更改。Java 实现的这个特性叫作 String 对象的不可变性，即 String 对象一旦创建成功，就不能再对它进行改变。&lt;/p&gt;
&lt;h3 id=&#34;121-java-这样做的好处在哪里呢&#34;&gt;1.2.1 Java 这样做的好处在哪里呢？
&lt;/h3&gt;&lt;p&gt;第一，保证 String 对象的安全性。假设 String 对象是可变的，那么 String 对象将可能被恶意修改。&lt;/p&gt;
&lt;p&gt;第二，保证 hash 属性值不会频繁变更，确保了唯一性，使得类似 HashMap 容器才能实现相应的 key-value 缓存功能。&lt;/p&gt;
&lt;p&gt;第三，可以实现字符串常量池。在 Java 中，通常有两种创建字符串对象的方式，一种是通过字符串常量的方式创建，如 String str=“abc”；另一种是字符串变量通过 new 形式的创建，如 String str = new String(“abc”)。&lt;/p&gt;
&lt;p&gt;当代码中使用第一种方式创建字符串对象时，JVM 首先会检查该对象是否在字符串常量池中，如果在，就返回该对象引用，否则新的字符串将在常量池中被创建。这种方式可以减少同一个值的字符串对象的重复创建，节约内存。&lt;/p&gt;
&lt;p&gt;String str = new String(“abc”) 这种方式，首先在编译类文件时，&amp;ldquo;abc&amp;quot;常量字符串将会放入到常量结构中，在类加载时，“abc&amp;quot;将会在常量池中创建；其次，在调用 new 时，JVM 命令将会调用 String 的构造函数，同时引用常量池中的&amp;quot;abc” 字符串，在堆内存中创建一个 String 对象；最后，str 将引用 String 对象。&lt;/p&gt;
&lt;h2 id=&#34;13-string-对象的优化&#34;&gt;1.3 String 对象的优化
&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;如何构建超大字符串？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;编程过程中，字符串的拼接很常见。前面我讲过 String 对象是不可变的，如果我们使用 String 对象相加，拼接我们想要的字符串，是不是就会产生多个对象呢？例如以下代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;String str= &amp;#34;ab&amp;#34; + &amp;#34;cd&amp;#34; + &amp;#34;ef&amp;#34;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;分析代码可知：首先会生成 ab 对象，再生成 abcd 对象，最后生成 abcdef 对象，从理论上来说，这段代码是低效的。&lt;/p&gt;
&lt;p&gt;但实际运行中，我们发现只有一个对象生成，这是为什么呢？难道我们的理论判断错了？我们再来看编译后的代码，你会发现编译器自动优化了这行代码，如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;String str= &amp;#34;abcdef&amp;#34;;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;上面我介绍的是字符串常量的累计，我们再来看看字符串变量的累计又是怎样的呢？&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;String str = &amp;#34;abcdef&amp;#34;;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;for(int i=0; i&amp;lt;1000; i++) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      str = str + i;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;上面的代码编译后，你可以看到编译器同样对这段代码进行了优化。不难发现，Java 在进行字符串的拼接时，偏向使用 StringBuilder，这样可以提高程序的效率。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;String str = &amp;#34;abcdef&amp;#34;;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;for(int i=0; i&amp;lt;1000; i++) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;       	  str = (new StringBuilder(String.valueOf(str))).append(i).toString();
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;综上已知：即使使用 + 号作为字符串的拼接，也一样可以被编译器优化成 StringBuilder 的方式。但再细致些，你会发现在编译器优化的代码中，每次循环都会生成一个新的 StringBuilder 实例，同样也会降低系统的性能。&lt;/p&gt;
&lt;p&gt;所以平时做字符串拼接的时候，我建议你还是要显示地使用 String Builder 来提升系统性能。&lt;/p&gt;
&lt;p&gt;如果在多线程编程中，String 对象的拼接涉及到线程安全，你可以使用 StringBuffer。但是要注意，由于 StringBuffer 是线程安全的，涉及到锁竞争，所以从性能上来说，要比 StringBuilder 差一些。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;如何使用 String.intern 节省内存？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;讲完了构建字符串，我们再来讨论下 String 对象的存储问题。先看一个案例。&lt;/p&gt;
&lt;p&gt;Twitter 每次发布消息状态的时候，都会产生一个地址信息，以当时 Twitter 用户的规模预估，服务器需要 32G 的内存来存储地址信息。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public class Location {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    private String city;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    private String region;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    private String countryCode;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    private double longitude;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    private double latitude;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;} 
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;考虑到其中有很多用户在地址信息上是有重合的，比如，国家、省份、城市等，这时就可以将这部分信息单独列出一个类，以减少重复，代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public class SharedLocation {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	private String city;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	private String region;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	private String countryCode;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public class Location {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	private SharedLocation sharedLocation;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	double longitude;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	double latitude;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;通过优化，数据存储大小减到了 20G 左右。但对于内存存储这个数据来说，依然很大，怎么办呢？&lt;/p&gt;
&lt;p&gt;这个案例来自一位 Twitter 工程师在 QCon 全球软件开发大会上的演讲，他们想到的解决方法，就是使用 String.intern 来节省内存空间，从而优化 String 对象的存储。&lt;/p&gt;
&lt;p&gt;具体做法就是，在每次赋值的时候使用 String 的 intern 方法，如果常量池中有相同值，就会重复使用该对象，返回对象引用，这样一开始的对象就可以被回收掉。这种方式可以使重复性非常高的地址信息存储大小从 20G 降到几百兆。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;SharedLocation sharedLocation = new SharedLocation();
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sharedLocation.setCity(messageInfo.getCity().intern());		sharedLocation.setCountryCode(messageInfo.getRegion().intern());
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;sharedLocation.setRegion(messageInfo.getCountryCode().intern());
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Location location = new Location();
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;location.set(sharedLocation);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;location.set(messageInfo.getLongitude());
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;location.set(messageInfo.getLatitude());
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;为了更好地理解，我们再来通过一个简单的例子，回顾下其中的原理：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;String a =new String(&amp;#34;abc&amp;#34;).intern();
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;String b = new String(&amp;#34;abc&amp;#34;).intern();
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    	  
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;if(a==b) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    System.out.print(&amp;#34;a==b&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;输出结果：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;a==b
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在字符串常量中，默认会将对象放入常量池；在字符串变量中，对象是会创建在堆内存中，同时也会在常量池中创建一个字符串对象，复制到堆内存对象中，并返回堆内存对象引用。&lt;/p&gt;
&lt;p&gt;如果调用 intern 方法，会去查看字符串常量池中是否有等于该对象的字符串，如果没有，就在常量池中新增该对象，并返回该对象引用；如果有，就返回常量池中的字符串引用。堆内存中原有的对象由于没有引用指向它，将会通过垃圾回收器回收。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;如何使用字符串的分割方法？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最后我想跟你聊聊字符串的分割，这种方法在编码中也很最常见。Split() 方法使用了正则表达式实现了其强大的分割功能，而正则表达式的性能是非常不稳定的，使用不恰当会引起回溯问题，很可能导致 CPU 居高不下。&lt;/p&gt;
&lt;p&gt;所以我们应该慎重使用 Split() 方法，我们可以用 String.indexOf() 方法代替 Split() 方法完成字符串的分割。如果实在无法满足需求，你就在使用 Split() 方法时，对回溯问题加以重视就可以了。&lt;/p&gt;
&lt;h1 id=&#34;2-正则表达式&#34;&gt;2. 正则表达式
&lt;/h1&gt;&lt;h2 id=&#34;21什么是正则表达式&#34;&gt;2.1什么是正则表达式？
&lt;/h2&gt;&lt;p&gt;正则表达式是计算机科学的一个概念，很多语言都实现了它。正则表达式使用一些特定的元字符来检索、匹配以及替换符合规则的字符串。&lt;/p&gt;
&lt;p&gt;构造正则表达式语法的元字符，由普通字符、标准字符、限定字符（量词）、定位字符（边界字符）组成。详情可见下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/02.jpeg&#34;
	width=&#34;1782&#34;
	height=&#34;800&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/02_hu_50865cbd933d5c8d.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/02_hu_bdc4a864cc08616c.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;222&#34;
		data-flex-basis=&#34;534px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;22-正则表达式引擎&#34;&gt;2.2 正则表达式引擎
&lt;/h2&gt;&lt;p&gt;正则表达式是一个用正则符号写出的公式，程序对这个公式进行语法分析，建立一个语法分析树，再根据这个分析树结合正则表达式的引擎生成执行程序（这个执行程序我们把它称作状态机，也叫状态自动机），用于字符匹配。&lt;/p&gt;
&lt;p&gt;而这里的正则表达式引擎就是一套核心算法，用于建立状态机。&lt;/p&gt;
&lt;p&gt;目前实现正则表达式引擎的方式有两种：DFA 自动机（Deterministic Final Automata 确定有限状态自动机）和 NFA 自动机（Non deterministic Finite Automaton 非确定有限状态自动机）。&lt;/p&gt;
&lt;p&gt;对比来看，构造 DFA 自动机的代价远大于 NFA 自动机，但 DFA 自动机的执行效率高于 NFA 自动机。&lt;/p&gt;
&lt;p&gt;假设一个字符串的长度是 n，如果用 DFA 自动机作为正则表达式引擎，则匹配的时间复杂度为 O(n)；如果用 NFA 自动机作为正则表达式引擎，由于 NFA 自动机在匹配过程中存在大量的分支和回溯，假设 NFA 的状态数为 s，则该匹配算法的时间复杂度为 O（ns）。&lt;/p&gt;
&lt;p&gt;NFA 自动机的优势是支持更多功能。例如，捕获 group、环视、占有优先量词等高级功能。这些功能都是基于子表达式独立进行匹配，因此在编程语言里，使用的正则表达式库都是基于 NFA 实现的。&lt;/p&gt;
&lt;p&gt;那么 NFA 自动机到底是怎么进行匹配的呢？我以下面的字符和表达式来举例说明。&lt;/p&gt;
&lt;p&gt;text=“aabcab”
regex=“bc”&lt;/p&gt;
&lt;p&gt;NFA 自动机会读取正则表达式的每一个字符，拿去和目标字符串匹配，匹配成功就换正则表达式的下一个字符，反之就继续和目标字符串的下一个字符进行匹配。分解一下过程。&lt;/p&gt;
&lt;p&gt;首先，读取正则表达式的第一个匹配符和字符串的第一个字符进行比较，b 对 a，不匹配；继续换字符串的下一个字符，也是 a，不匹配；继续换下一个，是 b，匹配。&lt;/p&gt;
&lt;p&gt;然后，同理，读取正则表达式的第二个匹配符和字符串的第四个字符进行比较，c 对 c，匹配；继续读取正则表达式的下一个字符，然而后面已经没有可匹配的字符了，结束。&lt;/p&gt;
&lt;p&gt;这就是 NFA 自动机的匹配过程，虽然在实际应用中，碰到的正则表达式都要比这复杂，但匹配方法是一样的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/03.jpeg&#34;
	width=&#34;502&#34;
	height=&#34;612&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/03_hu_256d68615645d9c.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/03_hu_254e157dfc43abd2.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;82&#34;
		data-flex-basis=&#34;196px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/04.jpeg&#34;
	width=&#34;482&#34;
	height=&#34;214&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/04_hu_40c79d91ba4c2dcb.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/04_hu_7885485d2601dfb3.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;225&#34;
		data-flex-basis=&#34;540px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;23-nfa-自动机的回溯&#34;&gt;2.3 NFA 自动机的回溯
&lt;/h2&gt;&lt;p&gt;用 NFA 自动机实现的比较复杂的正则表达式，在匹配过程中经常会引起回溯问题。大量的回溯会长时间地占用 CPU，从而带来系统性能开销。我来举例说明。&lt;/p&gt;
&lt;p&gt;text=“abbc”
regex=“ab{1,3}c”&lt;/p&gt;
&lt;p&gt;这个例子，匹配目的比较简单。匹配以 a 开头，以 c 结尾，中间有 1-3 个 b 字符的字符串。NFA 自动机对其解析的过程是这样的：&lt;/p&gt;
&lt;p&gt;首先，读取正则表达式第一个匹配符 a 和字符串第一个字符 a 进行比较，a 对 a，匹配。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/05.jpeg&#34;
	width=&#34;384&#34;
	height=&#34;218&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/05_hu_6a2ed3027d02641e.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/05_hu_be9d89a7bbfc2cdb.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;176&#34;
		data-flex-basis=&#34;422px&#34;
	
&gt;
然后，读取正则表达式第二个匹配符 b{1,3} 和字符串的第二个字符 b 进行比较，匹配。但因为 b{1,3} 表示 1-3 个 b 字符串，NFA 自动机又具有贪婪特性，所以此时不会继续读取正则表达式的下一个匹配符，而是依旧使用 b{1,3} 和字符串的第三个字符 b 进行比较，结果还是匹配。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/06.jpeg&#34;
	width=&#34;392&#34;
	height=&#34;436&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/06_hu_5261e2606e7af03c.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/06_hu_b4f46466fa8eaf07.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;89&#34;
		data-flex-basis=&#34;215px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;接着继续使用 b{1,3} 和字符串的第四个字符 c 进行比较，发现不匹配了，此时就会发生回溯，已经读取的字符串第四个字符 c 将被吐出去，指针回到第三个字符 b 的位置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/07.jpeg&#34;
	width=&#34;400&#34;
	height=&#34;214&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/07_hu_bf237b3c6a699e59.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/07_hu_57412f4c86bd029c.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;186&#34;
		data-flex-basis=&#34;448px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;那么发生回溯以后，匹配过程怎么继续呢？程序会读取正则表达式的下一个匹配符 c，和字符串中的第四个字符 c 进行比较，结果匹配，结束。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/08.jpeg&#34;
	width=&#34;394&#34;
	height=&#34;228&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/08_hu_6c08979367bb9a57.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/08_hu_79ce622337cdcd91.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;172&#34;
		data-flex-basis=&#34;414px&#34;
	
&gt;&lt;/p&gt;
&lt;h2 id=&#34;24-如何避免回溯问题&#34;&gt;2.4 如何避免回溯问题？
&lt;/h2&gt;&lt;p&gt;既然回溯会给系统带来性能开销，那我们如何应对呢？如果你有仔细看上面那个案例的话，你会发现 NFA 自动机的贪婪特性就是导火索，这和正则表达式的匹配模式息息相关，一起来了解一下。&lt;/p&gt;
&lt;h3 id=&#34;241-贪婪模式greedy&#34;&gt;2.4.1 贪婪模式（Greedy）
&lt;/h3&gt;&lt;p&gt;顾名思义，就是在数量匹配中，如果单独使用 +、 ? 、* 或{min,max} 等量词，正则表达式会匹配尽可能多的内容。&lt;/p&gt;
&lt;p&gt;例如，上边那个例子：&lt;/p&gt;
&lt;p&gt;text=“abbc”
regex=“ab{1,3}c”&lt;/p&gt;
&lt;p&gt;就是在贪婪模式下，NFA 自动机读取了最大的匹配范围，即匹配 3 个 b 字符。匹配发生了一次失败，就引起了一次回溯。如果匹配结果是“abbbc”，就会匹配成功。&lt;/p&gt;
&lt;p&gt;text=“abbbc”
regex=“ab{1,3}c”&lt;/p&gt;
&lt;h3 id=&#34;242-懒惰模式reluctant&#34;&gt;2.4.2 懒惰模式（Reluctant）
&lt;/h3&gt;&lt;p&gt;在该模式下，正则表达式会尽可能少地重复匹配字符。如果匹配成功，它会继续匹配剩余的字符串。&lt;/p&gt;
&lt;p&gt;例如，在上面例子的字符后面加一个“？”，就可以开启懒惰模式。&lt;/p&gt;
&lt;p&gt;text=“abc”
regex=“ab{1,3}?c”&lt;/p&gt;
&lt;p&gt;匹配结果是“abc”，该模式下 NFA 自动机首先选择最小的匹配范围，即匹配 1 个 b 字符，因此就避免了回溯问题。&lt;/p&gt;
&lt;h3 id=&#34;243--独占模式possessive&#34;&gt;2.4.3  独占模式（Possessive）
&lt;/h3&gt;&lt;p&gt;同贪婪模式一样，独占模式一样会最大限度地匹配更多内容；不同的是，在独占模式下，匹配失败就会结束匹配，不会发生回溯问题。&lt;/p&gt;
&lt;p&gt;还是上边的例子，在字符后面加一个“+”，就可以开启独占模式。&lt;/p&gt;
&lt;p&gt;text=“abbc”
regex=“ab{1,3}+bc”&lt;/p&gt;
&lt;p&gt;结果是不匹配，结束匹配，不会发生回溯问题。讲到这里，你应该非常清楚了，避免回溯的方法就是：使用懒惰模式和独占模式。&lt;/p&gt;
&lt;h2 id=&#34;25-正则表达式的优化&#34;&gt;2.5 正则表达式的优化
&lt;/h2&gt;&lt;h3 id=&#34;251-1-少用贪婪模式多用独占模式&#34;&gt;2.5.1 1. 少用贪婪模式，多用独占模式
&lt;/h3&gt;&lt;p&gt;贪婪模式会引起回溯问题，我们可以使用独占模式来避免回溯。前面详解过了，这里我就不再解释了。&lt;/p&gt;
&lt;h3 id=&#34;252-减少分支选择&#34;&gt;2.5.2 减少分支选择
&lt;/h3&gt;&lt;p&gt;分支选择类型“(X|Y|Z)”的正则表达式会降低性能，我们在开发的时候要尽量减少使用。如果一定要用，我们可以通过以下几种方式来优化：&lt;/p&gt;
&lt;p&gt;首先，我们需要考虑选择的顺序，将比较常用的选择项放在前面，使它们可以较快地被匹配；&lt;/p&gt;
&lt;p&gt;其次，我们可以尝试提取共用模式，例如，将“(abcd|abef)”替换为“ab(cd|ef)”，后者匹配速度较快，因为 NFA 自动机会尝试匹配 ab，如果没有找到，就不会再尝试任何选项；&lt;/p&gt;
&lt;p&gt;最后，如果是简单的分支选择类型，我们可以用三次 index 代替“(X|Y|Z)”，如果测试的话，你就会发现三次 index 的效率要比“(X|Y|Z)”高出一些。&lt;/p&gt;
&lt;h3 id=&#34;253-减少捕获嵌套&#34;&gt;2.5.3 减少捕获嵌套
&lt;/h3&gt;&lt;p&gt;在讲这个方法之前，我先简单介绍下什么是捕获组和非捕获组。&lt;/p&gt;
&lt;p&gt;捕获组是指把正则表达式中，子表达式匹配的内容保存到以数字编号或显式命名的数组中，方便后面引用。一般一个 () 就是一个捕获组，捕获组可以进行嵌套。&lt;/p&gt;
&lt;p&gt;非捕获组则是指参与匹配却不进行分组编号的捕获组，其表达式一般由（?:exp）组成。&lt;/p&gt;
&lt;p&gt;在正则表达式中，每个捕获组都有一个编号，编号 0 代表整个匹配到的内容。我们可以看下面的例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public static void main( String[] args )
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	String text = &amp;#34;&amp;lt;input high=\&amp;#34;20\&amp;#34; weight=\&amp;#34;70\&amp;#34;&amp;gt;test&amp;lt;/input&amp;gt;&amp;#34;;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	String reg=&amp;#34;(&amp;lt;input.*?&amp;gt;)(.*?)(&amp;lt;/input&amp;gt;)&amp;#34;;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	Pattern p = Pattern.compile(reg);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	Matcher m = p.matcher(text);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	while(m.find()) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		System.out.println(m.group(0));// 整个匹配到的内容
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		System.out.println(m.group(1));//(&amp;lt;input.*?&amp;gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		System.out.println(m.group(2));//(.*?)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		System.out.println(m.group(3));//(&amp;lt;/input&amp;gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;input high=\&amp;#34;20\&amp;#34; weight=\&amp;#34;70\&amp;#34;&amp;gt;test&amp;lt;/input&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;input high=\&amp;#34;20\&amp;#34; weight=\&amp;#34;70\&amp;#34;&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;test
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;/input&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果你并不需要获取某一个分组内的文本，那么就使用非捕获分组。例如，使用“(?:X)”代替“(X)”，我们再看下面的例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public static void main( String[] args )
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;{
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	String text = &amp;#34;&amp;lt;input high=\&amp;#34;20\&amp;#34; weight=\&amp;#34;70\&amp;#34;&amp;gt;test&amp;lt;/input&amp;gt;&amp;#34;;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	String reg=&amp;#34;(?:&amp;lt;input.*?&amp;gt;)(.*?)(?:&amp;lt;/input&amp;gt;)&amp;#34;;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	Pattern p = Pattern.compile(reg);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	Matcher m = p.matcher(text);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	while(m.find()) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		System.out.println(m.group(0));// 整个匹配到的内容
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;		System.out.println(m.group(1));//(.*?)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;	}
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;运行结果：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&amp;lt;input high=\&amp;#34;20\&amp;#34; weight=\&amp;#34;70\&amp;#34;&amp;gt;test&amp;lt;/input&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;test
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;综上可知：减少不需要获取的分组，可以提高正则表达式的性能。&lt;/p&gt;
&lt;h1 id=&#34;3-arraylist还是linkedlist使用不当性能差千倍&#34;&gt;3. ArrayList还是LinkedList？使用不当性能差千倍
&lt;/h1&gt;&lt;p&gt;集合作为一种存储数据的容器，是我们日常开发中使用最频繁的对象类型之一。JDK 为开发者提供了一系列的集合类型，这些集合类型使用不同的数据结构来实现。因此，不同的集合类型，使用场景也不同。&lt;/p&gt;
&lt;p&gt;很多同学在面试的时候，经常会被问到集合的相关问题，比较常见的有 ArrayList 和 LinkedList 的区别。&lt;/p&gt;
&lt;p&gt;相信大部分同学都能回答上：“ArrayList 是基于数组实现，LinkedList 是基于链表实现。”&lt;/p&gt;
&lt;p&gt;而在回答使用场景的时候，我发现大部分同学的答案是：“ArrayList 和 LinkedList 在新增、删除元素时，LinkedList 的效率要高于 ArrayList，而在遍历的时候，ArrayList 的效率要高于 LinkedList。”这个回答是否准确呢？今天这一讲就带你验证。&lt;/p&gt;
&lt;h2 id=&#34;31-初识-list-接口&#34;&gt;3.1 初识 List 接口
&lt;/h2&gt;&lt;p&gt;在学习 List 集合类之前，我们先来通过这张图，看下 List 集合类的接口和类的实现关系：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/09.jpeg&#34;
	width=&#34;1000&#34;
	height=&#34;1001&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/09_hu_69ca3197a95fdf03.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/09_hu_ea3a8ce72271e606.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;99&#34;
		data-flex-basis=&#34;239px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;我们可以看到 ArrayList、Vector、LinkedList 集合类继承了 AbstractList 抽象类，而 AbstractList 实现了 List 接口，同时也继承了 AbstractCollection 抽象类。ArrayList、Vector、LinkedList 又根据自我定位，分别实现了各自的功能。&lt;/p&gt;
&lt;p&gt;ArrayList 和 Vector 使用了数组实现，这两者的实现原理差不多，LinkedList 使用了双向链表实现。基础铺垫就到这里，接下来，我们就详细地分析下 ArrayList 和 LinkedList 的源码实现。&lt;/p&gt;
&lt;h2 id=&#34;32-arraylist-是如何实现的&#34;&gt;3.2 ArrayList 是如何实现的？
&lt;/h2&gt;&lt;p&gt;ArrayList 很常用，先来几道测试题，自检下你对 ArrayList 的了解程度。&lt;/p&gt;
&lt;p&gt;问题 1：我们在查看 ArrayList 的实现类源码时，你会发现对象数组 elementData 使用了 transient 修饰，我们知道 transient 关键字修饰该属性，则表示该属性不会被序列化，然而我们并没有看到文档中说明 ArrayList 不能被序列化，这是为什么？&lt;/p&gt;
&lt;p&gt;问题 2：我们在使用 ArrayList 进行新增、删除时，经常被提醒“使用 ArrayList 做新增删除操作会影响效率”。那是不是 ArrayList 在大量新增元素的场景下效率就一定会变慢呢？&lt;/p&gt;
&lt;p&gt;问题 3：如果让你使用 for 循环以及迭代循环遍历一个 ArrayList，你会使用哪种方式呢？原因是什么？&lt;/p&gt;
&lt;p&gt;如果你对这几道测试都没有一个全面的了解，那就跟我一起从数据结构、实现原理以及源码角度重新认识下 ArrayList 吧。&lt;/p&gt;
&lt;h3 id=&#34;321-arraylist-实现类&#34;&gt;3.2.1 ArrayList 实现类
&lt;/h3&gt;&lt;p&gt;ArrayList 实现了 List 接口，继承了 AbstractList 抽象类，底层是数组实现的，并且实现了自增扩容数组大小。&lt;/p&gt;
&lt;p&gt;ArrayList 还实现了 Cloneable 接口和 Serializable 接口，所以他可以实现克隆和序列化。&lt;/p&gt;
&lt;p&gt;ArrayList 还实现了 RandomAccess 接口。你可能对这个接口比较陌生，不知道具体的用处。通过代码我们可以发现，这个接口其实是一个空接口，什么也没有实现，那 ArrayList 为什么要去实现它呢？&lt;/p&gt;
&lt;p&gt;其实 RandomAccess 接口是一个标志接口，他标志着“只要实现该接口的 List 类，都能实现快速随机访问”。&lt;/p&gt;
&lt;h3 id=&#34;322-arraylist-属性&#34;&gt;3.2.2 ArrayList 属性
&lt;/h3&gt;&lt;p&gt;ArrayList 属性主要由数组长度 size、对象数组 elementData、初始化容量 default_capacity 等组成， 其中初始化容量默认大小为 10。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  // 默认初始化容量
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    private static final int DEFAULT_CAPACITY = 10;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    // 对象数组
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    transient Object[] elementData; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    // 数组长度
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    private int size;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;从 ArrayList 属性来看，它没有被任何的多线程关键字修饰，但 elementData 被关键字 transient 修饰了。这就是我在上面提到的第一道测试题：transient 关键字修饰该字段则表示该属性不会被序列化，但 ArrayList 其实是实现了序列化接口，这到底是怎么回事呢？&lt;/p&gt;
&lt;p&gt;这还得从“ArrayList 是基于数组实现“开始说起，由于 ArrayList 的数组是基于动态扩增的，所以并不是所有被分配的内存空间都存储了数据。&lt;/p&gt;
&lt;p&gt;如果采用外部序列化法实现数组的序列化，会序列化整个数组。ArrayList 为了避免这些没有存储数据的内存空间被序列化，内部提供了两个私有方法 writeObject 以及 readObject 来自我完成序列化与反序列化，从而在序列化与反序列化数组时节省了空间和时间。&lt;/p&gt;
&lt;p&gt;因此使用 transient 修饰数组，是防止对象数组被其他外部方法序列化。&lt;/p&gt;
&lt;h3 id=&#34;323-arraylist-构造函数&#34;&gt;3.2.3 ArrayList 构造函数
&lt;/h3&gt;&lt;p&gt;ArrayList 类实现了三个构造函数，第一个是创建 ArrayList 对象时，传入一个初始化值；第二个是默认创建一个空数组对象；第三个是传入一个集合类型进行初始化。&lt;/p&gt;
&lt;p&gt;当 ArrayList 新增元素时，如果所存储的元素已经超过其已有大小，它会计算元素大小后再进行动态扩容，数组的扩容会导致整个数组进行一次内存复制。因此，我们在初始化 ArrayList 时，可以通过第一个构造函数合理指定数组初始大小，这样有助于减少数组的扩容次数，从而提高系统性能。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public ArrayList(int initialCapacity) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        // 初始化容量不为零时，将根据初始化值创建数组大小
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        if (initialCapacity &amp;gt; 0) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            this.elementData = new Object[initialCapacity];
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        } else if (initialCapacity == 0) {// 初始化容量为零时，使用默认的空数组
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            this.elementData = EMPTY_ELEMENTDATA;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        } else {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            throw new IllegalArgumentException(&amp;#34;Illegal Capacity: &amp;#34;+
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                                               initialCapacity);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    public ArrayList() {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        // 初始化默认为空数组
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;324-arraylist-新增元素&#34;&gt;3.2.4 ArrayList 新增元素
&lt;/h3&gt;&lt;p&gt;ArrayList 新增元素的方法有两种，一种是直接将元素加到数组的末尾，另外一种是添加元素到任意位置。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public boolean add(E e) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        ensureCapacityInternal(size + 1);  // Increments modCount!!
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        elementData[size++] = e;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        return true;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    public void add(int index, E element) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        rangeCheckForAdd(index);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        ensureCapacityInternal(size + 1);  // Increments modCount!!
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        System.arraycopy(elementData, index, elementData, index + 1,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                         size - index);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        elementData[index] = element;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        size++;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;两个方法的相同之处是在添加元素之前，都会先确认容量大小，如果容量够大，就不用进行扩容；如果容量不够大，就会按照原来数组的 1.5 倍大小进行扩容，在扩容之后需要将数组复制到新分配的内存地址。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;private void ensureExplicitCapacity(int minCapacity) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        modCount++;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        // overflow-conscious code
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        if (minCapacity - elementData.length &amp;gt; 0)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            grow(minCapacity);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    private void grow(int minCapacity) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        // overflow-conscious code
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        int oldCapacity = elementData.length;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        int newCapacity = oldCapacity + (oldCapacity &amp;gt;&amp;gt; 1);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        if (newCapacity - minCapacity &amp;lt; 0)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            newCapacity = minCapacity;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        if (newCapacity - MAX_ARRAY_SIZE &amp;gt; 0)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            newCapacity = hugeCapacity(minCapacity);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        // minCapacity is usually close to size, so this is a win:
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        elementData = Arrays.copyOf(elementData, newCapacity);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;当然，两个方法也有不同之处，添加元素到任意位置，会导致在该位置后的所有元素都需要重新排列，而将元素添加到数组的末尾，在没有发生扩容的前提下，是不会有元素复制排序过程的。&lt;/p&gt;
&lt;p&gt;这里你就可以找到第二道测试题的答案了。如果我们在初始化时就比较清楚存储数据的大小，就可以在 ArrayList 初始化时指定数组容量大小，并且在添加元素时，只在数组末尾添加元素，那么 ArrayList 在大量新增元素的场景下，性能并不会变差，反而比其他 List 集合的性能要好。&lt;/p&gt;
&lt;h3 id=&#34;325-arraylist-删除元素&#34;&gt;3.2.5 ArrayList 删除元素
&lt;/h3&gt;&lt;p&gt;ArrayList 的删除方法和添加任意位置元素的方法是有些相同的。ArrayList 在每一次有效的删除元素操作之后，都要进行数组的重组，并且删除的元素位置越靠前，数组重组的开销就越大。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public E remove(int index) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        rangeCheck(index);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        modCount++;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        E oldValue = elementData(index);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        int numMoved = size - index - 1;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        if (numMoved &amp;gt; 0)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            System.arraycopy(elementData, index+1, elementData, index,
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                             numMoved);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        elementData[--size] = null; // clear to let GC do its work
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        return oldValue;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;326-arraylist-遍历元素&#34;&gt;3.2.6 ArrayList 遍历元素
&lt;/h3&gt;&lt;p&gt;由于 ArrayList 是基于数组实现的，所以在获取元素的时候是非常快捷的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public E get(int index) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        rangeCheck(index);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        return elementData(index);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    E elementData(int index) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        return (E) elementData[index];
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;33-linkedlist-是如何实现的&#34;&gt;3.3 LinkedList 是如何实现的？
&lt;/h2&gt;&lt;p&gt;虽然 LinkedList 与 ArrayList 都是 List 类型的集合，但 LinkedList 的实现原理却和 ArrayList 大相径庭，使用场景也不太一样。&lt;/p&gt;
&lt;p&gt;LinkedList 是基于双向链表数据结构实现的，LinkedList 定义了一个 Node 结构，Node 结构中包含了 3 个部分：元素内容 item、前指针 prev 以及后指针 next，代码如下。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; private static class Node&amp;lt;E&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        E item;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        Node&amp;lt;E&amp;gt; next;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        Node&amp;lt;E&amp;gt; prev;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        Node(Node&amp;lt;E&amp;gt; prev, E element, Node&amp;lt;E&amp;gt; next) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            this.item = element;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            this.next = next;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            this.prev = prev;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;总结一下，LinkedList 就是由 Node 结构对象连接而成的一个双向链表。在 JDK1.7 之前，LinkedList 中只包含了一个 Entry 结构的 header 属性，并在初始化的时候默认创建一个空的 Entry，用来做 header，前后指针指向自己，形成一个循环双向链表。&lt;/p&gt;
&lt;p&gt;在 JDK1.7 之后，LinkedList 做了很大的改动，对链表进行了优化。链表的 Entry 结构换成了 Node，内部组成基本没有改变，但 LinkedList 里面的 header 属性去掉了，新增了一个 Node 结构的 first 属性和一个 Node 结构的 last 属性。这样做有以下几点好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;first/last 属性能更清晰地表达链表的链头和链尾概念；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;first/last 方式可以在初始化 LinkedList 的时候节省 new 一个 Entry；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;first/last 方式最重要的性能优化是链头和链尾的插入删除操作更加快捷了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里同 ArrayList 的讲解一样，我将从数据结构、实现原理以及源码分析等几个角度带你深入了解 LinkedList。&lt;/p&gt;
&lt;h3 id=&#34;331-linkedlist-实现类&#34;&gt;3.3.1 LinkedList 实现类
&lt;/h3&gt;&lt;p&gt;LinkedList 类实现了 List 接口、Deque 接口，同时继承了 AbstractSequentialList 抽象类，LinkedList 既实现了 List 类型又有 Queue 类型的特点；LinkedList 也实现了 Cloneable 和 Serializable 接口，同 ArrayList 一样，可以实现克隆和序列化。&lt;/p&gt;
&lt;p&gt;由于 LinkedList 存储数据的内存地址是不连续的，而是通过指针来定位不连续地址，因此，LinkedList 不支持随机快速访问，LinkedList 也就不能实现 RandomAccess 接口。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gdscript3&#34; data-lang=&#34;gdscript3&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;LinkedList&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;AbstractSequentialList&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;implements&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;List&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Deque&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Cloneable&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;java&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;io&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Serializable&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;332-linkedlist-属性&#34;&gt;3.3.2 LinkedList 属性
&lt;/h3&gt;&lt;p&gt;我们前面讲到了 LinkedList 的两个重要属性 first/last 属性，其实还有一个 size 属性。我们可以看到这三个属性都被 transient 修饰了，原因很简单，我们在序列化的时候不会只对头尾进行序列化，所以 LinkedList 也是自行实现 readObject 和 writeObject 进行序列化与反序列化。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;transient int size = 0;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    transient Node&amp;lt;E&amp;gt; first;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    transient Node&amp;lt;E&amp;gt; last;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;333-linkedlist-新增元素&#34;&gt;3.3.3 LinkedList 新增元素
&lt;/h3&gt;&lt;p&gt;LinkedList 添加元素的实现很简洁，但添加的方式却有很多种。默认的 add (Ee) 方法是将添加的元素加到队尾，首先是将 last 元素置换到临时变量中，生成一个新的 Node 节点对象，然后将 last 引用指向新节点对象，之前的 last 对象的前指针指向新节点对象。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; public boolean add(E e) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        linkLast(e);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        return true;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    void linkLast(E e) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        final Node&amp;lt;E&amp;gt; l = last;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        final Node&amp;lt;E&amp;gt; newNode = new Node&amp;lt;&amp;gt;(l, e, null);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        last = newNode;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        if (l == null)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            first = newNode;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        else
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            l.next = newNode;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        size++;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        modCount++;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;LinkedList 也有添加元素到任意位置的方法，如果我们是将元素添加到任意两个元素的中间位置，添加元素操作只会改变前后元素的前后指针，指针将会指向添加的新元素，所以相比 ArrayList 的添加操作来说，LinkedList 的性能优势明显。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public void add(int index, E element) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        checkPositionIndex(index);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        if (index == size)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            linkLast(element);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        else
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            linkBefore(element, node(index));
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    void linkBefore(E e, Node&amp;lt;E&amp;gt; succ) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        // assert succ != null;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        final Node&amp;lt;E&amp;gt; pred = succ.prev;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        final Node&amp;lt;E&amp;gt; newNode = new Node&amp;lt;&amp;gt;(pred, e, succ);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        succ.prev = newNode;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        if (pred == null)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            first = newNode;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        else
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            pred.next = newNode;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        size++;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        modCount++;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;334-linkedlist-删除元素&#34;&gt;3.3.4 LinkedList 删除元素
&lt;/h3&gt;&lt;p&gt;在 LinkedList 删除元素的操作中，我们首先要通过循环找到要删除的元素，如果要删除的位置处于 List 的前半段，就从前往后找；若其位置处于后半段，就从后往前找。&lt;/p&gt;
&lt;p&gt;这样做的话，无论要删除较为靠前或较为靠后的元素都是非常高效的，但如果 List 拥有大量元素，移除的元素又在 List 的中间段，那效率相对来说会很低。&lt;/p&gt;
&lt;h3 id=&#34;335-linkedlist-遍历元素&#34;&gt;3.3.5 LinkedList 遍历元素
&lt;/h3&gt;&lt;p&gt;LinkedList 的获取元素操作实现跟 LinkedList 的删除元素操作基本类似，通过分前后半段来循环查找到对应的元素。但是通过这种方式来查询元素是非常低效的，特别是在 for 循环遍历的情况下，每一次循环都会去遍历半个 List。&lt;/p&gt;
&lt;p&gt;所以在 LinkedList 循环遍历时，我们可以使用 iterator 方式迭代循环，直接拿到我们的元素，而不需要通过循环查找 List。&lt;/p&gt;
&lt;h2 id=&#34;34-stream如何提高遍历集合效率&#34;&gt;3.4 Stream如何提高遍历集合效率？
&lt;/h2&gt;&lt;p&gt;在 Java8 之前，我们通常是通过 for 循环或者 Iterator 迭代来重新排序合并数据，又或者通过重新定义 Collections.sorts 的 Comparator 方法来实现，这两种方式对于大数据量系统来说，效率并不是很理想。&lt;/p&gt;
&lt;p&gt;Java8 中添加了一个新的接口类 Stream，他和我们之前接触的字节流概念不太一样，Java8 集合中的 Stream 相当于高级版的 Iterator，他可以通过 Lambda 表达式对集合进行各种非常便利、高效的聚合操作（Aggregate Operation），或者大批量数据操作 (Bulk Data Operation)。&lt;/p&gt;
&lt;p&gt;这个 Demo 的需求是过滤分组一所中学里身高在 160cm 以上的男女同学，我们先用传统的迭代方式来实现，代码如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Map&amp;lt;String, List&amp;lt;Student&amp;gt;&amp;gt; stuMap = new HashMap&amp;lt;String, List&amp;lt;Student&amp;gt;&amp;gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        for (Student stu: studentsList) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            if (stu.getHeight() &amp;gt; 160) { // 如果身高大于 160
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                if (stuMap.get(stu.getSex()) == null) { // 该性别还没分类
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                    List&amp;lt;Student&amp;gt; list = new ArrayList&amp;lt;Student&amp;gt;(); // 新建该性别学生的列表
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                    list.add(stu);// 将学生放进去列表
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                    stuMap.put(stu.getSex(), list);// 将列表放到 map 中
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                } else { // 该性别分类已存在
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                    stuMap.get(stu.getSex()).add(stu);// 该性别分类已存在，则直接放进去即可
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;我们再使用 Java8 中的 Stream API 进行实现：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;串行实现&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Map&amp;lt;String, List&amp;lt;Student&amp;gt;&amp;gt; stuMap = stuList.stream().filter((Student s) -&amp;gt; s.getHeight() &amp;gt; 160) .collect(Collectors.groupingBy(Student ::getSex)); 
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;并行实现&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Map&amp;lt;String, List&amp;lt;Student&amp;gt;&amp;gt; stuMap = stuList.parallelStream().filter((Student s) -&amp;gt; s.getHeight() &amp;gt; 160) .collect(Collectors.groupingBy(Student ::getSex)); 
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;341-stream-如何优化遍历&#34;&gt;3.4.1 Stream 如何优化遍历？
&lt;/h3&gt;&lt;h4 id=&#34;3411stream-操作分类&#34;&gt;3.4.1.1.Stream 操作分类
&lt;/h4&gt;&lt;p&gt;官方将 Stream 中的操作分为两大类：中间操作（Intermediate operations）和终结操作（Terminal operations）。中间操作只对操作进行了记录，即只会返回一个流，不会进行计算操作，而终结操作是实现了计算操作。&lt;/p&gt;
&lt;p&gt;中间操作又可以分为无状态（Stateless）与有状态（Stateful）操作，前者是指元素的处理不受之前元素的影响，后者是指该操作只有拿到所有元素之后才能继续下去。&lt;/p&gt;
&lt;p&gt;终结操作又可以分为短路（Short-circuiting）与非短路（Unshort-circuiting）操作，前者是指遇到某些符合条件的元素就可以得到最终结果，后者是指必须处理完所有元素才能得到最终结果。操作分类详情如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/10.jpeg&#34;
	width=&#34;2036&#34;
	height=&#34;1438&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/10_hu_f3c63a035c11f49f.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/10_hu_a5960d3d1f841a16.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;141&#34;
		data-flex-basis=&#34;339px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;我们通常还会将中间操作称为懒操作，也正是由这种懒操作结合终结操作、数据源构成的处理管道（Pipeline），实现了 Stream 的高效。&lt;/p&gt;
&lt;h4 id=&#34;3412stream-源码实现&#34;&gt;3.4.1.2.Stream 源码实现
&lt;/h4&gt;&lt;p&gt;在了解 Stream 如何工作之前，我们先来了解下 Stream 包是由哪些主要结构类组合而成的，各个类的职责是什么。参照下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/11.jpeg&#34;
	width=&#34;698&#34;
	height=&#34;428&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/11_hu_ee5d5a75dcd9b153.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/11_hu_cbadabf8a41bbe19.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;163&#34;
		data-flex-basis=&#34;391px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;BaseStream 和 Stream 为最顶端的接口类。BaseStream 主要定义了流的基本接口方法，例如，spliterator、isParallel 等；Stream 则定义了一些流的常用操作方法，例如，map、filter 等。&lt;/p&gt;
&lt;p&gt;ReferencePipeline 是一个结构类，他通过定义内部类组装了各种操作流。他定义了 Head、StatelessOp、StatefulOp 三个内部类，实现了 BaseStream 与 Stream 的接口方法。&lt;/p&gt;
&lt;p&gt;Sink 接口是定义每个 Stream 操作之间关系的协议，他包含 begin()、end()、cancellationRequested()、accpt() 四个方法。ReferencePipeline 最终会将整个 Stream 流操作组装成一个调用链，而这条调用链上的各个 Stream 操作的上下关系就是通过 Sink 接口协议来定义实现的。&lt;/p&gt;
&lt;h4 id=&#34;3413stream-操作叠加&#34;&gt;3.4.1.3.Stream 操作叠加
&lt;/h4&gt;&lt;p&gt;我们知道，一个 Stream 的各个操作是由处理管道组装，并统一完成数据处理的。在 JDK 中每次的中断操作会以使用阶段（Stage）命名。&lt;/p&gt;
&lt;p&gt;管道结构通常是由 ReferencePipeline 类实现的，前面讲解 Stream 包结构时，我提到过 ReferencePipeline 包含了 Head、StatelessOp、StatefulOp 三种内部类。&lt;/p&gt;
&lt;p&gt;Head 类主要用来定义数据源操作，在我们初次调用 names.stream() 方法时，会初次加载 Head 对象，此时为加载数据源操作；接着加载的是中间操作，分别为无状态中间操作&lt;/p&gt;
&lt;p&gt;StatelessOp 对象和有状态操作 StatefulOp 对象，此时的 Stage 并没有执行，而是通过 AbstractPipeline 生成了一个中间操作 Stage 链表；当我们调用终结操作时，会生成一个最终的 Stage，通过这个 Stage 触发之前的中间操作，从最后一个 Stage 开始，递归产生一个 Sink 链。&lt;/p&gt;
&lt;p&gt;下面我们再通过一个例子来感受下 Stream 的操作分类是如何实现高效迭代大数据集合的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;List&amp;lt;String&amp;gt; names = Arrays.asList(&amp;#34; 张三 &amp;#34;, &amp;#34; 李四 &amp;#34;, &amp;#34; 王老五 &amp;#34;, &amp;#34; 李三 &amp;#34;, &amp;#34; 刘老四 &amp;#34;, &amp;#34; 王小二 &amp;#34;, &amp;#34; 张四 &amp;#34;, &amp;#34; 张五六七 &amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;String maxLenStartWithZ = names.stream()
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    	            .filter(name -&amp;gt; name.startsWith(&amp;#34; 张 &amp;#34;))
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    	            .mapToInt(String::length)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    	            .max()
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    	            .toString();
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这个例子的需求是查找出一个长度最长，并且以张为姓氏的名字。从代码角度来看，你可能会认为是这样的操作流程：首先遍历一次集合，得到以“张”开头的所有名字；然后遍历一次 filter 得到的集合，将名字转换成数字长度；最后再从长度集合中找到最长的那个名字并且返回。&lt;/p&gt;
&lt;h4 id=&#34;3414stream-并行处理&#34;&gt;3.4.1.4.Stream 并行处理
&lt;/h4&gt;&lt;p&gt;Stream 处理数据的方式有两种，串行处理和并行处理。要实现并行处理，我们只需要在例子的代码中新增一个 Parallel() 方法，&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;List&amp;lt;String&amp;gt; names = Arrays.asList(&amp;#34; 张三 &amp;#34;, &amp;#34; 李四 &amp;#34;, &amp;#34; 王老五 &amp;#34;, &amp;#34; 李三 &amp;#34;, &amp;#34; 刘老四 &amp;#34;, &amp;#34; 王小二 &amp;#34;, &amp;#34; 张四 &amp;#34;, &amp;#34; 张五六七 &amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;String maxLenStartWithZ = names.stream()
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                    .parallel()
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    	            .filter(name -&amp;gt; name.startsWith(&amp;#34; 张 &amp;#34;))
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    	            .mapToInt(String::length)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    	            .max()
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    	            .toString();
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Stream 的并行处理在执行终结操作之前，跟串行处理的实现是一样的。而在调用终结方法之后，实现的方式就有点不太一样，会调用 TerminalOp 的 evaluateParallel 方法进行并行处理。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;final &amp;lt;R&amp;gt; R evaluate(TerminalOp&amp;lt;E_OUT, R&amp;gt; terminalOp) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        assert getOutputShape() == terminalOp.inputShape();
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        if (linkedOrConsumed)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            throw new IllegalStateException(MSG_STREAM_LINKED);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        linkedOrConsumed = true;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        return isParallel()
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;               ? terminalOp.evaluateParallel(this, sourceSpliterator(terminalOp.getOpFlags()))
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;               : terminalOp.evaluateSequential(this, sourceSpliterator(terminalOp.getOpFlags()));
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这里的并行处理指的是，Stream 结合了 ForkJoin 框架，对 Stream 处理进行了分片，Splititerator 中的 estimateSize 方法会估算出分片的数据量。&lt;/p&gt;
&lt;p&gt;ForkJoin 框架和估算算法，在这里我就不具体讲解了，如果感兴趣，你可以深入源码分析下该算法的实现。&lt;/p&gt;
&lt;p&gt;通过预估的数据量获取最小处理单元的阀值，如果当前分片大小大于最小处理单元的阀值，就继续切分集合。每个分片将会生成一个 Sink 链表，当所有的分片操作完成后，ForkJoin 框架将会合并分片任何结果集。&lt;/p&gt;
&lt;h2 id=&#34;35-深入浅出hashmap的设计与优化&#34;&gt;3.5 深入浅出HashMap的设计与优化
&lt;/h2&gt;&lt;h3 id=&#34;351-常用的数据结构&#34;&gt;3.5.1 常用的数据结构
&lt;/h3&gt;&lt;p&gt;数组：采用一段连续的存储单元来存储数据。对于指定下标的查找，时间复杂度为 O(1)，但在数组中间以及头部插入数据时，需要复制移动后面的元素。&lt;/p&gt;
&lt;p&gt;链表：一种在物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。&lt;/p&gt;
&lt;p&gt;哈希表：根据关键码值（Key value）直接进行访问的数据结构。通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做哈希函数，存放记录的数组就叫做哈希表。&lt;/p&gt;
&lt;p&gt;树：由 n（n≥1）个有限结点组成的一个具有层次关系的集合，就像是一棵倒挂的树。&lt;/p&gt;
&lt;h3 id=&#34;352-hashmap-的实现结构&#34;&gt;3.5.2 HashMap 的实现结构
&lt;/h3&gt;&lt;p&gt;哈希表将键的 Hash 值映射到内存地址，即根据键获取对应的值，并将其存储到内存地址。也就是说 HashMap 是根据键的 Hash 值来决定对应值的存储位置。通过这种索引方式，HashMap 获取数据的速度会非常快。&lt;/p&gt;
&lt;p&gt;例如，存储键值对（x，“aa”）时，哈希表会通过哈希函数 f(x) 得到&amp;quot;aa&amp;quot;的实现存储位置。&lt;/p&gt;
&lt;p&gt;但也会有新的问题。如果再来一个 (y，“bb”)，哈希函数 f(y) 的哈希值跟之前 f(x) 是一样的，这样两个对象的存储地址就冲突了，这种现象就被称为哈希冲突。那么哈希表是怎么解决的呢？方式有很多，比如，开放定址法、再哈希函数法和链地址法。&lt;/p&gt;
&lt;p&gt;开放定址法很简单，当发生哈希冲突时，如果哈希表未被装满，说明在哈希表中必然还有空位置，那么可以把 key 存放到冲突位置的空位置上去。这种方法存在着很多缺点，例如，查找、扩容等，所以我不建议你作为解决哈希冲突的首选。&lt;/p&gt;
&lt;p&gt;再哈希法顾名思义就是在同义词产生地址冲突时再计算另一个哈希函数地址，直到冲突不再发生，这种方法不易产生“聚集”，但却增加了计算时间。如果我们不考虑添加元素的时间成本，且对查询元素的要求极高，就可以考虑使用这种算法设计。&lt;/p&gt;
&lt;p&gt;HashMap 则是综合考虑了所有因素，采用链地址法解决哈希冲突问题。这种方法是采用了数组（哈希表）+ 链表的数据结构，当发生哈希冲突时，就用一个链表结构存储相同 Hash 值的数据。&lt;/p&gt;
&lt;h3 id=&#34;353-hashmap-的重要属性&#34;&gt;3.5.3 HashMap 的重要属性
&lt;/h3&gt;&lt;p&gt;从 HashMap 的源码中，我们可以发现，HashMap 是由一个 Node 数组构成，每个 Node 包含了一个 key-value 键值对。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;transient Node&amp;lt;K,V&amp;gt;[] table;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Node 类作为 HashMap 中的一个内部类，除了 key、value 两个属性外，还定义了一个 next 指针。当有哈希冲突时，HashMap 会用之前数组当中相同哈希值对应存储的 Node 对象，通过指针指向新增的相同哈希值的 Node 对象的引用。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;static class Node&amp;lt;K,V&amp;gt; implements Map.Entry&amp;lt;K,V&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        final int hash;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        final K key;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        V value;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        Node&amp;lt;K,V&amp;gt; next;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        Node(int hash, K key, V value, Node&amp;lt;K,V&amp;gt; next) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            this.hash = hash;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            this.key = key;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            this.value = value;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            this.next = next;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;ashMap 还有两个重要的属性：加载因子（loadFactor）和边界值（threshold）。在初始化 HashMap 时，就会涉及到这两个关键初始化参数。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-gdscript3&#34; data-lang=&#34;gdscript3&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;ne&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;threshold&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;n&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;ne&#34;&gt;float&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;loadFactor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;LoadFactor 属性是用来间接设置 Entry 数组（哈希表）的内存空间大小，在初始 HashMap 不设置参数的情况下，默认 LoadFactor 值为 0.75。为什么是 0.75 这个值呢？&lt;/p&gt;
&lt;p&gt;这是因为对于使用链表法的哈希表来说，查找一个元素的平均时间是 O(1+n)，这里的 n 指的是遍历链表的长度，因此加载因子越大，对空间的利用就越充分，这就意味着链表的长度越长，查找效率也就越低。如果设置的加载因子太小，那么哈希表的数据将过于稀疏，对空间造成严重浪费。&lt;/p&gt;
&lt;p&gt;Entry 数组的 Threshold 是通过初始容量和 LoadFactor 计算所得，在初始 HashMap 不设置参数的情况下，默认边界值为 12。如果我们在初始化时，设置的初始化容量较小，HashMap 中 Node 的数量超过边界值，HashMap 就会调用 resize() 方法重新分配 table 数组。这将会导致 HashMap 的数组复制，迁移到另一块内存中去，从而影响 HashMap 的效率。&lt;/p&gt;
&lt;h3 id=&#34;354-hashmap-添加元素优化&#34;&gt;3.5.4 HashMap 添加元素优化
&lt;/h3&gt;&lt;p&gt;初始化完成后，HashMap 就可以使用 put() 方法添加键值对了。从下面源码可以看出，当程序将一个 key-value 对添加到 HashMap 中，程序首先会根据该 key 的 hashCode() 返回值，再通过 hash() 方法计算出 hash 值，再通过 putVal 方法中的 (n - 1) &amp;amp; hash 决定该 Node 的存储位置。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public V put(K key, V value) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        return putVal(hash(key), key, value, false, true);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;static final int hash(Object key) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        int h;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &amp;gt;&amp;gt;&amp;gt; 16);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;if ((tab = table) == null || (n = tab.length) == 0)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            n = (tab = resize()).length;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        // 通过 putVal 方法中的 (n - 1) &amp;amp; hash 决定该 Node 的存储位置
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        if ((p = tab[i = (n - 1) &amp;amp; hash]) == null)
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            tab[i] = newNode(hash, key, value, null);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果你不太清楚 hash() 以及 (n-1)&amp;amp;hash 的算法，可查看jdk这部分源码。&lt;/p&gt;
&lt;h3 id=&#34;355-hashmap-获取元素优化&#34;&gt;3.5.5 HashMap 获取元素优化
&lt;/h3&gt;&lt;p&gt;当 HashMap 中只存在数组，而数组中没有 Node 链表时，是 HashMap 查询数据性能最好的时候。一旦发生大量的哈希冲突，就会产生 Node 链表，这个时候每次查询元素都可能遍历 Node 链表，从而降低查询数据的性能。&lt;/p&gt;
&lt;p&gt;特别是在链表长度过长的情况下，性能将明显降低，红黑树的使用很好地解决了这个问题，使得查询的平均复杂度降低到了 O(log(n))，链表越长，使用黑红树替换后的查询效率提升就越明显。&lt;/p&gt;
&lt;p&gt;我们在编码中也可以优化 HashMap 的性能，例如，重新 key 值的 hashCode() 方法，降低哈希冲突，从而减少链表的产生，高效利用哈希表，达到提高性能的效果。&lt;/p&gt;
&lt;h3 id=&#34;356-hashmap-扩容优化&#34;&gt;3.5.6 HashMap 扩容优化
&lt;/h3&gt;&lt;p&gt;在 JDK1.7 中，HashMap 整个扩容过程就是分别取出数组元素，一般该元素是最后一个放入链表中的元素，然后遍历以该元素为头的单向链表元素，依据每个被遍历元素的 hash 值计算其在新数组中的下标，然后进行交换。这样的扩容方式会将原来哈希冲突的单向链表尾部变成扩容后单向链表的头部。&lt;/p&gt;
&lt;p&gt;而在 JDK 1.8 中，HashMap 对扩容操作做了优化。由于扩容数组的长度是 2 倍关系，所以对于假设初始 tableSize = 4 要扩容到 8 来说就是 0100 到 1000 的变化（左移一位就是 2 倍），在扩容中只用判断原来的 hash 值和左移动的一位（newtable 的值）按位与操作是 0 或 1 就行，0 的话索引不变，1 的话索引变成原索引加上扩容前数组。&lt;/p&gt;
&lt;h2 id=&#34;36-网络通信优化之i-o模型&#34;&gt;3.6 网络通信优化之I-O模型
&lt;/h2&gt;&lt;p&gt;提到 Java I/O，相信你一定不陌生。你可能使用 I/O 操作读写文件，也可能使用它实现 Socket 的信息传输…这些都是我们在系统中最常遇到的和 I/O 有关的操作。&lt;/p&gt;
&lt;p&gt;我们都知道，I/O 的速度要比内存速度慢，尤其是在现在这个大数据时代背景下，I/O 的性能问题更是尤为突出，I/O 读写已经成为很多应用场景下的系统性能瓶颈，不容我们忽视。&lt;/p&gt;
&lt;h3 id=&#34;361-什么是-io&#34;&gt;3.6.1 什么是 I/O
&lt;/h3&gt;&lt;p&gt;I/O 是机器获取和交换信息的主要渠道，而流是完成 I/O 操作的主要方式。&lt;/p&gt;
&lt;p&gt;在计算机中，流是一种信息的转换。流是有序的，因此相对于某一机器或者应用程序而言，我们通常把机器或者应用程序接收外界的信息称为输入流（InputStream），从机器或者应用程序向外输出的信息称为输出流（OutputStream），合称为输入 / 输出流（I/O Streams）。&lt;/p&gt;
&lt;p&gt;机器间或程序间在进行信息交换或者数据交换时，总是先将对象或数据转换为某种形式的流，再通过流的传输，到达指定机器或程序后，再将流转换为对象数据。因此，流就可以被看作是一种数据的载体，通过它可以实现数据交换和传输。&lt;/p&gt;
&lt;p&gt;Java 的 I/O 操作类在包 java.io 下，其中 InputStream、OutputStream 以及 Reader、Writer 类是 I/O 包中的 4 个基本类，它们分别处理字节流和字符流。&lt;/p&gt;
&lt;h4 id=&#34;3611-字节流&#34;&gt;3.6.1.1 字节流
&lt;/h4&gt;&lt;p&gt;InputStream/OutputStream 是字节流的抽象类，这两个抽象类又派生出了若干子类，不同的子类分别处理不同的操作类型。如果是文件的读写操作，就使用 FileInputStream/FileOutputStream；如果是数组的读写操作，就使用 ByteArrayInputStream/ByteArrayOutputStream；如果是普通字符串的读写操作，就使用 BufferedInputStream/BufferedOutputStream。具体内容如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/12.jpeg&#34;
	width=&#34;1474&#34;
	height=&#34;1086&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/12_hu_9ee0518349907581.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/12_hu_91d026d39e2435b7.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;135&#34;
		data-flex-basis=&#34;325px&#34;
	
&gt;&lt;/p&gt;
&lt;h4 id=&#34;3612-字符流&#34;&gt;3.6.1.2 字符流
&lt;/h4&gt;&lt;p&gt;Reader/Writer 是字符流的抽象类，这两个抽象类也派生出了若干子类，不同的子类分别处理不同的操作类型，具体内容如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/13.jpeg&#34;
	width=&#34;1126&#34;
	height=&#34;742&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/13_hu_12bd70ffbec69ce1.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/13_hu_a334e7e637999ad6.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;151&#34;
		data-flex-basis=&#34;364px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;362-传统-io-的性能问题&#34;&gt;3.6.2 传统 I/O 的性能问题
&lt;/h3&gt;&lt;p&gt;我们知道，I/O 操作分为磁盘 I/O 操作和网络 I/O 操作。前者是从磁盘中读取数据源输入到内存中，之后将读取的信息持久化输出在物理磁盘上；后者是从网络中读取信息输入到内存，最终将信息输出到网络中。但不管是磁盘 I/O 还是网络 I/O，在传统 I/O 中都存在严重的性能问题。&lt;/p&gt;
&lt;h4 id=&#34;3621--多次内存复制&#34;&gt;3.6.2.1  多次内存复制
&lt;/h4&gt;&lt;p&gt;在传统 I/O 中，我们可以通过 InputStream 从源数据中读取数据流输入到缓冲区里，通过 OutputStream 将数据输出到外部设备（包括磁盘、网络）。你可以先看下输入操作在操作系统中的具体流程，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/14.jpeg&#34;
	width=&#34;676&#34;
	height=&#34;295&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/14_hu_e98a3a34dc6af7db.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/14_hu_69c09bdc93abea29.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;229&#34;
		data-flex-basis=&#34;549px&#34;
	
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JVM 会发出 read() 系统调用，并通过 read 系统调用向内核发起读请求；&lt;/li&gt;
&lt;li&gt;内核向硬件发送读指令，并等待读就绪；&lt;/li&gt;
&lt;li&gt;内核把将要读取的数据复制到指向的内核缓存中；&lt;/li&gt;
&lt;li&gt;操作系统内核将数据复制到用户空间缓冲区，然后 read 系统调用返回。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;3622--阻塞&#34;&gt;3.6.2.2  阻塞
&lt;/h4&gt;&lt;p&gt;在传统 I/O 中，InputStream 的 read() 是一个 while 循环操作，它会一直等待数据读取，直到数据就绪才会返回。这就意味着如果没有数据就绪，这个读取操作将会一直被挂起，用户线程将会处于阻塞状态。&lt;/p&gt;
&lt;p&gt;在少量连接请求的情况下，使用这种方式没有问题，响应速度也很高。但在发生大量连接请求时，就需要创建大量监听线程，这时如果线程没有数据就绪就会被挂起，然后进入阻塞状态。一旦发生线程阻塞，这些线程将会不断地抢夺 CPU 资源，从而导致大量的 CPU 上下文切换，增加系统的性能开销。&lt;/p&gt;
&lt;h3 id=&#34;363-如何优化-io-操作&#34;&gt;3.6.3 如何优化 I/O 操作
&lt;/h3&gt;&lt;h4 id=&#34;3631--使用缓冲区优化读写流操作&#34;&gt;3.6.3.1  使用缓冲区优化读写流操作
&lt;/h4&gt;&lt;p&gt;在传统 I/O 中，提供了基于流的 I/O 实现，即 InputStream 和 OutputStream，这种基于流的实现以字节为单位处理数据。&lt;/p&gt;
&lt;p&gt;NIO 与传统 I/O 不同，它是基于块（Block）的，它以块为基本单位处理数据。在 NIO 中，最为重要的两个组件是缓冲区（Buffer）和通道（Channel）。Buffer 是一块连续的内存块，是 NIO 读写数据的中转地。Channel 表示缓冲数据的源头或者目的地，它用于读取缓冲或者写入数据，是访问缓冲的接口。&lt;/p&gt;
&lt;p&gt;传统 I/O 和 NIO 的最大区别就是传统 I/O 是面向流，NIO 是面向 Buffer。Buffer 可以将文件一次性读入内存再做后续处理，而传统的方式是边读文件边处理数据。虽然传统 I/O 后面也使用了缓冲块，例如 BufferedInputStream，但仍然不能和 NIO 相媲美。使用 NIO 替代传统 I/O 操作，可以提升系统的整体性能，效果立竿见影。&lt;/p&gt;
&lt;h4 id=&#34;3632--使用-directbuffer-减少内存复制&#34;&gt;3.6.3.2  使用 DirectBuffer 减少内存复制
&lt;/h4&gt;&lt;p&gt;NIO 的 Buffer 除了做了缓冲块优化之外，还提供了一个可以直接访问物理内存的类 DirectBuffer。普通的 Buffer 分配的是 JVM 堆内存，而 DirectBuffer 是直接分配物理内存。&lt;/p&gt;
&lt;p&gt;我们知道数据要输出到外部设备，必须先从用户空间复制到内核空间，再复制到输出设备，而 DirectBuffer 则是直接将步骤简化为从内核空间复制到外部设备，减少了数据拷贝。&lt;/p&gt;
&lt;p&gt;这里拓展一点，由于 DirectBuffer 申请的是非 JVM 的物理内存，所以创建和销毁的代价很高。DirectBuffer 申请的内存并不是直接由 JVM 负责垃圾回收，但在 DirectBuffer 包装类被回收时，会通过 Java Reference 机制来释放该内存块。&lt;/p&gt;
&lt;h4 id=&#34;3632-避免阻塞优化-io-操作&#34;&gt;3.6.3.2 避免阻塞，优化 I/O 操作
&lt;/h4&gt;&lt;p&gt;NIO 很多人也称之为 Non-block I/O，即非阻塞 I/O，因为这样叫，更能体现它的特点。为什么这么说呢？&lt;/p&gt;
&lt;p&gt;传统的 I/O 即使使用了缓冲块，依然存在阻塞问题。由于线程池线程数量有限，一旦发生大量并发请求，超过最大数量的线程就只能等待，直到线程池中有空闲的线程可以被复用。而对 Socket 的输入流进行读取时，读取流会一直阻塞，直到发生以下三种情况的任意一种才会解除阻塞：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有数据可读；&lt;/li&gt;
&lt;li&gt;连接释放；&lt;/li&gt;
&lt;li&gt;空指针或 I/O 异常。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;阻塞问题，就是传统 I/O 最大的弊端。NIO 发布后，通道和多路复用器这两个基本组件实现了 NIO 的非阻塞，下面我们就一起来了解下这两个组件的优化原理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;通道（Channel）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;前面我们讨论过，传统 I/O 的数据读取和写入是从用户空间到内核空间来回复制，而内核空间的数据是通过操作系统层面的 I/O 接口从磁盘读取或写入。&lt;/p&gt;
&lt;p&gt;最开始，在应用程序调用操作系统 I/O 接口时，是由 CPU 完成分配，这种方式最大的问题是“发生大量 I/O 请求时，非常消耗 CPU“；之后，操作系统引入了 DMA（直接存储器存储），内核空间与磁盘之间的存取完全由 DMA 负责，但这种方式依然需要向 CPU 申请权限，且需要借助 DMA 总线来完成数据的复制操作，如果 DMA 总线过多，就会造成总线冲突。&lt;/p&gt;
&lt;p&gt;通道的出现解决了以上问题，Channel 有自己的处理器，可以完成内核空间和磁盘之间的 I/O 操作。在 NIO 中，我们读取和写入数据都要通过 Channel，由于 Channel 是双向的，所以读、写可以同时进行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多路复用器（Selector）&lt;/strong&gt;
Selector 是 Java NIO 编程的基础。用于检查一个或多个 NIO Channel 的状态是否处于可读、可写。&lt;/p&gt;
&lt;p&gt;Selector 是基于事件驱动实现的，我们可以在 Selector 中注册 accpet、read 监听事件，Selector 会不断轮询注册在其上的 Channel，如果某个 Channel 上面发生监听事件，这个 Channel 就处于就绪状态，然后进行 I/O 操作。&lt;/p&gt;
&lt;p&gt;一个线程使用一个 Selector，通过轮询的方式，可以监听多个 Channel 上的事件。我们可以在注册 Channel 时设置该通道为非阻塞，当 Channel 上没有 I/O 操作时，该线程就不会一直等待了，而是会不断轮询所有 Channel，从而避免发生阻塞。&lt;/p&gt;
&lt;p&gt;目前操作系统的 I/O 多路复用机制都使用了 epoll，相比传统的 select 机制，epoll 没有最大连接句柄 1024 的限制。所以 Selector 在理论上可以轮询成千上万的客户端。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;下面我用一个生活化的场景来举例，看完你就更清楚 Channel 和 Selector 在非阻塞 I/O 中承担什么角色，发挥什么作用了。&lt;/p&gt;
&lt;p&gt;我们可以把监听多个 I/O 连接请求比作一个火车站的进站口。以前检票只能让搭乘就近一趟发车的旅客提前进站，而且只有一个检票员，这时如果有其他车次的旅客要进站，就只能在站口排队。这就相当于最早没有实现线程池的 I/O 操作。&lt;/p&gt;
&lt;p&gt;后来火车站升级了，多了几个检票入口，允许不同车次的旅客从各自对应的检票入口进站。这就相当于用多线程创建了多个监听线程，同时监听各个客户端的 I/O 请求。&lt;/p&gt;
&lt;p&gt;最后火车站进行了升级改造，可以容纳更多旅客了，每个车次载客更多了，而且车次也安排合理，乘客不再扎堆排队，可以从一个大的统一的检票口进站了，这一个检票口可以同时检票多个车次。这个大的检票口就相当于 Selector，车次就相当于 Channel，旅客就相当于 I/O 流。下面我用一个生活化的场景来举例，看完你就更清楚 Channel 和 Selector 在非阻塞 I/O 中承担什么角色，发挥什么作用了。&lt;/p&gt;
&lt;p&gt;我们可以把监听多个 I/O 连接请求比作一个火车站的进站口。以前检票只能让搭乘就近一趟发车的旅客提前进站，而且只有一个检票员，这时如果有其他车次的旅客要进站，就只能在站口排队。这就相当于最早没有实现线程池的 I/O 操作。&lt;/p&gt;
&lt;p&gt;后来火车站升级了，多了几个检票入口，允许不同车次的旅客从各自对应的检票入口进站。这就相当于用多线程创建了多个监听线程，同时监听各个客户端的 I/O 请求。&lt;/p&gt;
&lt;p&gt;最后火车站进行了升级改造，可以容纳更多旅客了，每个车次载客更多了，而且车次也安排合理，乘客不再扎堆排队，可以从一个大的统一的检票口进站了，这一个检票口可以同时检票多个车次。这个大的检票口就相当于 Selector，车次就相当于 Channel，旅客就相当于 I/O 流。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;37-网络通信优化之序列化&#34;&gt;3.7 网络通信优化之序列化
&lt;/h2&gt;&lt;p&gt;当前大部分后端服务都是基于微服务架构实现的。服务按照业务划分被拆分，实现了服务的解偶，但同时也带来了新的问题，不同业务之间通信需要通过接口实现调用。两个服务之间要共享一个数据对象，就需要从对象转换成二进制流，通过网络传输，传送到对方服务，再转换回对象，供服务方法调用。这个编码和解码过程我们称之为序列化与反序列化。&lt;/p&gt;
&lt;p&gt;在大量并发请求的情况下，如果序列化的速度慢，会导致请求响应时间增加；而序列化后的传输数据体积大，会导致网络吞吐量下降。所以一个优秀的序列化框架可以提高系统的整体性能。&lt;/p&gt;
&lt;p&gt;我们知道，Java 提供了 RMI 框架可以实现服务与服务之间的接口暴露和调用，RMI 中对数据对象的序列化采用的是 Java 序列化。而目前主流的微服务框架却几乎没有用到 Java 序列化，SpringCloud 用的是 Json 序列化，Dubbo 虽然兼容了 Java 序列化，但默认使用的是 Hessian 序列化。这是为什么呢？&lt;/p&gt;
&lt;p&gt;今天我们就来深入了解下 Java 序列化，再对比近两年比较火的 Protobuf 序列化，看看 Protobuf 是如何实现最优序列化的。&lt;/p&gt;
&lt;h3 id=&#34;371-java-序列化&#34;&gt;3.7.1 Java 序列化
&lt;/h3&gt;&lt;p&gt;Java 提供了一种序列化机制，这种机制能够将一个对象序列化为二进制形式（字节数组），用于写入磁盘或输出到网络，同时也能从网络或磁盘中读取字节数组，反序列化成对象，在程序中使用。&lt;/p&gt;
&lt;p&gt;JDK 提供的两个输入、输出流对象 ObjectInputStream 和 ObjectOutputStream，它们只能对实现了 Serializable 接口的类的对象进行反序列化和序列化。&lt;/p&gt;
&lt;p&gt;ObjectOutputStream 的默认序列化方式，仅对对象的非 transient 的实例变量进行序列化，而不会序列化对象的 transient 的实例变量，也不会序列化静态变量。&lt;/p&gt;
&lt;p&gt;在实现了 Serializable 接口的类的对象中，会生成一个 serialVersionUID 的版本号，这个版本号有什么用呢？它会在反序列化过程中来验证序列化对象是否加载了反序列化的类，如果是具有相同类名的不同版本号的类，在反序列化中是无法获取对象的。&lt;/p&gt;
&lt;p&gt;具体实现序列化的是 writeObject 和 readObject，通常这两个方法是默认的，当然我们也可以在实现 Serializable 接口的类中对其进行重写，定制一套属于自己的序列化与反序列化机制。&lt;/p&gt;
&lt;p&gt;另外，Java 序列化的类中还定义了两个重写方法：writeReplace() 和 readResolve()，前者是用来在序列化之前替换序列化对象的，后者是用来在反序列化之后对返回对象进行处理的。&lt;/p&gt;
&lt;h3 id=&#34;372-java-序列化的缺陷&#34;&gt;3.7.2 Java 序列化的缺陷
&lt;/h3&gt;&lt;p&gt;如果你用过一些 RPC 通信框架，你就会发现这些框架很少使用 JDK 提供的序列化。其实不用和不好用多半是挂钩的，下面我们就一起来看看 JDK 默认的序列化到底存在着哪些缺陷。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;无法跨语言&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;现在的系统设计越来越多元化，很多系统都使用了多种语言来编写应用程序。比如某公司开发的一些大型游戏就使用了多种语言，C++ 写游戏服务，Java/Go 写周边服务，Python 写一些监控应用。&lt;/p&gt;
&lt;p&gt;而 Java 序列化目前只适用基于 Java 语言实现的框架，其它语言大部分都没有使用 Java 的序列化框架，也没有实现 Java 序列化这套协议。因此，如果是两个基于不同语言编写的应用程序相互通信，则无法实现两个应用服务之间传输对象的序列化与反序列化。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;易被攻击&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Java 官网安全编码指导方针中说明：“对不信任数据的反序列化，从本质上来说是危险的，应该予以避免”。可见 Java 序列化是不安全的。&lt;/p&gt;
&lt;p&gt;我们知道对象是通过在 ObjectInputStream 上调用 readObject() 方法进行反序列化的，这个方法其实是一个神奇的构造器，它可以将类路径上几乎所有实现了 Serializable 接口的对象都实例化。&lt;/p&gt;
&lt;p&gt;这也就意味着，在反序列化字节流的过程中，该方法可以执行任意类型的代码，这是非常危险的。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;序列化后的流太大&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;序列化后的二进制流大小能体现序列化的性能。序列化后的二进制数组越大，占用的存储空间就越多，存储硬件的成本就越高。如果我们是进行网络传输，则占用的带宽就更多，这时就会影响到系统的吞吐量。&lt;/p&gt;
&lt;p&gt;Java 序列化中使用了 ObjectOutputStream 来实现对象转二进制编码，那么这种序列化机制实现的二进制编码完成的二进制数组大小，相比于 NIO 中的 ByteBuffer 实现的二进制编码完成的数组大小，有没有区别呢？&lt;/p&gt;
&lt;p&gt;我们可以通过一个简单的例子来验证下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;User user = new User();
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    	user.setUserName(&amp;#34;test&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    	user.setPassword(&amp;#34;test&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    	ByteArrayOutputStream os =new ByteArrayOutputStream();
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    	ObjectOutputStream out = new ObjectOutputStream(os);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    	out.writeObject(user);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    	
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    	byte[] testByte = os.toByteArray();
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    	System.out.print(&amp;#34;ObjectOutputStream 字节编码长度：&amp;#34; + testByte.length + &amp;#34;\n&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ByteBuffer byteBuffer = ByteBuffer.allocate( 2048);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        byte[] userName = user.getUserName().getBytes();
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        byte[] password = user.getPassword().getBytes();
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        byteBuffer.putInt(userName.length);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        byteBuffer.put(userName);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        byteBuffer.putInt(password.length);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        byteBuffer.put(password);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        byteBuffer.flip();
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        byte[] bytes = new byte[byteBuffer.remaining()];
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    	System.out.print(&amp;#34;ByteBuffer 字节编码长度：&amp;#34; + bytes.length+ &amp;#34;\n&amp;#34;);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; 
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;运行结果：
ObjectOutputStream 字节编码长度：99
ByteBuffer 字节编码长度：16&lt;/p&gt;
&lt;p&gt;这里我们可以清楚地看到：Java 序列化实现的二进制编码完成的二进制数组大小，比 ByteBuffer 实现的二进制编码完成的二进制数组大小要大上几倍。&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;序列化性能太差&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;序列化的速度也是体现序列化性能的重要指标，如果序列化的速度慢，就会影响网络通信的效率，从而增加系统的响应时间。&lt;/p&gt;
&lt;h3 id=&#34;373-使用-protobuf-序列化替换-java-序列化&#34;&gt;3.7.3 使用 Protobuf 序列化替换 Java 序列化
&lt;/h3&gt;&lt;p&gt;目前业内优秀的序列化框架有很多，而且大部分都避免了 Java 默认序列化的一些缺陷。例如，最近几年比较流行的 FastJson、Kryo、Protobuf、Hessian 等。我们完全可以找一种替换掉 Java 序列化，这里我推荐使用 Protobuf 序列化框架。&lt;/p&gt;
&lt;p&gt;Protobuf 是由 Google 推出且支持多语言的序列化框架，目前在主流网站上的序列化框架性能对比测试报告中，Protobuf 无论是编解码耗时，还是二进制流压缩大小，都名列前茅。&lt;/p&gt;
&lt;p&gt;Protobuf 以一个 .proto 后缀的文件为基础，这个文件描述了字段以及字段类型，通过工具可以生成不同语言的数据结构文件。在序列化该数据对象的时候，Protobuf 通过.proto 文件描述来生成 Protocol Buffers 格式的编码。&lt;/p&gt;
&lt;p&gt;这里拓展一点，我来讲下什么是 Protocol Buffers 存储格式以及它的实现原理。&lt;/p&gt;
&lt;p&gt;Protocol Buffers 是一种轻便高效的结构化数据存储格式。它使用 T-L-V（标识 - 长度 - 字段值）的数据格式来存储数据，T 代表字段的正数序列 (tag)，Protocol Buffers 将对象中的每个字段和正数序列对应起来，对应关系的信息是由生成的代码来保证的。在序列化的时候用整数值来代替字段名称，于是传输流量就可以大幅缩减；L 代表 Value 的字节长度，一般也只占一个字节；V 则代表字段值经过编码后的值。这种数据格式不需要分隔符，也不需要空格，同时减少了冗余字段名。&lt;/p&gt;
&lt;p&gt;Protobuf 定义了一套自己的编码方式，几乎可以映射 Java/Python 等语言的所有基础数据类型。不同的编码方式对应不同的数据类型，还能采用不同的存储格式。
如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/15.jpeg&#34;
	width=&#34;1638&#34;
	height=&#34;466&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/15_hu_82388223301a592b.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/15_hu_dae53338b35cb40d.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;351&#34;
		data-flex-basis=&#34;843px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;对于存储 Varint 编码数据，由于数据占用的存储空间是固定的，就不需要存储字节长度 Length，所以实际上 Protocol Buffers 的存储方式是 T - V，这样就又减少了一个字节的存储空间。&lt;/p&gt;
&lt;p&gt;Protobuf 定义的 Varint 编码方式是一种变长的编码方式，每个数据类型一个字节的最后一位是一个标志位 (msb)，用 0 和 1 来表示，0 表示当前字节已经是最后一个字节，1 表示这个数字后面还有一个字节。&lt;/p&gt;
&lt;p&gt;对于 int32 类型数字，一般需要 4 个字节表示，若采用 Varint 编码方式，对于很小的 int32 类型数字，就可以用 1 个字节来表示。对于大部分整数类型数据来说，一般都是小于 256，所以这种操作可以起到很好地压缩数据的效果。&lt;/p&gt;
&lt;p&gt;我们知道 int32 代表正负数，所以一般最后一位是用来表示正负值，现在 Varint 编码方式将最后一位用作了标志位，那还如何去表示正负整数呢？如果使用 int32/int64 表示负数就需要多个字节来表示，在 Varint 编码类型中，通过 Zigzag 编码进行转换，将负数转换成无符号数，再采用 sint32/sint64 来表示负数，这样就可以大大地减少编码后的字节数。&lt;/p&gt;
&lt;p&gt;Protobuf 的这种数据存储格式，不仅压缩存储数据的效果好， 在编码和解码的性能方面也很高效。Protobuf 的编码和解码过程结合.proto 文件格式，加上 Protocol Buffer 独特的编码格式，只需要简单的数据运算以及位移等操作就可以完成编码与解码。可以说 Protobuf 的整体性能非常优秀。&lt;/p&gt;
&lt;h2 id=&#34;38-网络通信优化之通信协议&#34;&gt;3.8 网络通信优化之通信协议
&lt;/h2&gt;&lt;h3 id=&#34;381-rpc-通信是大型服务框架的核心&#34;&gt;3.8.1 RPC 通信是大型服务框架的核心
&lt;/h3&gt;&lt;p&gt;我们经常讨论微服务，首要应该了解的就是微服务的核心到底是什么，这样我们在做技术选型时，才能更准确地把握需求。&lt;/p&gt;
&lt;p&gt;就我个人理解，我认为微服务的核心是远程通信和服务治理。远程通信提供了服务之间通信的桥梁，服务治理则提供了服务的后勤保障。所以，我们在做技术选型时，更多要考虑的是这两个核心的需求。&lt;/p&gt;
&lt;p&gt;我们知道服务的拆分增加了通信的成本，特别是在一些抢购或者促销的业务场景中，如果服务之间存在方法调用，比如，抢购成功之后需要调用订单系统、支付系统、券包系统等，这种远程通信就很容易成为系统的瓶颈。所以，在满足一定的服务治理需求的前提下，对远程通信的性能需求就是技术选型的主要影响因素。&lt;/p&gt;
&lt;p&gt;目前，很多微服务框架中的服务通信是基于 RPC 通信实现的，在没有进行组件扩展的前提下，SpringCloud 是基于 Feign 组件实现的 RPC 通信（基于 Http+Json 序列化实现），Dubbo 是基于 SPI 扩展了很多 RPC 通信框架，包括 RMI、Dubbo、Hessian 等 RPC 通信框架（默认是 Dubbo+Hessian 序列化）。不同的业务场景下，RPC 通信的选择和优化标准也不同。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;无论从响应时间还是吞吐量上来看，单一 TCP 长连接 +Protobuf 序列化实现的 RPC 通信框架都有着非常明显的优势。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;382-什么是-rpc-通信&#34;&gt;3.8.2 什么是 RPC 通信
&lt;/h3&gt;&lt;p&gt;无论是微服务、SOA、还是 RPC 架构，它们都是分布式服务架构，都需要实现服务之间的互相通信，我们通常把这种通信统称为 RPC 通信。&lt;/p&gt;
&lt;p&gt;RPC（Remote Process Call），即远程服务调用，是通过网络请求远程计算机程序服务的通信技术。RPC 框架封装好了底层网络通信、序列化等技术，我们只需要在项目中引入各个服务的接口包，就可以实现在代码中调用 RPC 服务同调用本地方法一样。正因为这种方便、透明的远程调用，RPC 被广泛应用于当下企业级以及互联网项目中，是实现分布式系统的核心。&lt;/p&gt;
&lt;p&gt;RMI（Remote Method Invocation）是 JDK 中最先实现了 RPC 通信的框架之一，RMI 的实现对建立分布式 Java 应用程序至关重要，是 Java 体系非常重要的底层技术，很多开源的 RPC 通信框架也是基于 RMI 实现原理设计出来的，包括 Dubbo 框架中也接入了 RMI 框架。接下来我们就一起了解下 RMI 的实现原理，看看它存在哪些性能瓶颈有待优化。&lt;/p&gt;
&lt;h3 id=&#34;383-一个高并发场景下的-rpc-通信优化路径&#34;&gt;3.8.3 一个高并发场景下的 RPC 通信优化路径
&lt;/h3&gt;&lt;p&gt;pringCloud 的 RPC 通信和 RMI 通信的性能瓶颈就非常相似。SpringCloud 是基于 Http 通信协议（短连接）和 Json 序列化实现的，在高并发场景下并没有优势。 那么，在瞬时高并发的场景下，我们又该如何去优化一个 RPC 通信呢？&lt;/p&gt;
&lt;p&gt;RPC 通信包括了建立通信、实现报文、传输协议以及传输数据编解码等操作，接下来我们就从每一层的优化出发，逐步实现整体的性能优化。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;选择合适的通信协议&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;要实现不同机器间的网络通信，我们先要了解计算机系统网络通信的基本原理。网络通信是两台设备之间实现数据流交换的过程，是基于网络传输协议和传输数据的编解码来实现的。其中网络传输协议有 TCP、UDP 协议，这两个协议都是基于 Socket 编程接口之上，为某类应用场景而扩展出的传输协议。通过以下的图，我们可以大概了解到基于 TCP 和 UDP 协议实现的 Socket 网络通信是怎样的一个流程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/16.jpeg&#34;
	width=&#34;1924&#34;
	height=&#34;1394&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/16_hu_a3361c3eb86ae298.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/16_hu_c7e517bd818b0e1b.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;138&#34;
		data-flex-basis=&#34;331px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;基于 TCP 协议实现的 Socket 通信是有连接的，而传输数据是要通过三次握手来实现数据传输的可靠性，且传输数据是没有边界的，采用的是字节流模式。&lt;/p&gt;
&lt;p&gt;基于 UDP 协议实现的 Socket 通信，客户端不需要建立连接，只需要创建一个套接字发送数据报给服务端，这样就不能保证数据报一定会达到服务端，所以在传输数据方面，基于 UDP 协议实现的 Socket 通信具有不可靠性。UDP 发送的数据采用的是数据报模式，每个 UDP 的数据报都有一个长度，该长度将与数据一起发送到服务端。&lt;/p&gt;
&lt;p&gt;通过对比，我们可以得出优化方法：为了保证数据传输的可靠性，通常情况下我们会采用 TCP 协议。如果在局域网且对数据传输的可靠性没有要求的情况下，我们也可以考虑使用 UDP 协议，毕竟这种协议的效率要比 TCP 协议高。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;使用单一长连接&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果是基于 TCP 协议实现 Socket 通信，我们还能做哪些优化呢？&lt;/p&gt;
&lt;p&gt;服务之间的通信不同于客户端与服务端之间的通信。客户端与服务端由于客户端数量多，基于短连接实现请求可以避免长时间地占用连接，导致系统资源浪费。&lt;/p&gt;
&lt;p&gt;但服务之间的通信，连接的消费端不会像客户端那么多，但消费端向服务端请求的数量却一样多，我们基于长连接实现，就可以省去大量的 TCP 建立和关闭连接的操作，从而减少系统的性能消耗，节省时间。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;优化 Socket 通信&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;建立两台机器的网络通信，我们一般使用 Java 的 Socket 编程实现一个 TCP 连接。传统的 Socket 通信主要存在 I/O 阻塞、线程模型缺陷以及内存拷贝等问题。我们可以使用比较成熟的通信框架，比如 Netty。Netty4 对 Socket 通信编程做了很多方面的优化，具体见下方。&lt;/p&gt;
&lt;p&gt;实现非阻塞 I/O：在 08 讲中，我们提到了多路复用器 Selector 实现了非阻塞 I/O 通信。&lt;/p&gt;
&lt;p&gt;高效的 Reactor 线程模型：Netty 使用了主从 Reactor 多线程模型，服务端接收客户端请求连接是用了一个主线程，这个主线程用于客户端的连接请求操作，一旦连接建立成功，将会监听 I/O 事件，监听到事件后会创建一个链路请求。&lt;/p&gt;
&lt;p&gt;链路请求将会注册到负责 I/O 操作的 I/O 工作线程上，由 I/O 工作线程负责后续的 I/O 操作。利用这种线程模型，可以解决在高负载、高并发的情况下，由于单个 NIO 线程无法监听海量客户端和满足大量 I/O 操作造成的问题。&lt;/p&gt;
&lt;p&gt;串行设计：服务端在接收消息之后，存在着编码、解码、读取和发送等链路操作。如果这些操作都是基于并行去实现，无疑会导致严重的锁竞争，进而导致系统的性能下降。为了提升性能，Netty 采用了串行无锁化完成链路操作，Netty 提供了 Pipeline 实现链路的各个操作在运行期间不进行线程切换。&lt;/p&gt;
&lt;p&gt;零拷贝：在 08 讲中，我们提到了一个数据从内存发送到网络中，存在着两次拷贝动作，先是从用户空间拷贝到内核空间，再是从内核空间拷贝到网络 I/O 中。而 NIO 提供的 ByteBuffer 可以使用 Direct Buffers 模式，直接开辟一个非堆物理内存，不需要进行字节缓冲区的二次拷贝，可以直接将数据写入到内核空间。&lt;/p&gt;
&lt;p&gt;除了以上这些优化，我们还可以针对套接字编程提供的一些 TCP 参数配置项，提高网络吞吐量，Netty 可以基于 ChannelOption 来设置这些参数。&lt;/p&gt;
&lt;p&gt;TCP_NODELAY：TCP_NODELAY 选项是用来控制是否开启 Nagle 算法。Nagle 算法通过缓存的方式将小的数据包组成一个大的数据包，从而避免大量的小数据包发送阻塞网络，提高网络传输的效率。我们可以关闭该算法，优化对于时延敏感的应用场景。&lt;/p&gt;
&lt;p&gt;SO_RCVBUF 和 SO_SNDBUF：可以根据场景调整套接字发送缓冲区和接收缓冲区的大小。&lt;/p&gt;
&lt;p&gt;SO_BACKLOG：backlog 参数指定了客户端连接请求缓冲队列的大小。服务端处理客户端连接请求是按顺序处理的，所以同一时间只能处理一个客户端连接，当有多个客户端进来的时候，服务端就会将不能处理的客户端连接请求放在队列中等待处理。&lt;/p&gt;
&lt;p&gt;SO_KEEPALIVE：当设置该选项以后，连接会检查长时间没有发送数据的客户端的连接状态，检测到客户端断开连接后，服务端将回收该连接。我们可以将该时间设置得短一些，来提高回收连接的效率。&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;量身定做报文格式&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接下来就是实现报文，我们需要设计一套报文，用于描述具体的校验、操作、传输数据等内容。为了提高传输的效率，我们可以根据自己的业务和架构来考虑设计，尽量实现报体小、满足功能、易解析等特性。&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;
&lt;p&gt;编码、解码
在 09 讲中，我们分析过序列化编码和解码的过程，对于实现一个好的网络通信协议来说，兼容优秀的序列化框架是非常重要的。如果只是单纯的数据对象传输，我们可以选择性能相对较好的 Protobuf 序列化，有利于提高网络通信的性能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调整 Linux 的 TCP 参数设置选项
如果 RPC 是基于 TCP 短连接实现的，我们可以通过修改 Linux TCP 配置项来优化网络通信。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们可以通过 sysctl -a | grep net.xxx 命令运行查看 Linux 系统默认的的 TCP 参数设置，如果需要修改某项配置，可以通过编辑 vim/etc/sysctl.conf，加入需要修改的配置项， 并通过 sysctl -p 命令运行生效修改后的配置项设置。通常我们会通过修改以下几个配置项来提高网络吞吐量和降低延时。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/17.jpeg&#34;
	width=&#34;1503&#34;
	height=&#34;1340&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/17_hu_a6a38174474447a7.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/17_hu_4ada462e7cc32914.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;112&#34;
		data-flex-basis=&#34;269px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;以上就是我们从不同层次对 RPC 优化的详解，除了最后的 Linux 系统中 TCP 的配置项设置调优，其它的调优更多是从代码编程优化的角度出发，最终实现了一套 RPC 通信框架的优化路径。&lt;/p&gt;
&lt;p&gt;弄懂了这些，你就可以根据自己的业务场景去做技术选型了，还能很好地解决过程中出现的一些性能问题。&lt;/p&gt;
&lt;h2 id=&#34;39-常用的性能测试工具&#34;&gt;3.9 常用的性能测试工具
&lt;/h2&gt;&lt;p&gt;常用的性能测试工具有很多，在这里我将列举几个比较实用的。&lt;/p&gt;
&lt;p&gt;对于开发人员来说，首选是一些开源免费的性能（压力）测试软件，例如 ab（ApacheBench）、JMeter 等；对于专业的测试团队来说，付费版的 LoadRunner 是首选。当然，也有很多公司是自行开发了一套量身定做的性能测试软件，优点是定制化强，缺点则是通用性差。&lt;/p&gt;
&lt;h3 id=&#34;391ab&#34;&gt;3.9.1.ab
&lt;/h3&gt;&lt;p&gt;ab 测试工具是 Apache 提供的一款测试工具，具有简单易上手的特点，在测试 Web 服务时非常实用。&lt;/p&gt;
&lt;p&gt;ab 可以在 Windows 系统中使用，也可以在 Linux 系统中使用。这里我说下在 Linux 系统中的安装方法，非常简单，只需要在 Linux 系统中输入 yum-y install httpd-tools 命令，就可以了。&lt;/p&gt;
&lt;p&gt;ab 工具用来测试 post get 接口请求非常便捷，可以通过参数指定请求数、并发数、请求参数等。例如，一个测试并发用户数为 10、请求数量为 100 的的 post 请求输入如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ab -n 100  -c 10 -p &amp;#39;post.txt&amp;#39; -T &amp;#39;application/x-www-form-urlencoded&amp;#39; &amp;#39;http://test.api.com/test/register&amp;#39;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;post.txt 为存放 post 参数的文档，存储格式如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;usernanme=test&amp;amp;password=test&amp;amp;sex=1
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;附上几个常用参数的含义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;-n：总请求次数（最小默认为 1）；&lt;/li&gt;
&lt;li&gt;-c：并发次数（最小默认为 1 且不能大于总请求次数，例如：10 个请求，10 个并发，实际就是 1 人请求 1 次）；&lt;/li&gt;
&lt;li&gt;-p：post 参数文档路径（-p 和 -T 参数要配合使用）；&lt;/li&gt;
&lt;li&gt;-T：header 头内容类型（此处切记是大写英文字母 T）。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ab -c 10 -n 100 http://www.test.api.com/test/login?userName=test&amp;amp;password=test
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;以上输出中，有几项性能指标可以提供给你参考使用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Requests per second：吞吐率，指某个并发用户数下单位时间内处理的请求数；&lt;/li&gt;
&lt;li&gt;Time per request：上面的是用户平均请求等待时间，指处理完成所有请求数所花费的时间 /（总请求数 / 并发用户数）；&lt;/li&gt;
&lt;li&gt;Time per request：下面的是服务器平均请求处理时间，指处理完成所有请求数所花费的时间 / 总请求数；&lt;/li&gt;
&lt;li&gt;Percentage of the requests served within a certain time：每秒请求时间分布情况，指在整个请求中，每个请求的时间长度的分布情况，例如有 50% 的请求响应在 8ms 内，66% 的请求响应在 10ms 内，说明有 16% 的请求在 8ms~10ms 之间。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;392-jmeter&#34;&gt;3.9.2 JMeter
&lt;/h3&gt;&lt;p&gt;JMeter 是 Apache 提供的一款功能性比较全的性能测试工具，同样可以在 Windows 和 Linux 环境下安装使用。&lt;/p&gt;
&lt;p&gt;JMeter 在 Windows 环境下使用了图形界面，可以通过图形界面来编写测试用例，具有易学和易操作的特点。&lt;/p&gt;
&lt;p&gt;JMeter 不仅可以实现简单的并发性能测试，还可以实现复杂的宏基准测试。我们可以通过录制脚本的方式，在 JMeter 实现整个业务流程的测试。JMeter 也支持通过 csv 文件导入参数变量，实现用多样化的参数测试系统性能。&lt;/p&gt;
&lt;p&gt;JMeter 的测试结果与 ab 的测试结果的指标参数差不多，这里我就不再重复讲解了。&lt;/p&gt;
&lt;h3 id=&#34;393-loadrunner&#34;&gt;3.9.3 LoadRunner
&lt;/h3&gt;&lt;p&gt;LoadRunner 是一款商业版的测试工具，并且 License 的售价不低。&lt;/p&gt;
&lt;p&gt;作为一款专业的性能测试工具，LoadRunner 在性能压测时，表现得非常稳定和高效。相比 JMeter，LoadRunner 可以模拟出不同的内网 IP 地址，通过分配不同的 IP 地址给测试的用户，模拟真实环境下的用户。这里我就不展开详述了。&lt;/p&gt;
&lt;p&gt;三种常用的性能测试工具就介绍完了，最后我把今天的主要内容为你总结了一张图。
&lt;img src=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/18.jpeg&#34;
	width=&#34;2644&#34;
	height=&#34;992&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/18_hu_408c6a9724163377.jpeg 480w, https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%982/18_hu_53f836674605b0d6.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;266&#34;
		data-flex-basis=&#34;639px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;现在测试工具非常多，包括阿里云的 PTS 测试工具也很好用，但每款测试工具其实都有自己的优缺点。个人建议，还是在熟练掌握其中一款测试工具的前提下，再去探索其他测试工具的使用方法会更好。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Java性能调优1</title>
        <link>https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%981/</link>
        <pubDate>Wed, 24 Feb 2021 18:16:39 +0800</pubDate>
        
        <guid>https://zhenyu0324.github.io/p/java%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%981/</guid>
        <description>&lt;h1 id=&#34;1-引言&#34;&gt;1. 引言
&lt;/h1&gt;&lt;h2 id=&#34;11怎样才能做好性能调优&#34;&gt;1.1怎样才能做好性能调优
&lt;/h2&gt;&lt;p&gt;互联网时代，一个简单的系统就囊括了应用程序、数据库、容器、操作系统、网络等技术，线上一旦出现性能问题，就可能要你协调多方面组件去进行优化，这就是技术广度；而很多性能问题呢，又隐藏得很深，可能因为一个小小的代码，也可能因为线程池的类型选择错误…可归根结底考验的还是我们对这项技术的了解程度，这就是技术深度。&lt;/p&gt;
&lt;p&gt;显然，性能调优不是一件容易的事。但有没有什么方法能把这件事情做好呢？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;扎实的计算机基础&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们调优的对象不是单一的应用服务，而是错综复杂的系统。应用服务的性能可能与操作系统、网络、数据库等组件相关，所以我们需要储备计算机组成原理、操作系统、网络协议以及数据库等基础知识。具体的性能问题往往还与传输、计算、存储数据等相关，那我们还需要储备数据结构、算法以及数学等基础知识。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;习惯透过源码了解技术本质&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我身边有很多好学的同学，他们经常和我分享在一些技术论坛或者公众号上学到的技术。这个方式很好，因为论坛上边的大部分内容，都是生产者自己吸收消化后总结的知识点，能帮助我们快速获取、快速理解。但是只做到这个程度还不够，因为你缺失了自己的判断。怎么办呢？我们需要深入源码，通过分析来学习、总结一项技术的实现原理和优缺点，这样我们就能更客观地去学习一项技术，还能透过源码来学习牛人的思维方式，收获更好的编码实现方式。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;善于追问和总结&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;很多同学在使用一项技术时，只是因为这项技术好用就用了，从来不问自己：为什么这项技术可以提升系统性能？对比其他技术它好在哪儿？实现的原理又是什么呢？事实上，“知其然且知所以然”才是我们积累经验的关键。知道了一项技术背后的实现原理，我们才能在遇到性能问题时，做到触类旁通。&lt;/p&gt;
&lt;h2 id=&#34;12-如何制定性能调优标准&#34;&gt;1.2 如何制定性能调优标准？
&lt;/h2&gt;&lt;h3 id=&#34;121-为什么要做性能调优&#34;&gt;1.2.1 为什么要做性能调优？
&lt;/h3&gt;&lt;p&gt;款线上产品如果没有经过性能测试，那它就好比是一颗定时炸弹，你不知道它什么时候会出现问题，你也不清楚它能承受的极限在哪儿。&lt;/p&gt;
&lt;p&gt;有些性能问题是时间累积慢慢产生的，到了一定时间自然就爆炸了；而更多的性能问题是由访问量的波动导致的，例如，活动或者公司产品用户量上升；当然也有可能是一款产品上线后就半死不活，一直没有大访问量，所以还没有引发这颗定时炸弹。&lt;/p&gt;
&lt;p&gt;比如，当你在用某一款 App 查询某一条信息时，需要等待十几秒钟；在抢购活动中，无法进入活动页面等等。你看，系统响应就是体现系统性能最直接的一个参考因素。&lt;/p&gt;
&lt;p&gt;好的系统性能调优不仅仅可以提高系统的性能，还能为公司节省资源。这也是我们做性能调优的最直接的目的。&lt;/p&gt;
&lt;h3 id=&#34;122-什么时候开始介入调优&#34;&gt;1.2.2 什么时候开始介入调优？
&lt;/h3&gt;&lt;p&gt;解决了为什么要做性能优化的问题，那么新的问题就来了：如果需要对系统做一次全面的性能监测和优化，我们从什么时候开始介入性能调优呢？是不是越早介入越好？&lt;/p&gt;
&lt;p&gt;其实，在项目开发的初期，我们没有必要过于在意性能优化，这样反而会让我们疲于性能优化，不仅不会给系统性能带来提升，还会影响到开发进度，甚至获得相反的效果，给系统带来新的问题。&lt;/p&gt;
&lt;p&gt;我们只需要在代码层面保证有效的编码，比如，减少磁盘 I/O 操作、降低竞争锁的使用以及使用高效的算法等等。遇到比较复杂的业务，我们可以充分利用设计模式来优化业务代码。&lt;/p&gt;
&lt;p&gt;在系统编码完成之后，我们就可以对系统进行性能测试了。这时候，产品经理一般会提供线上预期数据，我们在提供的参考平台上进行压测，通过性能分析、统计工具来统计各项性能指标，看是否在预期范围之内。&lt;/p&gt;
&lt;p&gt;在项目成功上线后，我们还需要根据线上的实际情况，依照日志监控以及性能统计日志，来观测系统性能问题，一旦发现问题，就要对日志进行分析并及时修复问题。&lt;/p&gt;
&lt;h3 id=&#34;123-有哪些参考因素可以体现系统的性能&#34;&gt;1.2.3 有哪些参考因素可以体现系统的性能？
&lt;/h3&gt;&lt;p&gt;上面我们讲到了在项目研发的各个阶段性能调优是如何介入的，其中多次讲到了性能指标，那么性能指标到底有哪些呢？&lt;/p&gt;
&lt;p&gt;CPU：有的应用需要大量计算，他们会长时间、不间断地占用 CPU 资源，导致其他资源无法争夺到 CPU 而响应缓慢，从而带来系统性能问题。例如，代码递归导致的无限循环，正则表达式引起的回溯，JVM 频繁的 FULL GC，以及多线程编程造成的大量上下文切换等，这些都有可能导致 CPU 资源繁忙。&lt;/p&gt;
&lt;p&gt;内存：Java 程序一般通过 JVM 对内存进行分配管理，主要是用 JVM 中的堆内存来存储 Java 创建的对象。系统堆内存的读写速度非常快，所以基本不存在读写性能瓶颈。但是由于内存成本要比磁盘高，相比磁盘，内存的存储空间又非常有限。所以当内存空间被占满，对象无法回收时，就会导致内存溢出、内存泄露等问题。&lt;/p&gt;
&lt;p&gt;磁盘 I/O：磁盘相比内存来说，存储空间要大很多，但磁盘 I/O 读写的速度要比内存慢，虽然目前引入的 SSD 固态硬盘已经有所优化，但仍然无法与内存的读写速度相提并论。&lt;/p&gt;
&lt;p&gt;网络：网络对于系统性能来说，也起着至关重要的作用。如果你购买过云服务，一定经历过，选择网络带宽大小这一环节。带宽过低的话，对于传输数据比较大，或者是并发量比较大的系统，网络就很容易成为性能瓶颈。&lt;/p&gt;
&lt;p&gt;异常：Java 应用中，抛出异常需要构建异常栈，对异常进行捕获和处理，这个过程非常消耗系统性能。如果在高并发的情况下引发异常，持续地进行异常处理，那么系统的性能就会明显地受到影响。&lt;/p&gt;
&lt;p&gt;数据库：大部分系统都会用到数据库，而数据库的操作往往是涉及到磁盘 I/O 的读写。大量的数据库读写操作，会导致磁盘 I/O 性能瓶颈，进而导致数据库操作的延迟性。对于有大量数据库读写操作的系统来说，数据库的性能优化是整个系统的核心。&lt;/p&gt;
&lt;p&gt;锁竞争：在并发编程中，我们经常会需要多个线程，共享读写操作同一个资源，这个时候为了保持数据的原子性（即保证这个共享资源在一个线程写的时候，不被另一个线程修改），我们就会用到锁。锁的使用可能会带来上下文切换，从而给系统带来性能开销。JDK1.6 之后，Java 为了降低锁竞争带来的上下文切换，对 JVM 内部锁已经做了多次优化，例如，新增了偏向锁、自旋锁、轻量级锁、锁粗化、锁消除等。而如何合理地使用锁资源，优化锁资源，就需要你了解更多的操作系统知识、Java 多线程编程基础，积累项目经验，并结合实际场景去处理相关问题。&lt;/p&gt;
&lt;p&gt;了解了上面这些基本内容，我们可以得到下面几个指标，来衡量一般系统的性能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;响应时间&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;响应时间是衡量系统性能的重要指标之一，响应时间越短，性能越好，一般一个接口的响应时间是在毫秒级。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据库响应时间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数据库操作所消耗的时间，往往是整个请求链中最耗时的；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务端响应时间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;服务端包括 Nginx 分发的请求所消耗的时间以及服务端程序执行所消耗的时间；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;网络响应时间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这是网络传输时，网络硬件需要对传输的请求进行解析等操作所消耗的时间；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;客户端响应时间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于普通的 Web、App 客户端来说，消耗时间是可以忽略不计的，但如果你的客户端嵌入了大量的逻辑处理，消耗的时间就有可能变长，从而成为系统的瓶颈。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;吞吐量&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在测试中，我们往往会比较注重系统接口的 TPS（每秒事务处理量），因为 TPS 体现了接口的性能，TPS 越大，性能越好。在系统中，我们也可以把吞吐量自下而上地分为两种：磁盘吞吐量和网络吞吐量。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;磁盘吞吐量&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一种是 IOPS（Input/Output Per Second），即每秒的输入输出量（或读写次数），这种是指单位时间内系统能处理的 I/O 请求数量，I/O 请求通常为读或写数据操作请求，关注的是随机读写性能。适应于随机读写频繁的应用，如小文件存储（图片）、OLTP 数据库、邮件服务器。&lt;/p&gt;
&lt;p&gt;另一种是数据吞吐量，这种是指单位时间内可以成功传输的数据量。对于大量顺序读写频繁的应用，传输大量连续数据，例如，电视台的视频编辑、视频点播 VOD（Video On Demand），数据吞吐量则是关键衡量指标。&lt;/p&gt;
&lt;p&gt;网络吞吐量&lt;/p&gt;
&lt;p&gt;网络传输时没有帧丢失的情况下，设备能够接受的最大数据速率。网络吞吐量不仅仅跟带宽有关系，还跟 CPU 的处理能力、网卡、防火墙、外部接口以及 I/O 等紧密关联。而吞吐量的大小主要由网卡的处理能力、内部程序算法以及带宽大小决定。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;计算机资源分配使用率&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通常由 CPU 占用率、内存使用率、磁盘 I/O、网络 I/O 来表示资源使用率。这几个参数好比一个木桶，如果其中任何一块木板出现短板，任何一项分配不合理，对整个系统性能的影响都是毁灭性的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;负载承受能力&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当系统压力上升时，你可以观察，系统响应时间的上升曲线是否平缓。这项指标能直观地反馈给你，系统所能承受的负载压力极限。例如，当你对系统进行压测时，系统的响应时间会随着系统并发数的增加而延长，直到系统无法处理这么多请求，抛出大量错误时，就到了极限。&lt;/p&gt;
&lt;h2 id=&#34;13-如何制定性能调优策略&#34;&gt;1.3 如何制定性能调优策略？
&lt;/h2&gt;&lt;h3 id=&#34;131-性能测试攻略&#34;&gt;1.3.1 性能测试攻略
&lt;/h3&gt;&lt;p&gt;两种常用的测试方法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;微基准性能测试&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;微基准性能测试可以精准定位到某个模块或者某个方法的性能问题，特别适合做一个功能模块或者一个方法在不同实现方式下的性能对比。例如，对比一个方法使用同步实现和非同步实现的性能。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;宏基准性能测试&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;宏基准性能测试是一个综合测试，需要考虑到测试环境、测试场景和测试目标。&lt;/p&gt;
&lt;p&gt;首先看测试环境，我们需要模拟线上的真实环境。&lt;/p&gt;
&lt;p&gt;然后看测试场景。我们需要确定在测试某个接口时，是否有其他业务接口同时也在平行运行，造成干扰。如果有，请重视，因为你一旦忽视了这种干扰，测试结果就会出现偏差。&lt;/p&gt;
&lt;p&gt;最后看测试目标。我们的性能测试是要有目标的，这里可以通过吞吐量以及响应时间来衡量系统是否达标。不达标，就进行优化；达标，就继续加大测试的并发数，探底接口的 TPS（最大每秒事务处理量），这样做，可以深入了解到接口的性能。除了测试接口的吞吐量和响应时间以外，我们还需要循环测试可能导致性能问题的接口，观察各个服务器的 CPU、内存以及 I/O 使用率的变化。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;做性能测试时，还要注意一些问题&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;热身问题&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当我们做性能测试时，我们的系统会运行得越来越快，后面的访问速度要比我们第一次访问的速度快上几倍。这是怎么回事呢？&lt;/p&gt;
&lt;p&gt;在 Java 编程语言和环境中，.java 文件编译成为 .class 文件后，机器还是无法直接运行 .class 文件中的字节码，需要通过解释器将字节码转换成本地机器码才能运行。为了节约内存和执行效率，代码最初被执行时，解释器会率先解释执行这段代码。&lt;/p&gt;
&lt;p&gt;随着代码被执行的次数增多，当虚拟机发现某个方法或代码块运行得特别频繁时，就会把这些代码认定为热点代码（Hot Spot Code）。为了提高热点代码的执行效率，在运行时，虚拟机将会通过即时编译器（JIT compiler，just-in-time compiler）把这些代码编译成与本地平台相关的机器码，并进行各层次的优化，然后存储在内存中，之后每次运行代码时，直接从内存中获取即可。&lt;/p&gt;
&lt;p&gt;所以在刚开始运行的阶段，虚拟机会花费很长的时间来全面优化代码，后面就能以最高性能执行了。&lt;/p&gt;
&lt;p&gt;这就是热身过程，如果在进行性能测试时，热身时间过长，就会导致第一次访问速度过慢，你就可以考虑先优化，再进行测试。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;性能测试结果不稳定&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们在做性能测试时发现，每次测试处理的数据集都是一样的，但测试结果却有差异。这是因为测试时，伴随着很多不稳定因素，比如机器其他进程的影响、网络波动以及每个阶段 JVM 垃圾回收的不同等等。&lt;/p&gt;
&lt;p&gt;我们可以通过多次测试，将测试结果求平均，或者统计一个曲线图，只要保证我们的平均值是在合理范围之内，而且波动不是很大，这种情况下，性能测试就是通过的。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;多 JVM 情况下的影响&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果我们的服务器有多个 Java 应用服务，部署在不同的 Tomcat 下，这就意味着我们的服务器会有多个 JVM。任意一个 JVM 都拥有整个系统的资源使用权。如果一台机器上只部署单独的一个 JVM，在做性能测试时，测试结果很好，或者你调优的效果很好，但在一台机器多个 JVM 的情况下就不一定了。所以我们应该尽量避免线上环境中一台机器部署多个 JVM 的情况。&lt;/p&gt;
&lt;h3 id=&#34;132-合理分析结果制定调优策略&#34;&gt;1.3.2 合理分析结果，制定调优策略
&lt;/h3&gt;&lt;p&gt;分析查找问题是一个复杂而又细致的过程，某个性能问题可能是一个原因导致的，也可能是几个原因共同导致的结果。我们分析查找问题可以采用自下而上的方式，而我们解决系统性能问题，则可以采用自上而下的方式逐级优化。下面我来介绍下从应用层到操作系统层的几种调优策略。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;优化代码&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;应用层的问题代码往往会因为耗尽系统资源而暴露出来。例如，我们某段代码导致内存溢出，往往是将 JVM 中的内存用完了，这个时候系统的内存资源消耗殆尽了，同时也会引发 JVM 频繁地发生垃圾回收，导致 CPU 100% 以上居高不下，这个时候又消耗了系统的 CPU 资源。&lt;/p&gt;
&lt;p&gt;还有一些是非问题代码导致的性能问题，这种往往是比较难发现的，需要依靠我们的经验来优化。例如，我们经常使用的 LinkedList 集合，如果使用 for 循环遍历该容器，将大大降低读的效率，但这种效率的降低很难导致系统性能参数异常。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;优化设计&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;面向对象有很多设计模式，可以帮助我们优化业务层以及中间件层的代码设计。优化后，不仅可以精简代码，还能提高整体性能。例如，单例模式在频繁调用创建对象的场景中，可以共享一个创建对象，这样可以减少频繁地创建和销毁对象所带来的性能消耗。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;优化算法
好的算法可以帮助我们大大地提升系统性能。例如，在不同的场景中，使用合适的查找算法可以降低时间复杂度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时间换空间
有时候系统对查询时的速度并没有很高的要求，反而对存储空间要求苛刻，这个时候我们可以考虑用时间来换取空间。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;例如，我在 03 讲就会详解的用 String 对象的 intern 方法，可以将重复率比较高的数据集存储在常量池，重复使用一个相同的对象，这样可以大大节省内存存储空间。但由于常量池使用的是 HashMap 数据结构类型，如果我们存储数据过多，查询的性能就会下降。所以在这种对存储容量要求比较苛刻，而对查询速度不作要求的场景，我们就可以考虑用时间换空间。&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;空间换时间
这种方法是使用存储空间来提升访问速度。现在很多系统都是使用的 MySQL 数据库，较为常见的分表分库是典型的使用空间换时间的案例。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因为 MySQL 单表在存储千万数据以上时，读写性能会明显下降，这个时候我们需要将表数据通过某个字段 Hash 值或者其他方式分拆，系统查询数据时，会根据条件的 Hash 值判断找到对应的表，因为表数据量减小了，查询性能也就提升了。&lt;/p&gt;
&lt;ol start=&#34;6&#34;&gt;
&lt;li&gt;参数调优
以上都是业务层代码的优化，除此之外，JVM、Web 容器以及操作系统的优化也是非常关键的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;根据自己的业务场景，合理地设置 JVM 的内存空间以及垃圾回收算法可以提升系统性能。例如，如果我们业务中会创建大量的大对象，我们可以通过设置，将这些大对象直接放进老年代。这样可以减少年轻代频繁发生小的垃圾回收（Minor GC），减少 CPU 占用时间，提升系统性能。&lt;/p&gt;
&lt;p&gt;Web 容器线程池的设置以及 Linux 操作系统的内核参数设置不合理也有可能导致系统性能瓶颈，根据自己的业务场景优化这两部分，可以提升系统性能。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>如何设计秒杀系统(下)</title>
        <link>https://zhenyu0324.github.io/p/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E4%B8%8B/</link>
        <pubDate>Tue, 23 Feb 2021 15:01:13 +0800</pubDate>
        
        <guid>https://zhenyu0324.github.io/p/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E4%B8%8B/</guid>
        <description>&lt;h1 id=&#34;6-影响性能的因素有哪些又该如何提高系统的性能&#34;&gt;6. 影响性能的因素有哪些？又该如何提高系统的性能？
&lt;/h1&gt;&lt;p&gt;系统服务端性能,一般用 QPS（Query Per Second，每秒请求数）来衡量，还有一个影响和 QPS 也息息相关，那就是响应时间（Response Time，RT），它可以理解为服务器处理响应的耗时。&lt;/p&gt;
&lt;p&gt;正常情况下响应时间（RT）越短，一秒钟处理的请求数（QPS）自然也就会越多，这在单线程处理的情况下看起来是线性的关系，即我们只要把每个请求的响应时间降到最低，那么性能就会最高。&lt;/p&gt;
&lt;p&gt;但是你可能想到响应时间总有一个极限，不可能无限下降，所以又出现了另外一个维度，即通过多线程，来处理请求。这样理论上就变成了“总 QPS =（1000ms / 响应时间）× 线程数量”，这样性能就和两个因素相关了，一个是一次响应的服务端耗时，一个是处理请求的线程数。&lt;/p&gt;
&lt;h2 id=&#34;61-响应时间和-qps-关系&#34;&gt;6.1 响应时间和 QPS 关系
&lt;/h2&gt;&lt;p&gt;对于大部分的 Web 系统而言，响应时间一般都是由 CPU 执行时间和线程等待时间（比如 RPC、IO 等待、Sleep、Wait 等）组成，即服务器在处理一个请求时，一部分是 CPU 本身在做运算，还有一部分是在各种等待。&lt;/p&gt;
&lt;p&gt;理解了服务器处理请求的逻辑，估计你会说为什么我们不去减少这种等待时间。很遗憾，根据我们实际的测试发现，减少线程等待时间对提升性能的影响没有我们想象得那么大，它并不是线性的提升关系，这点在很多代理服务器（Proxy）上可以做验证。&lt;/p&gt;
&lt;p&gt;如果代理服务器本身没有 CPU 消耗，我们在每次给代理服务器代理的请求加个延时，即增加响应时间，但是这对代理服务器本身的吞吐量并没有多大的影响，因为代理服务器本身的资源并没有被消耗，可以通过增加代理服务器的处理线程数，来弥补响应时间对代理服务器的 QPS 的影响。&lt;/p&gt;
&lt;p&gt;其实，真正对性能有影响的是 CPU 的执行时间。这也很好理解，因为 CPU 的执行真正消耗了服务器的资源。经过实际的测试，如果减少 CPU 一半的执行时间，就可以增加一倍的 QPS。&lt;/p&gt;
&lt;p&gt;也就是说，我们应该致力于减少 CPU 的执行时间。&lt;/p&gt;
&lt;h2 id=&#34;62-线程数对-qps-的影响&#34;&gt;6.2 线程数对 QPS 的影响
&lt;/h2&gt;&lt;p&gt;单看“总 QPS”的计算公式，你会觉得线程数越多 QPS 也就会越高，但这会一直正确吗？显然不是，线程数不是越多越好，因为线程本身也消耗资源，也受到其他因素的制约。例如，线程越多系统的线程切换成本就会越高，而且每个线程也都会耗费一定内存。&lt;/p&gt;
&lt;p&gt;那么，设置什么样的线程数最合理呢？其实很多多线程的场景都有一个默认配置，即“线程数 = 2 * CPU 核数 + 1”。除去这个配置，还有一个根据最佳实践得出来的公式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;线程数 = [(线程等待时间 + 线程 CPU 时间) / 线程 CPU 时间] × CPU 数量
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;当然，最好的办法是通过性能测试来发现最佳的线程数。&lt;/p&gt;
&lt;p&gt;换句话说，要提升性能我们就要减少 CPU 的执行时间，另外就是要设置一个合理的并发线程数，通过这两方面来显著提升服务器的性能。&lt;/p&gt;
&lt;p&gt;现在，你知道了如何来快速提升性能，那接下来你估计会问，我应该怎么发现系统哪里最消耗 CPU 资源呢？&lt;/p&gt;
&lt;h2 id=&#34;63-如何发现瓶颈&#34;&gt;6.3 如何发现瓶颈
&lt;/h2&gt;&lt;p&gt;就服务器而言，会出现瓶颈的地方有很多，例如 CPU、内存、磁盘以及网络等都可能会导致瓶颈。此外，不同的系统对瓶颈的关注度也不一样，例如对缓存系统而言，制约它的是内存，而对存储型系统来说 I/O 更容易是瓶颈。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们定位的场景是秒杀，它的瓶颈更多地发生在 CPU 上。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么，如何发现 CPU 的瓶颈呢？其实有很多 CPU 诊断工具可以发现 CPU 的消耗，最常用的就是 JProfiler 和 Yourkit 这两个工具，它们可以列出整个请求中每个函数的 CPU 执行时间，可以发现哪个函数消耗的 CPU 时间最多，以便你有针对性地做优化。&lt;/p&gt;
&lt;p&gt;当然还有一些办法也可以近似地统计 CPU 的耗时，例如通过 jstack 定时地打印调用栈，如果某些函数调用频繁或者耗时较多，那么那些函数就会多次出现在系统调用栈里，这样相当于采样的方式也能够发现耗时较多的函数。&lt;/p&gt;
&lt;p&gt;虽说秒杀系统的瓶颈大部分在 CPU，但这并不表示其他方面就一定不出现瓶颈。例如，如果海量请求涌过来，你的页面又比较大，那么网络就有可能出现瓶颈。&lt;/p&gt;
&lt;p&gt;怎样简单地判断 CPU 是不是瓶颈呢？一个办法就是看当 QPS 达到极限时，你的服务器的 CPU 使用率是不是超过了 95%，如果没有超过，那么表示 CPU 还有提升的空间，要么是有锁限制，要么是有过多的本地 I/O 等待发生。&lt;/p&gt;
&lt;h2 id=&#34;64-如何优化系统&#34;&gt;6.4 如何优化系统
&lt;/h2&gt;&lt;p&gt;对 Java 系统来说，可以优化的地方很多，这里我重点说一下比较有效的几种手段，供你参考，它们是：减少编码、减少序列化、Java 极致优化、并发读优化。接下来，我们分别来看一下。&lt;/p&gt;
&lt;h3 id=&#34;641-减少编码&#34;&gt;6.4.1 减少编码
&lt;/h3&gt;&lt;p&gt;Java 的编码运行比较慢，这是 Java 的一大硬伤。在很多场景下，只要涉及字符串的操作（如输入输出操作、I/O 操作）都比较耗 CPU 资源，不管它是磁盘 I/O 还是网络 I/O，因为都需要将字符转换成字节，而这个转换必须编码。&lt;/p&gt;
&lt;p&gt;每个字符的编码都需要查表，而这种查表的操作非常耗资源，所以减少字符到字节或者相反的转换、减少字符编码会非常有成效。减少编码就可以大大提升性能。&lt;/p&gt;
&lt;p&gt;那么如何才能减少编码呢？例如，网页输出是可以直接进行流输出的，即用 resp.getOutputStream() 函数写数据，把一些静态的数据提前转化成字节，等到真正往外写的时候再直接用 OutputStream() 函数写，就可以减少静态数据的编码转换。&lt;/p&gt;
&lt;h3 id=&#34;642-减少序列化&#34;&gt;6.4.2 减少序列化
&lt;/h3&gt;&lt;p&gt;序列化也是 Java 性能的一大天敌，减少 Java 中的序列化操作也能大大提升性能。又因为序列化往往是和编码同时发生的，所以减少序列化也就减少了编码。&lt;/p&gt;
&lt;p&gt;序列化大部分是在 RPC 中发生的，因此避免或者减少 RPC 就可以减少序列化，当然当前的序列化协议也已经做了很多优化来提升性能。有一种新的方案，就是可以将多个关联性比较强的应用进行“合并部署”，而减少不同应用之间的 RPC 也可以减少序列化的消耗。&lt;/p&gt;
&lt;p&gt;所谓“合并部署”，就是把两个原本在不同机器上的不同应用合并部署到一台机器上，当然不仅仅是部署在一台机器上，还要在同一个 Tomcat 容器中，且不能走本机的 Socket，这样才能避免序列化的产生。&lt;/p&gt;
&lt;h3 id=&#34;643-java-极致优化&#34;&gt;6.4.3 Java 极致优化
&lt;/h3&gt;&lt;p&gt;Java 和通用的 Web 服务器（如 Nginx 或 Apache 服务器）相比，在处理大并发的 HTTP 请求时要弱一点，所以一般我们都会对大流量的 Web 系统做静态化改造，让大部分请求和数据直接在 Nginx 服务器或者 Web 代理服务器（如 Varnish、Squid 等）上直接返回（这样可以减少数据的序列化与反序列化），而 Java 层只需处理少量数据的动态请求。针对这些请求，我们可以使用以下手段进行优化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;直接使用 Servlet 处理请求。避免使用传统的 MVC 框架，这样可以绕过一大堆复杂且用处不大的处理逻辑，节省 1ms 时间（具体取决于你对 MVC 框架的依赖程度）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;直接输出流数据。使用 resp.getOutputStream() 而不是 resp.getWriter() 函数，可以省掉一些不变字符数据的编码，从而提升性能；数据输出时推荐使用 JSON 而不是模板引擎（一般都是解释执行）来输出页面。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;644-并发读优化&#34;&gt;6.4.4 并发读优化
&lt;/h3&gt;&lt;p&gt;也许有读者会觉得这个问题很容易解决，无非就是放到 Tair 缓存里面。集中式缓存为了保证命中率一般都会采用一致性 Hash，所以同一个 key 会落到同一台机器上。虽然单台缓存机器也能支撑 30w/s 的请求，但还是远不足以应对像“大秒”这种级别的热点商品。那么，该如何彻底解决单点的瓶颈呢？&lt;/p&gt;
&lt;p&gt;答案是采用应用层的 LocalCache，即在秒杀系统的单机上缓存商品相关的数据。&lt;/p&gt;
&lt;p&gt;那么，又如何缓存（Cache）数据呢？你需要划分成动态数据和静态数据分别进行处理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;像商品中的“标题”和“描述”这些本身不变的数据，会在秒杀开始之前全量推送到秒杀机器上，并一直缓存到秒杀结束；&lt;/li&gt;
&lt;li&gt;像库存这类动态数据，会采用“被动失效”的方式缓存一定时间（一般是数秒），失效后再去缓存拉取最新的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你可能还会有疑问：像库存这种频繁更新的数据，一旦数据不一致，会不会导致超卖？&lt;/p&gt;
&lt;p&gt;这就要用到前面介绍的读数据的分层校验原则了，读的场景可以允许一定的脏数据，因为这里的误判只会导致少量原本无库存的下单请求被误认为有库存，可以等到真正写数据时再保证最终的一致性，通过在数据的高可用性和一致性之间的平衡，来解决高并发的数据读取问题。&lt;/p&gt;
&lt;h1 id=&#34;7-秒杀系统减库存设计的核心逻辑&#34;&gt;7. 秒杀系统“减库存”设计的核心逻辑
&lt;/h1&gt;&lt;p&gt;如果要设计一套秒杀系统，那我想你的老板肯定会先对你说：千万不要超卖，这是大前提。&lt;/p&gt;
&lt;h2 id=&#34;71-减库存有哪几种方式&#34;&gt;7.1 减库存有哪几种方式
&lt;/h2&gt;&lt;p&gt;在正常的电商平台购物场景中，用户的实际购买过程一般分为两步：下单和付款。&lt;/p&gt;
&lt;p&gt;那如果你是架构师，你会在哪个环节完成减库存的操作呢？总结来说，减库存操作一般有如下几个方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;下单减库存&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;即当买家下单后，在商品的总库存中减去买家购买数量。下单减库存是最简单的减库存方式，也是控制最精确的一种，下单时直接通过数据库的事务机制控制商品库存，这样一定不会出现超卖的情况。但是你要知道，有些人下完单可能并不会付款。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;付款减库存&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;即买家下单后，并不立即减库存，而是等到有用户付款后才真正减库存，否则库存一直保留给其他买家。但因为付款时才减库存，如果并发比较高，有可能出现买家下单后付不了款的情况，因为可能商品已经被其他人买走了。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;预扣库存&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这种方式相对复杂一些，买家下单后，库存为其保留一定的时间（如 10 分钟），超过这个时间，库存将会自动释放，释放后其他买家就可以继续购买。在买家付款前，系统会校验该订单的库存是否还有保留：如果没有保留，则再次尝试预扣；如果库存不足（也就是预扣失败）则不允许继续付款；如果预扣成功，则完成付款并实际地减去库存。&lt;/p&gt;
&lt;p&gt;以上这几种减库存的方式都会存在一些问题，下面我们一起来看下。&lt;/p&gt;
&lt;h2 id=&#34;72-减库存可能存在的问题&#34;&gt;7.2 减库存可能存在的问题
&lt;/h2&gt;&lt;p&gt;由于购物过程中存在两步或者多步的操作，因此在不同的操作步骤中减库存，就会存在一些可能被恶意买家利用的漏洞，例如发生恶意下单的情况。&lt;/p&gt;
&lt;p&gt;假如我们采用“下单减库存”的方式，即用户下单后就减去库存，正常情况下，买家下单后付款的概率会很高，所以不会有太大问题。但是有一种场景例外，就是当卖家参加某个活动时，此时活动的有效时间是商品的黄金售卖时间，如果有竞争对手通过恶意下单的方式将该卖家的商品全部下单，让这款商品的库存减为零，那么这款商品就不能正常售卖了。要知道，这些恶意下单的人是不会真正付款的，这正是“下单减库存”方式的不足之处。&lt;/p&gt;
&lt;p&gt;既然“下单减库存”可能导致恶意下单，从而影响卖家的商品销售，那么有没有办法解决呢？你可能会想，采用“付款减库存”的方式是不是就可以了？的确可以。但是，“付款减库存”又会导致另外一个问题：库存超卖。&lt;/p&gt;
&lt;p&gt;假如有 100 件商品，就可能出现 300 人下单成功的情况，因为下单时不会减库存，所以也就可能出现下单成功数远远超过真正库存数的情况，这尤其会发生在做活动的热门商品上。这样一来，就会导致很多买家下单成功但是付不了款，买家的购物体验自然比较差。&lt;/p&gt;
&lt;p&gt;可以看到，不管是“下单减库存”还是“付款减库存”，都会导致商品库存不能完全和实际售卖情况对应起来的情况，看来要把商品准确地卖出去还真是不容易啊！&lt;/p&gt;
&lt;p&gt;那么，既然“下单减库存”和“付款减库存”都有缺点，我们能否把两者相结合，将两次操作进行前后关联起来，下单时先预扣，在规定时间内不付款再释放库存，即采用“预扣库存”这种方式呢？&lt;/p&gt;
&lt;p&gt;这种方案确实可以在一定程度上缓解上面的问题。但是否就彻底解决了呢？其实没有！针对恶意下单这种情况，虽然把有效的付款时间设置为 10 分钟，但是恶意买家完全可以在 10 分钟后再次下单，或者采用一次下单很多件的方式把库存减完。针对这种情况，解决办法还是要结合安全和反作弊的措施来制止。&lt;/p&gt;
&lt;p&gt;例如，给经常下单不付款的买家进行识别打标（可以在被打标的买家下单时不减库存）、给某些类目设置最大购买件数（例如，参加活动的商品一人最多只能买 3 件），以及对重复下单不付款的操作进行次数限制等。&lt;/p&gt;
&lt;p&gt;针对“库存超卖”这种情况，在 10 分钟时间内下单的数量仍然有可能超过库存数量，遇到这种情况我们只能区别对待：对普通的商品下单数量超过库存数量的情况，可以通过补货来解决；但是有些卖家完全不允许库存为负数的情况，那只能在买家付款时提示库存不足。&lt;/p&gt;
&lt;h2 id=&#34;73-大型秒杀中如何减库存&#34;&gt;7.3 大型秒杀中如何减库存？
&lt;/h2&gt;&lt;p&gt;目前来看，业务系统中最常见的就是预扣库存方案，像你在买机票、买电影票时，下单后一般都有个“有效付款时间”，超过这个时间订单自动释放，这都是典型的预扣库存方案。而具体到秒杀这个场景，应该采用哪种方案比较好呢？&lt;/p&gt;
&lt;p&gt;由于参加秒杀的商品，一般都是“抢到就是赚到”，所以成功下单后却不付款的情况比较少，再加上卖家对秒杀商品的库存有严格限制，所以秒杀商品采用“下单减库存”更加合理。另外，理论上由于“下单减库存”比“预扣库存”以及涉及第三方支付的“付款减库存”在逻辑上更为简单，所以性能上更占优势。&lt;/p&gt;
&lt;p&gt;“下单减库存”在数据一致性上，主要就是保证大并发请求时库存数据不能为负数，也就是要保证数据库中的库存字段值不能为负数，一般我们有多种解决方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一种是在应用程序中通过事务来判断，即保证减后库存不能为负数，否则就回滚；&lt;/li&gt;
&lt;li&gt;另一种办法是直接设置数据库的字段数据为无符号整数，这样减后库存字段值小于零时会直接执行 SQL 语句来报错；&lt;/li&gt;
&lt;li&gt;再有一种就是使用 CASE WHEN 判断语句，例如这样的 SQL 语句：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;UPDATE item SET inventory = CASE WHEN inventory &amp;gt;= xxx THEN inventory-xxx ELSE inventory END
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;74-秒杀减库存的极致优化&#34;&gt;7.4 秒杀减库存的极致优化
&lt;/h2&gt;&lt;p&gt;在交易环节中，“库存”是个关键数据，也是个热点数据，因为交易的各个环节中都可能涉及对库存的查询。但是，我在前面介绍分层过滤时提到过，秒杀中并不需要对库存有精确的一致性读，把库存数据放到缓存（Cache）中，可以大大提升读性能。&lt;/p&gt;
&lt;p&gt;解决大并发读问题，可以采用 LocalCache（即在秒杀系统的单机上缓存商品相关的数据）和对数据进行分层过滤的方式，但是像减库存这种大并发写无论如何还是避免不了，这也是秒杀场景下最为核心的一个技术难题。&lt;/p&gt;
&lt;p&gt;秒杀商品和普通商品的减库存还是有些差异的，例如商品数量比较少，交易时间段也比较短，因此这里有一个大胆的假设，即能否把秒杀商品减库存直接放到缓存系统中实现，也就是直接在缓存中减库存或者在一个带有持久化功能的缓存系统（如 Redis）中完成呢？&lt;/p&gt;
&lt;p&gt;如果你的秒杀商品的减库存逻辑非常单一，比如没有复杂的 SKU 库存和总库存这种联动关系的话，我觉得完全可以。但是如果有比较复杂的减库存逻辑，或者需要使用事务，你还是必须在数据库中完成减库存。&lt;/p&gt;
&lt;p&gt;由于 MySQL 存储数据的特点，同一数据在数据库里肯定是一行存储（MySQL），因此会有大量线程来竞争 InnoDB 行锁，而并发度越高时等待线程会越多，TPS（Transaction Per Second，即每秒处理的消息数）会下降，响应时间（RT）会上升，数据库的吞吐量就会严重受影响。&lt;/p&gt;
&lt;p&gt;这就可能引发一个问题，就是单个热点商品会影响整个数据库的性能， 导致 0.01% 的商品影响 99.99% 的商品的售卖，这是我们不愿意看到的情况。一个解决思路是遵循前面介绍的原则进行隔离，把热点商品放到单独的热点库中。&lt;/p&gt;
&lt;p&gt;而分离热点商品到单独的数据库还是没有解决并发锁的问题，我们应该怎么办呢？要解决并发锁的问题，有两种办法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用层做排队&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;按照商品维度设置队列顺序执行，这样能减少同一台机器对数据库同一行记录进行操作的并发度，同时也能控制单个商品占用数据库连接的数量，防止热点商品占用太多的数据库连接。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据库层做排队&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应用层只能做到单机的排队，但是应用机器数本身很多，这种排队方式控制并发的能力仍然有限，所以如果能在数据库层做全局排队是最理想的。阿里的数据库团队开发了针对这种 MySQL 的 InnoDB 层上的补丁程序（patch），可以在数据库层上对单行记录做到并发排队。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;你可能有疑问了，排队和锁竞争不都是要等待吗，有啥区别？&lt;/em&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果熟悉 MySQL 的话，你会知道 InnoDB 内部的死锁检测，以及 MySQL Server 和 InnoDB 的切换会比较消耗性能，淘宝的 MySQL 核心团队还做了很多其他方面的优化，如 COMMIT_ON_SUCCESS 和 ROLLBACK_ON_FAIL 的补丁程序，配合在 SQL 里面加提示（hint），在事务里不需要等待应用层提交（COMMIT），而在数据执行完最后一条 SQL 后，直接根据 TARGET_AFFECT_ROW 的结果进行提交或回滚，可以减少网络等待时间（平均约 0.7ms）。据我所知，目前阿里 MySQL 团队已经将包含这些补丁程序的 MySQL 开源。&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;另外，数据更新问题除了前面介绍的热点隔离和排队处理之外，还有些场景（如对商品的 lastmodifytime 字段的）更新会非常频繁，在某些场景下这些多条 SQL 是可以合并的，一定时间内只要执行最后一条 SQL 就行了，以便减少对数据库的更新操作。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h1 id=&#34;8-准备plan-b如何设计兜底方案&#34;&gt;8. 准备Plan B：如何设计兜底方案?
&lt;/h1&gt;&lt;p&gt;对于很多秒杀系统而言，在诸如双十一这样的大流量的迅猛冲击下，都曾经或多或少发生过宕机的情况。当一个系统面临持续的大流量时，它其实很难单靠自身调整来恢复状态，你必须等待流量自然下降或者人为地把流量切走才行，这无疑会严重影响用户的购物体验。&lt;/p&gt;
&lt;p&gt;同时，你也要知道，没有人能够提前预估所有情况，意外无法避免。那么，我们是不是就没办法了呢？当然不是，我们可以在系统达到不可用状态之前就做好流量限制，防止最坏情况的发生。用现在流行的话来说，任何一个系统，都需要“反脆弱”。&lt;/p&gt;
&lt;h2 id=&#34;81-高可用建设应该从哪里着手&#34;&gt;8.1 高可用建设应该从哪里着手
&lt;/h2&gt;&lt;p&gt;说到系统的高可用建设，它其实是一个系统工程，需要考虑到系统建设的各个阶段，也就是说它其实贯穿了系统建设的整个生命周期，涉及架构阶段、编码阶段、测试阶段、发布阶段、运行阶段，以及故障发生时。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;架构阶段：架构阶段主要考虑系统的可扩展性和容错性，要避免系统出现单点问题。例如多机房单元化部署，即使某个城市的某个机房出现整体故障，仍然不会影响整体网站的运转。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编码阶段：编码最重要的是保证代码的健壮性，例如涉及远程调用问题时，要设置合理的超时退出机制，防止被其他系统拖垮，也要对调用的返回结果集有预期，防止返回的结果超出程序处理范围，最常见的做法就是对错误异常进行捕获，对无法预料的错误要有默认处理结果。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;测试阶段：测试主要是保证测试用例的覆盖度，保证最坏情况发生时，我们也有相应的处理流程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;发布阶段：发布时也有一些地方需要注意，因为发布时最容易出现错误，因此要有紧急的回滚机制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行阶段：运行时是系统的常态，系统大部分时间都会处于运行态，运行态最重要的是对系统的监控要准确及时，发现问题能够准确报警并且报警数据要准确详细，以便于排查问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;故障发生：故障发生时首先最重要的就是及时止损，例如由于程序问题导致商品价格错误，那就要及时下架商品或者关闭购买链接，防止造成重大资产损失。然后就是要能够及时恢复服务，并定位原因解决问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为什么系统的高可用建设要放到整个生命周期中全面考虑？因为我们在每个环节中都可能犯错，而有些环节犯的错，你在后面是无法弥补的。&lt;/p&gt;
&lt;h2 id=&#34;82-降级&#34;&gt;8.2 降级
&lt;/h2&gt;&lt;p&gt;所谓“降级”，就是当系统的容量达到一定程度时，限制或者关闭系统的某些非核心功能，从而把有限的资源保留给更核心的业务。它是一个有目的、有计划的执行过程，所以对降级我们一般需要有一套预案来配合执行。如果我们把它系统化，就可以通过预案系统和开关系统来实现降级。&lt;/p&gt;
&lt;p&gt;降级方案可以这样设计：当秒杀流量达到 5w/s 时，把成交记录的获取从展示 20 条降级到只展示 5 条。“从 20 改到 5”这个操作由一个开关来实现，也就是设置一个能够从开关系统动态获取的系统参数。&lt;/p&gt;
&lt;p&gt;执行降级无疑是在系统性能和用户体验之间选择了前者，降级后肯定会影响一部分用户的体验，例如在双 11 零点时，如果优惠券系统扛不住，可能会临时降级商品详情的优惠信息展示，把有限的系统资源用在保障交易系统正确展示优惠信息上，即保障用户真正下单时的价格是正确的。所以降级的核心目标是牺牲次要的功能和用户体验来保证核心业务流程的稳定，是一个不得已而为之的举措。&lt;/p&gt;
&lt;h2 id=&#34;83-限流&#34;&gt;8.3 限流
&lt;/h2&gt;&lt;p&gt;如果说降级是牺牲了一部分次要的功能和用户的体验效果，那么限流就是更极端的一种保护措施了。限流就是当系统容量达到瓶颈时，我们需要通过限制一部分流量来保护系统，并做到既可以人工执行开关，也支持自动化保护的措施。&lt;/p&gt;
&lt;p&gt;首先，我以内部的系统调用为例，来分别说下客户端限流和服务端限流的优缺点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;客户端限流，好处可以限制请求的发出，通过减少发出无用请求从而减少对系统的消耗。缺点就是当客户端比较分散时，没法设置合理的限流阈值：如果阈值设的太小，会导致服务端没有达到瓶颈时客户端已经被限制；而如果设的太大，则起不到限制的作用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务端限流，好处是可以根据服务端的性能设置合理的阈值，而缺点就是被限制的请求都是无效的请求，处理这些无效的请求本身也会消耗服务器资源。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在限流的实现手段上来讲，基于 QPS 和线程数的限流应用最多，最大 QPS 很容易通过压测提前获取，例如我们的系统最高支持 1w QPS 时，可以设置 8000 来进行限流保护。线程数限流在客户端比较有效，例如在远程调用时我们设置连接池的线程数，超出这个并发线程请求，就将线程进行排队或者直接超时丢弃。&lt;/p&gt;
&lt;p&gt;限流无疑会影响用户的正常请求，所以必然会导致一部分用户请求失败，因此在系统处理这种异常时一定要设置超时时间，防止因被限流的请求不能 fast fail（快速失败）而拖垮系统。&lt;/p&gt;
&lt;h2 id=&#34;84-拒绝服务&#34;&gt;8.4 拒绝服务
&lt;/h2&gt;&lt;p&gt;当系统负载达到一定阈值时，例如 CPU 使用率达到 90% 或者系统 load 值达到 2*CPU 核数时，系统直接拒绝所有请求，这种方式是最暴力但也最有效的系统保护方式。例如秒杀系统，我们在如下几个环节设计过载保护：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在最前端的 Nginx 上设置过载保护，当机器负载达到某个值时直接拒绝 HTTP 请求并返回 503 错误码，在 Java 层同样也可以设计过载保护。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;拒绝服务可以说是一种不得已的兜底方案，用以防止最坏情况发生，防止因把服务器压跨而长时间彻底无法提供服务。像这种系统过载保护虽然在过载时无法提供服务，但是系统仍然可以运作，当负载下降时又很容易恢复，所以每个系统和每个环节都应该设置这个兜底方案，对系统做最坏情况下的保护。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>如何设计秒杀系统(上)</title>
        <link>https://zhenyu0324.github.io/p/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E4%B8%8A/</link>
        <pubDate>Mon, 22 Feb 2021 14:10:48 +0800</pubDate>
        
        <guid>https://zhenyu0324.github.io/p/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E4%B8%8A/</guid>
        <description>&lt;h1 id=&#34;1引言&#34;&gt;1.引言
&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;秒杀系统架构设计都有哪些关键点？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;秒杀其实主要解决两个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个是并发读&lt;/li&gt;
&lt;li&gt;一个是并发写&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;并发读的核心优化理念是尽量减少用户到服务端来“读”数据，或者让他们读更少的数据；并发写的处理原则也一样，它要求我们在数据库层面独立出来一个库，做特殊的处理。另外，我们还要针对秒杀系统做一些保护，针对意料之外的情况设计兜底方案，以防止最坏的情况发生。&lt;/p&gt;
&lt;p&gt;秒杀的整体架构可以概括为“稳、准、快”几个关键字。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;所谓“稳”，就是整个系统架构要满足高可用，流量符合预期时肯定要稳定，就是超出预期时也同样不能掉链子，你要保证秒杀活动顺利完成，即秒杀商品顺利地卖出去，这个是最基本的前提。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后就是“准”，就是秒杀 10 台 iPhone，那就只能成交 10 台，多一台少一台都不行。一旦库存不对，那平台就要承担损失，所以“准”就是要求保证数据的一致性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最后再看“快”，“快”其实很好理解，它就是说系统的性能要足够高，否则你怎么支撑这么大的流量呢？不光是服务端要做极致的性能优化，而且在整个请求链路上都要做协同的优化，每个地方快一点，整个系统就完美了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;2-设计秒杀系统时应该注意的5个架构原则&#34;&gt;2. 设计秒杀系统时应该注意的5个架构原则
&lt;/h1&gt;&lt;p&gt;架构原则：“4 要 1 不要”&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;数据要尽量少&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所谓“数据要尽量少”，首先是指用户请求的数据能少就少。请求的数据包括上传给系统的数据和系统返回给用户的数据（通常就是网页）。&lt;/p&gt;
&lt;p&gt;为啥“数据要尽量少”呢？因为首先这些数据在网络上传输需要时间，其次不管是请求数据还是返回数据都需要服务器做处理，而服务器在写网络时通常都要做压缩和字符编码，这些都非常消耗 CPU，所以减少传输的数据量可以显著减少 CPU 的使用。例如，我们可以简化秒杀页面的大小，去掉不必要的页面装修效果，等等。&lt;/p&gt;
&lt;p&gt;其次，“数据要尽量少”还要求系统依赖的数据能少就少，包括系统完成某些业务逻辑需要读取和保存的数据，这些数据一般是和后台服务以及数据库打交道的。调用其他服务会涉及数据的序列化和反序列化，而这也是 CPU 的一大杀手，同样也会增加延时。而且，数据库本身也容易成为一个瓶颈，所以和数据库打交道越少越好，数据越简单、越小则越好。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;请求数要尽量少&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;用户请求的页面返回后，浏览器渲染这个页面还要包含其他的额外请求，比如说，这个页面依赖的 CSS/JavaScript、图片，以及 Ajax 请求等等都定义为“额外请求”，这些额外请求应该尽量少。因为浏览器每发出一个请求都多少会有一些消耗，例如建立连接要做三次握手，有的时候有页面依赖或者连接数限制，一些请求（例如 JavaScript）还需要串行加载等。另外，如果不同请求的域名不一样的话，还涉及这些域名的 DNS 解析，可能会耗时更久。所以你要记住的是，减少请求数可以显著减少以上这些因素导致的资源消耗。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;路径要尽量短&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所谓“路径”，就是用户发出请求到返回数据这个过程中，需求经过的中间的节点数。&lt;/p&gt;
&lt;p&gt;通常，这些节点可以表示为一个系统或者一个新的 Socket 连接（比如代理服务器只是创建一个新的 Socket 连接来转发请求）。每经过一个节点，一般都会产生一个新的 Socket 连接。&lt;/p&gt;
&lt;p&gt;然而，每增加一个连接都会增加新的不确定性。从概率统计上来说，假如一次请求经过 5 个节点，每个节点的可用性是 99.9% 的话，那么整个请求的可用性是：99.9% 的 5 次方，约等于 99.5%。&lt;/p&gt;
&lt;p&gt;所以缩短请求路径不仅可以增加可用性，同样可以有效提升性能（减少中间节点可以减少数据的序列化与反序列化），并减少延时（可以减少网络传输耗时）。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;要缩短访问路径有一种办法，就是多个相互强依赖的应用合并部署在一起，把远程过程调用（RPC）变成 JVM 内部之间的方法调用。&lt;/em&gt;&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;依赖要尽量少&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所谓依赖，指的是要完成一次用户请求必须依赖的系统或者服务，这里的依赖指的是强依赖。&lt;/p&gt;
&lt;p&gt;举个例子，比如说你要展示秒杀页面，而这个页面必须强依赖商品信息、用户信息，还有其他如优惠券、成交列表等这些对秒杀不是非要不可的信息（弱依赖），这些弱依赖在紧急情况下就可以去掉。&lt;/p&gt;
&lt;p&gt;要减少依赖，我们可以给系统进行分级，比如 0 级系统、1 级系统、2 级系统、3 级系统，0 级系统如果是最重要的系统，那么 0 级系统强依赖的系统也同样是最重要的系统，以此类推。&lt;/p&gt;
&lt;p&gt;注意，0 级系统要尽量减少对 1 级系统的强依赖，防止重要的系统被不重要的系统拖垮。例如支付系统是 0 级系统，而优惠券是 1 级系统的话，在极端情况下可以把优惠券给降级，防止支付系统被优惠券这个 1 级系统给拖垮。&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;不要有单点&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;系统中的单点可以说是系统架构上的一个大忌，因为单点意味着没有备份，风险不可控，我们设计分布式系统最重要的原则就是“消除单点”。&lt;/p&gt;
&lt;p&gt;那如何避免单点呢？我认为关键点是避免将服务的状态和机器绑定，即把服务无状态化，这样服务就可以在机器中随意移动。&lt;/p&gt;
&lt;p&gt;如何那把服务的状态和机器解耦呢？这里也有很多实现方式。例如把和机器相关的配置动态化，这些参数可以通过配置中心来动态推送，在服务启动时动态拉取下来，我们在这些配置中心设置一些规则来方便地改变这些映射关系。&lt;/p&gt;
&lt;p&gt;应用无状态化是有效避免单点的一种方式，但是像存储服务本身很难无状态化，因为数据要存储在磁盘上，本身就要和机器绑定，那么这种场景一般要通过冗余多个备份的方式来解决单点问题。&lt;/p&gt;
&lt;h1 id=&#34;3如何才能做好动静分离有哪些方案可选&#34;&gt;3.如何才能做好动静分离？有哪些方案可选？
&lt;/h1&gt;&lt;p&gt;秒杀的场景中，对于系统的要求其实就三个字：快、准、稳。&lt;/p&gt;
&lt;h2 id=&#34;31-何为动静数据&#34;&gt;3.1 何为动静数据
&lt;/h2&gt;&lt;p&gt;那到底什么才是动静分离呢？所谓“动静分离”，其实就是把用户请求的数据（如 HTML 页面）划分为“动态数据”和“静态数据”。&lt;/p&gt;
&lt;p&gt;简单来说，“动态数据”和“静态数据”的主要区别就是看页面中输出的数据是否和 URL、浏览者、时间、地域相关，以及是否含有 Cookie 等私密数据。比如说：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;很多媒体类的网站，某一篇文章的内容不管是你访问还是我访问，它都是一样的。所以它就是一个典型的静态数据，但是它是个动态页面。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我们如果现在访问淘宝的首页，每个人看到的页面可能都是不一样的，淘宝首页中包含了很多根据访问者特征推荐的信息，而这些个性化的数据就可以理解为动态数据了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里再强调一下，我们所说的静态数据，不能仅仅理解为传统意义上完全存在磁盘上的 HTML 页面，它也可能是经过 Java 系统产生的页面，但是它输出的页面本身不包含上面所说的那些因素。也就是所谓“动态”还是“静态”，并不是说数据本身是否动静，而是数据中是否含有和访问者相关的个性化数据。&lt;/p&gt;
&lt;p&gt;还有一点要注意，就是页面中“不包含”，指的是“页面的 HTML 源码中不含有”，这一点务必要清楚。&lt;/p&gt;
&lt;p&gt;理解了静态数据和动态数据，我估计你很容易就能想明白“动静分离”这个方案的来龙去脉了。分离了动静数据，我们就可以对分离出来的静态数据做缓存，有了缓存之后，静态数据的“访问效率”自然就提高了。&lt;/p&gt;
&lt;p&gt;那么，怎样对静态数据做缓存呢？我在这里总结了几个重点。&lt;/p&gt;
&lt;p&gt;第一，你应该把静态数据缓存到离用户最近的地方。静态数据就是那些相对不会变化的数据，因此我们可以把它们缓存起来。缓存到哪里呢？常见的就三种，用户浏览器里、CDN 上或者在服务端的 Cache 中。你应该根据情况，把它们尽量缓存到离用户最近的地方。&lt;/p&gt;
&lt;p&gt;第二，静态化改造就是要直接缓存 HTTP 连接。相较于普通的数据缓存而言，你肯定还听过系统的静态化改造。静态化改造是直接缓存 HTTP 连接而不是仅仅缓存数据，如下图所示，Web 代理服务器根据请求 URL，直接取出对应的 HTTP 响应头和响应体然后直接返回，这个响应过程简单得连 HTTP 协议都不用重新组装，甚至连 HTTP 请求头也不需要解析。
&lt;img src=&#34;https://zhenyu0324.github.io/p/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E4%B8%8A/00.jpeg&#34;
	width=&#34;1366&#34;
	height=&#34;484&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E4%B8%8A/00_hu_f1d9ab586916a3d4.jpeg 480w, https://zhenyu0324.github.io/p/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E4%B8%8A/00_hu_d83ef0b581c3e28a.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;282&#34;
		data-flex-basis=&#34;677px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;第三，让谁来缓存静态数据也很重要。不同语言写的 Cache 软件处理缓存数据的效率也各不相同。以 Java 为例，因为 Java 系统本身也有其弱点（比如不擅长处理大量连接请求，每个连接消耗的内存较多，Servlet 容器解析 HTTP 协议较慢），所以你可以不在 Java 层做缓存，而是直接在 Web 服务器层上做，这样你就可以屏蔽 Java 语言层面的一些弱点；而相比起来，Web 服务器（如 Nginx、Apache、Varnish）也更擅长处理大并发的静态文件请求。&lt;/p&gt;
&lt;h2 id=&#34;32-如何做动静分离的改造&#34;&gt;3.2 如何做动静分离的改造
&lt;/h2&gt;&lt;p&gt;我以典型的商品详情系统为例来详细介绍。这里，你可以先打开京东或者淘宝的商品详情页，看看这个页面里都有哪些动静数据。我们从以下 5 个方面来分离出动态内容。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;URL 唯一化。商品详情系统天然地就可以做到 URL 唯一化，比如每个商品都由 ID 来标识，那么 &lt;a class=&#34;link&#34; href=&#34;http://item.xxx.com/item.htm?id=xxxx&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://item.xxx.com/item.htm?id=xxxx&lt;/a&gt; 就可以作为唯一的 URL 标识。为啥要 URL 唯一呢？前面说了我们是要缓存整个 HTTP 连接，那么以什么作为 Key 呢？就以 URL 作为缓存的 Key，例如以 id=xxx 这个格式进行区分。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分离浏览者相关的因素。浏览者相关的因素包括是否已登录，以及登录身份等，这些相关因素我们可以单独拆分出来，通过动态请求来获取。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分离时间因素。服务端输出的时间也通过动态请求获取。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;异步化地域因素。详情页面上与地域相关的因素做成异步方式获取，当然你也可以通过动态请求方式获取，只是这里通过异步获取更合适。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;去掉 Cookie。服务端输出的页面包含的 Cookie 可以通过代码软件来删除，如 Web 服务器 Varnish 可以通过 unset req.http.cookie 命令去掉 Cookie。注意，这里说的去掉 Cookie 并不是用户端收到的页面就不含 Cookie 了，而是说，在缓存的静态数据中不含有 Cookie。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;分离出动态内容之后，如何组织这些内容页就变得非常关键了。这里我要提醒你一点，因为这其中很多动态内容都会被页面中的其他模块用到，如判断该用户是否已登录、用户 ID 是否匹配等，所以这个时候我们应该将这些信息 JSON 化（用 JSON 格式组织这些数据），以方便前端获取。&lt;/p&gt;
&lt;p&gt;前面我们介绍里用缓存的方式来处理静态数据。而动态内容的处理通常有两种方案：ESI（Edge Side Includes）方案和 CSI（Client Side Include）方案。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;ESI 方案（或者 SSI）：即在 Web 代理服务器上做动态内容请求，并将请求插入到静态页面中，当用户拿到页面时已经是一个完整的页面了。这种方式对服务端性能有些影响，但是用户体验较好。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CSI 方案。即单独发起一个异步 JavaScript 请求，以向服务端获取动态内容。这种方式服务端性能更佳，但是用户端页面可能会延时，体验稍差。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;33-动静分离的几种架构方案&#34;&gt;3.3 动静分离的几种架构方案
&lt;/h2&gt;&lt;p&gt;前面我们通过改造把静态数据和动态数据做了分离，那么如何在系统架构上进一步对这些动态和静态数据重新组合，再完整地输出给用户呢？&lt;/p&gt;
&lt;p&gt;这就涉及对用户请求路径进行合理的架构了。根据架构上的复杂度，有 3 种方案可选：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实体机单机部署；&lt;/li&gt;
&lt;li&gt;统一 Cache 层；&lt;/li&gt;
&lt;li&gt;上 CDN。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;331-方案-1实体机单机部署&#34;&gt;3.3.1 方案 1：实体机单机部署
&lt;/h3&gt;&lt;p&gt;这种方案是将虚拟机改为实体机，以增大 Cache 的容量，并且采用了一致性 Hash 分组的方式来提升命中率。这里将 Cache 分成若干组，是希望能达到命中率和访问热点的平衡。Hash 分组越少，缓存的命中率肯定就会越高，但短板是也会使单个商品集中在一个分组中，容易导致 Cache 被击穿，所以我们应该适当增加多个相同的分组，来平衡访问热点和命中率的问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E4%B8%8A/01.jpeg&#34;
	width=&#34;1643&#34;
	height=&#34;1900&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E4%B8%8A/01_hu_ec650f46e7ed7d93.jpeg 480w, https://zhenyu0324.github.io/p/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E4%B8%8A/01_hu_f5c5ce871de70c91.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;86&#34;
		data-flex-basis=&#34;207px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;实体机单机部署有以下几个优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;没有网络瓶颈，而且能使用大内存；&lt;/li&gt;
&lt;li&gt;既能提升命中率，又能减少 Gzip 压缩；&lt;/li&gt;
&lt;li&gt;减少 Cache 失效压力，因为采用定时失效方式，例如只缓存 3 秒钟，过期即自动失效。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个方案中，虽然把通常只需要虚拟机或者容器运行的 Java 应用换成实体机，优势很明显，它会增加单机的内存容量，但是一定程度上也造成了 CPU 的浪费，因为单个的 Java 进程很难用完整个实体机的 CPU。&lt;/p&gt;
&lt;p&gt;另外就是，一个实体机上部署了 Java 应用又作为 Cache 来使用，这造成了运维上的高复杂度，所以这是一个折中的方案。如果你的公司里，没有更多的系统有类似需求，那么这样做也比较合适，如果你们有多个业务系统都有静态化改造的需求，那还是建议把 Cache 层单独抽出来公用比较合理。&lt;/p&gt;
&lt;h3 id=&#34;332-方案-2统一-cache-层&#34;&gt;3.3.2 方案 2：统一 Cache 层
&lt;/h3&gt;&lt;p&gt;所谓统一 Cache 层，就是将单机的 Cache 统一分离出来，形成一个单独的 Cache 集群。统一 Cache 层是个更理想的可推广方案，该方案的结构图如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E4%B8%8A/02.jpeg&#34;
	width=&#34;1643&#34;
	height=&#34;2065&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E4%B8%8A/02_hu_7923b325b096cc79.jpeg 480w, https://zhenyu0324.github.io/p/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E4%B8%8A/02_hu_5b1d77734795370.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;79&#34;
		data-flex-basis=&#34;190px&#34;
	
&gt;
将 Cache 层单独拿出来统一管理可以减少运维成本，同时也方便接入其他静态化系统。此外，它还有一些优点。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;单独一个 Cache 层，可以减少多个应用接入时使用 Cache 的成本。这样接入的应用只要维护自己的 Java 系统就好，不需要单独维护 Cache，而只关心如何使用即可。&lt;/li&gt;
&lt;li&gt;统一 Cache 的方案更易于维护，如后面加强监控、配置的自动化，只需要一套解决方案就行，统一起来维护升级也比较方便。&lt;/li&gt;
&lt;li&gt;可以共享内存，最大化利用内存，不同系统之间的内存可以动态切换，从而能够有效应对各种攻击。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这种方案虽然维护上更方便了，但是也带来了其他一些问题，比如缓存更加集中，导致：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Cache 层内部交换网络成为瓶颈；&lt;/li&gt;
&lt;li&gt;缓存服务器的网卡也会是瓶颈；&lt;/li&gt;
&lt;li&gt;机器少风险较大，挂掉一台就会影响很大一部分缓存数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;333-方案-3上-cdn&#34;&gt;3.3.3 方案 3：上 CDN
&lt;/h3&gt;&lt;p&gt;在将整个系统做动静分离后，我们自然会想到更进一步的方案，就是将 Cache 进一步前移到 CDN 上，因为 CDN 离用户最近，效果会更好。&lt;/p&gt;
&lt;p&gt;但是要想这么做，有以下几个问题需要解决。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;失效问题。前面我们也有提到过缓存时效的问题，不知道你有没有理解，我再来解释一下。谈到静态数据时，我说过一个关键词叫“相对不变”，它的言外之意是“可能会变化”。比如一篇文章，现在不变，但如果你发现个错别字，是不是就会变化了？如果你的缓存时效很长，那用户端在很长一段时间内看到的都是错的。所以，这个方案中也是，我们需要保证 CDN 可以在秒级时间内，让分布在全国各地的 Cache 同时失效，这对 CDN 的失效系统要求很高。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;命中率问题。Cache 最重要的一个衡量指标就是“高命中率”，不然 Cache 的存在就失去了意义。同样，如果将数据全部放到全国的 CDN 上，必然导致 Cache 分散，而 Cache 分散又会导致访问请求命中同一个 Cache 的可能性降低，那么命中率就成为一个问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;发布更新问题。如果一个业务系统每周都有日常业务需要发布，那么发布系统必须足够简洁高效，而且你还要考虑有问题时快速回滚和排查问题的简便性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;从前面的分析来看，将商品详情系统放到全国的所有 CDN 节点上是不太现实的，因为存在失效问题、命中率问题以及系统的发布更新问题。那么是否可以选择若干个节点来尝试实施呢？答案是“可以”，但是这样的节点需要满足几个条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;靠近访问量比较集中的地区；&lt;/li&gt;
&lt;li&gt;离主站相对较远；&lt;/li&gt;
&lt;li&gt;节点到主站间的网络比较好，而且稳定；&lt;/li&gt;
&lt;li&gt;节点容量比较大，不会占用其他 CDN 太多的资源。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最后，还有一点也很重要，那就是：节点不要太多。&lt;/p&gt;
&lt;p&gt;基于上面几个因素，选择 CDN 的二级 Cache 比较合适，因为二级 Cache 数量偏少，容量也更大，让用户的请求先回源的 CDN 的二级 Cache 中，如果没命中再回源站获取数据，部署方式如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E4%B8%8A/03.jpeg&#34;
	width=&#34;951&#34;
	height=&#34;946&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E4%B8%8A/03_hu_d083e3a5e8b9df03.jpeg 480w, https://zhenyu0324.github.io/p/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E4%B8%8A/03_hu_78489f678512b4b3.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;100&#34;
		data-flex-basis=&#34;241px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;除此之外，CDN 化部署方案还有以下几个特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;把整个页面缓存在用户浏览器中；&lt;/li&gt;
&lt;li&gt;如果强制刷新整个页面，也会请求 CDN；&lt;/li&gt;
&lt;li&gt;实际有效请求，只是用户对“刷新抢宝”按钮的点击。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;4二八原则有针对性地处理好系统的热点数据&#34;&gt;4.二八原则：有针对性地处理好系统的“热点数据”
&lt;/h1&gt;&lt;p&gt;假设你的系统中存储有几十亿上百亿的商品，而每天有千万级的商品被上亿的用户访问，那么肯定有一部分被大量用户访问的热卖商品，这就是我们常说的“热点商品”。&lt;/p&gt;
&lt;p&gt;那么问题来了：这些热点对系统有啥影响，我们非要关注这些热点吗？&lt;/p&gt;
&lt;h2 id=&#34;41-为什么要关注热点&#34;&gt;4.1 为什么要关注热点
&lt;/h2&gt;&lt;p&gt;我们一定要关注热点，因为热点会对系统产生一系列的影响。&lt;/p&gt;
&lt;p&gt;首先，热点请求会大量占用服务器处理资源，虽然这个热点可能只占请求总量的亿分之一，然而却可能抢占 90% 的服务器资源，如果这个热点请求还是没有价值的无效请求，那么对系统资源来说完全是浪费。&lt;/p&gt;
&lt;p&gt;其次，即使这些热点是有效的请求，我们也要识别出来做针对性的优化，从而用更低的代价来支撑这些热点请求。&lt;/p&gt;
&lt;h2 id=&#34;42-什么是热点&#34;&gt;4.2 什么是“热点”
&lt;/h2&gt;&lt;p&gt;热点分为热点操作和热点数据。所谓“热点操作”，例如大量的刷新页面、大量的添加购物车、双十一零点大量的下单等都属于此类操作。对系统来说，这些操作可以抽象为“读请求”和“写请求”，这两种热点请求的处理方式大相径庭，读请求的优化空间要大一些，而写请求的瓶颈一般都在存储层，优化的思路就是根据 CAP 理论做平衡，这个内容我在“减库存”一文再详细介绍。&lt;/p&gt;
&lt;p&gt;而“热点数据”比较好理解，那就是用户的热点请求对应的数据。而热点数据又分为“静态热点数据”和“动态热点数据”。&lt;/p&gt;
&lt;p&gt;所谓“静态热点数据”，就是能够提前预测的热点数据。&lt;/p&gt;
&lt;p&gt;所谓“动态热点数据”，就是不能被提前预测到的，系统在运行过程中临时产生的热点。例如，卖家在抖音上做了广告，然后商品一下就火了，导致它在短时间内被大量购买。&lt;/p&gt;
&lt;p&gt;由于热点操作是用户的行为，我们不好改变，但能做一些限制和保护，所以本文我主要针对热点数据来介绍如何进行优化。&lt;/p&gt;
&lt;h2 id=&#34;43-发现热点数据&#34;&gt;4.3 发现热点数据
&lt;/h2&gt;&lt;p&gt;前面，我介绍了如何对单个秒杀商品的页面数据进行动静分离，以便针对性地对静态数据做优化处理，那么另外一个关键的问题来了：如何发现这些秒杀商品，或者更准确地说，如何发现热点商品呢？&lt;/p&gt;
&lt;p&gt;你可能会说“参加秒杀的商品就是秒杀商品啊”，没错，关键是系统怎么知道哪些商品参加了秒杀活动呢？所以，你要有一个机制提前来区分普通商品和秒杀商品。&lt;/p&gt;
&lt;p&gt;我们从发现静态热点和发现动态热点两个方面来看一下。&lt;/p&gt;
&lt;h3 id=&#34;431-发现静态热点数据&#34;&gt;4.3.1 发现静态热点数据
&lt;/h3&gt;&lt;p&gt;如前面讲的，静态热点数据可以通过商业手段，例如强制让卖家通过报名参加的方式提前把热点商品筛选出来，实现方式是通过一个运营系统，把参加活动的商品数据进行打标，然后通过一个后台系统对这些热点商品进行预处理，如提前进行缓存。但是这种通过报名提前筛选的方式也会带来新的问题，即增加卖家的使用成本，而且实时性较差，也不太灵活。&lt;/p&gt;
&lt;p&gt;不过，除了提前报名筛选这种方式，你还可以通过技术手段提前预测，例如对买家每天访问的商品进行大数据计算，然后统计出 TOP N 的商品，我们可以认为这些 TOP N 的商品就是热点商品。&lt;/p&gt;
&lt;h3 id=&#34;432-发现动态热点数据&#34;&gt;4.3.2 发现动态热点数据
&lt;/h3&gt;&lt;p&gt;我们可以通过卖家报名或者大数据预测这些手段来提前预测静态热点数据，但这其中有一个痛点，就是实时性较差，如果我们的系统能在秒级内自动发现热点商品那就完美了。&lt;/p&gt;
&lt;p&gt;能够动态地实时发现热点不仅对秒杀商品，对其他热卖商品也同样有价值，所以我们需要想办法实现热点的动态发现功能。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;构建一个异步的系统，它可以收集交易链路上各个环节中的中间件产品的热点 Key，如 Nginx、缓存、RPC 服务框架等这些中间件（一些中间件产品本身已经有热点统计模块）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;建立一个热点上报和可以按照需求订阅的热点服务的下发规范，主要目的是通过交易链路上各个系统（包括详情、购物车、交易、优惠、库存、物流等）访问的时间差，把上游已经发现的热点透传给下游系统，提前做好保护。比如，对于大促高峰期，详情系统是最早知道的，在统一接入层上 Nginx 模块统计的热点 URL。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将上游系统收集的热点数据发送到热点服务台，然后下游系统（如交易系统）就会知道哪些商品会被频繁调用，然后做热点保护。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E4%B8%8A/04.jpeg&#34;
	width=&#34;1649&#34;
	height=&#34;1173&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E4%B8%8A/04_hu_b7862a9c4a29d71.jpeg 480w, https://zhenyu0324.github.io/p/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E4%B8%8A/04_hu_732474323910ead7.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;140&#34;
		data-flex-basis=&#34;337px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;我们通过部署在每台机器上的 Agent 把日志汇总到聚合和分析集群中，然后把符合一定规则的热点数据，通过订阅分发系统再推送到相应的系统中。你可以是把热点数据填充到 Cache 中，或者直接推送到应用服务器的内存中，还可以对这些数据进行拦截，总之下游系统可以订阅这些数据，然后根据自己的需求决定如何处理这些数据。&lt;/p&gt;
&lt;h2 id=&#34;44-处理热点数据&#34;&gt;4.4 处理热点数据
&lt;/h2&gt;&lt;p&gt;处理热点数据通常有几种思路：一是优化，二是限制，三是隔离。&lt;/p&gt;
&lt;p&gt;先来说说优化。优化热点数据最有效的办法就是缓存热点数据，如果热点数据做了动静分离，那么可以长期缓存静态数据。但是，缓存热点数据更多的是“临时”缓存，即不管是静态数据还是动态数据，都用一个队列短暂地缓存数秒钟，由于队列长度有限，可以采用 LRU 淘汰算法替换。&lt;/p&gt;
&lt;p&gt;再来说说限制。限制更多的是一种保护机制，限制的办法也有很多，例如对被访问商品的 ID 做一致性 Hash，然后根据 Hash 做分桶，每个分桶设置一个处理队列，这样可以把热点商品限制在一个请求队列里，防止因某些热点商品占用太多的服务器资源，而使其他请求始终得不到服务器的处理资源。&lt;/p&gt;
&lt;p&gt;最后介绍一下隔离。秒杀系统设计的第一个原则就是将这种热点数据隔离出来，不要让 1% 的请求影响到另外的 99%，隔离出来后也更方便对这 1% 的请求做针对性的优化。&lt;/p&gt;
&lt;p&gt;具体到“秒杀”业务，我们可以在以下几个层次实现隔离。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;业务隔离。把秒杀做成一种营销活动，卖家要参加秒杀这种营销活动需要单独报名，从技术上来说，卖家报名后对我们来说就有了已知热点，因此可以提前做好预热。&lt;/li&gt;
&lt;li&gt;系统隔离。系统隔离更多的是运行时的隔离，可以通过分组部署的方式和另外 99% 分开。秒杀可以申请单独的域名，目的也是让请求落到不同的集群中。&lt;/li&gt;
&lt;li&gt;数据隔离。秒杀所调用的数据大部分都是热点数据，比如会启用单独的 Cache 集群或者 MySQL 数据库来放热点数据，目的也是不想 0.01% 的数据有机会影响 99.99% 数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;5流量削峰这事应该怎么做&#34;&gt;5.流量削峰这事应该怎么做？
&lt;/h1&gt;&lt;p&gt;从业务上来说，秒杀活动是希望更多的人来参与的，也就是开始之前希望有更多的人来刷页面，但是真正开始下单时，秒杀请求并不是越多越好。因此我们可以设计一些规则，让并发的请求更多地延缓，而且我们甚至可以过滤掉一些无效请求。&lt;/p&gt;
&lt;h2 id=&#34;51-为什么要削峰&#34;&gt;5.1 为什么要削峰
&lt;/h2&gt;&lt;p&gt;为什么要削峰呢？或者说峰值会带来哪些坏处？&lt;/p&gt;
&lt;p&gt;我们知道服务器的处理资源是恒定的，你用或者不用它的处理能力都是一样的，所以出现峰值的话，很容易导致忙到处理不过来，闲的时候却又没有什么要处理。但是由于要保证服务质量，我们的很多处理资源只能按照忙的时候来预估，而这会导致资源的一个浪费。&lt;/p&gt;
&lt;p&gt;削峰的存在意义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一是可以让服务端处理变得更加平稳&lt;/li&gt;
&lt;li&gt;二是可以节省服务器的资源成本。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;52-排队&#34;&gt;5.2 排队
&lt;/h2&gt;&lt;p&gt;要对流量进行削峰，最容易想到的解决方案就是用消息队列来缓冲瞬时流量，把同步的直接调用转换成异步的间接推送，中间通过一个队列在一端承接瞬时的流量洪峰，在另一端平滑地将消息推送出去。在这里，消息队列就像“水库”一样， 拦蓄上游的洪水，削减进入下游河道的洪峰流量，从而达到减免洪水灾害的目的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E4%B8%8A/05.jpeg&#34;
	width=&#34;1134&#34;
	height=&#34;682&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E4%B8%8A/05_hu_795a6dc1c493a778.jpeg 480w, https://zhenyu0324.github.io/p/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E4%B8%8A/05_hu_9cbebfb9402f023d.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;166&#34;
		data-flex-basis=&#34;399px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;但是，如果流量峰值持续一段时间达到了消息队列的处理上限，例如本机的消息积压达到了存储空间的上限，消息队列同样也会被压垮，这样虽然保护了下游的系统，但是和直接把请求丢弃也没多大的区别。就像遇到洪水爆发时，即使是有水库恐怕也无济于事。&lt;/p&gt;
&lt;p&gt;除了消息队列，类似的排队方式还有很多，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;利用线程池加锁等待也是一种常用的排队方式；&lt;/li&gt;
&lt;li&gt;先进先出、先进后出等常用的内存排队算法的实现方式；&lt;/li&gt;
&lt;li&gt;把请求序列化到文件中，然后再顺序地读文件（例如基于 MySQL binlog 的同步机制）来恢复请求等方式。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看到，这些方式都有一个共同特征，就是把“一步的操作”变成“两步的操作”，其中增加的一步操作用来起到缓冲的作用。&lt;/p&gt;
&lt;h2 id=&#34;53-答题&#34;&gt;5.3 答题
&lt;/h2&gt;&lt;p&gt;你是否还记得，最早期的秒杀只是纯粹地刷新页面和点击购买按钮，它是后来才增加了答题功能的。那么，为什么要增加答题功能呢？&lt;/p&gt;
&lt;p&gt;这主要是为了增加购买的复杂度，从而达到两个目的。&lt;/p&gt;
&lt;p&gt;第一个目的是防止部分买家使用秒杀器在参加秒杀时作弊。2011 年秒杀非常火的时候，秒杀器也比较猖獗，因而没有达到全民参与和营销的目的，所以系统增加了答题来限制秒杀器。&lt;/p&gt;
&lt;p&gt;第二个目的其实就是延缓请求，起到对请求流量进行削峰的作用，从而让系统能够更好地支持瞬时的流量高峰。这个重要的功能就是把峰值的下单请求拉长，从以前的 1s 之内延长到 2s~10s。这样一来，请求峰值基于时间分片了。这个时间的分片对服务端处理并发非常重要，会大大减轻压力。而且，由于请求具有先后顺序，靠后的请求到来时自然也就没有库存了，因此根本到不了最后的下单步骤，所以真正的并发写就非常有限了。这种设计思路目前用得非常普遍，如当年支付宝的“咻一咻”、微信的“摇一摇”都是类似的方式。&lt;/p&gt;
&lt;p&gt;这里，我重点说一下秒杀答题的设计思路。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E4%B8%8A/06.jpeg&#34;
	width=&#34;942&#34;
	height=&#34;567&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E4%B8%8A/06_hu_99221c21fe772516.jpeg 480w, https://zhenyu0324.github.io/p/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E4%B8%8A/06_hu_9d2c8b26bddba7b8.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;166&#34;
		data-flex-basis=&#34;398px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;如上图所示，整个秒杀答题的逻辑主要分为 3 部分。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;题库生成模块，这个部分主要就是生成一个个问题和答案，其实题目和答案本身并不需要很复杂，重要的是能够防止由机器来算出结果，即防止秒杀器来答题。&lt;/li&gt;
&lt;li&gt;题库的推送模块，用于在秒杀答题前，把题目提前推送给详情系统和交易系统。题库的推送主要是为了保证每次用户请求的题目是唯一的，目的也是防止答题作弊。&lt;/li&gt;
&lt;li&gt;题目的图片生成模块，用于把题目生成为图片格式，并且在图片里增加一些干扰因素。这也同样是为防止机器直接来答题，它要求只有人才能理解题目本身的含义。这里还要注意一点，由于答题时网络比较拥挤，我们应该把题目的图片提前推送到 CDN 上并且要进行预热，不然的话当用户真正请求题目时，图片可能加载比较慢，从而影响答题的体验。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;验证的逻辑如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E4%B8%8A/07.jpeg&#34;
	width=&#34;1208&#34;
	height=&#34;299&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E4%B8%8A/07_hu_422a96c015449706.jpeg 480w, https://zhenyu0324.github.io/p/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E4%B8%8A/07_hu_cebce5079de4d1cd.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;404&#34;
		data-flex-basis=&#34;969px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;注意，这里面的验证逻辑，除了验证问题的答案以外，还包括用户本身身份的验证，例如是否已经登录、用户的 Cookie 是否完整、用户是否重复频繁提交等。&lt;/p&gt;
&lt;p&gt;除了做正确性验证，我们还可以对提交答案的时间做些限制，例如从开始答题到接受答案要超过 1s，因为小于 1s 是人为操作的可能性很小，这样也能防止机器答题的情况。&lt;/p&gt;
&lt;h2 id=&#34;54-分层过滤&#34;&gt;5.4 分层过滤
&lt;/h2&gt;&lt;p&gt;前面介绍的排队和答题要么是少发请求，要么对发出来的请求进行缓冲，而针对秒杀场景还有一种方法，就是对请求进行分层过滤，从而过滤掉一些无效的请求。分层过滤其实就是采用“漏斗”式设计来处理请求的，如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E4%B8%8A/08.jpeg&#34;
	width=&#34;1186&#34;
	height=&#34;1264&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E4%B8%8A/08_hu_5e6465771b1d3c4.jpeg 480w, https://zhenyu0324.github.io/p/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E4%B8%8A/08_hu_74b707339375c4c8.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;93&#34;
		data-flex-basis=&#34;225px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;假如请求分别经过 CDN、前台读系统（如商品详情系统）、后台系统（如交易系统）和数据库这几层，那么：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;大部分数据和流量在用户浏览器或者 CDN 上获取，这一层可以拦截大部分数据的读取；&lt;/li&gt;
&lt;li&gt;经过第二层（即前台系统）时数据（包括强一致性的数据）尽量得走 Cache，过滤一些无效的请求；&lt;/li&gt;
&lt;li&gt;再到第三层后台系统，主要做数据的二次检验，对系统做好保护和限流，这样数据量和请求就进一步减少；&lt;/li&gt;
&lt;li&gt;最后在数据层完成数据的强一致性校验。
这样就像漏斗一样，尽量把数据量和请求量一层一层地过滤和减少了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;分层过滤的核心思想是：在不同的层次尽可能地过滤掉无效请求，让“漏斗”最末端的才是有效请求。而要达到这种效果，我们就必须对数据做分层的校验。&lt;/p&gt;
&lt;p&gt;分层校验的基本原则是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将动态请求的读数据缓存（Cache）在 Web 端，过滤掉无效的数据读；&lt;/li&gt;
&lt;li&gt;对读数据不做强一致性校验，减少因为一致性校验产生瓶颈的问题；&lt;/li&gt;
&lt;li&gt;对写数据进行基于时间的合理分片，过滤掉过期的失效请求；&lt;/li&gt;
&lt;li&gt;对写请求做限流保护，将超出系统承载能力的请求过滤掉；&lt;/li&gt;
&lt;li&gt;对写数据进行强一致性校验，只保留最后有效的数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;分层校验的目的是：在读系统中，尽量减少由于一致性校验带来的系统瓶颈，但是尽量将不影响性能的检查条件提前，如用户是否具有秒杀资格、商品状态是否正常、用户答题是否正确、秒杀是否已经结束、是否非法请求、营销等价物是否充足等；在写数据系统中，主要对写的数据（如“库存”）做一致性检查，最后在数据库层保证数据的最终准确性（如“库存”不能减为负数）。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>白话法律笔记</title>
        <link>https://zhenyu0324.github.io/p/%E7%99%BD%E8%AF%9D%E6%B3%95%E5%BE%8B%E7%AC%94%E8%AE%B0/</link>
        <pubDate>Sat, 20 Feb 2021 11:40:52 +0800</pubDate>
        
        <guid>https://zhenyu0324.github.io/p/%E7%99%BD%E8%AF%9D%E6%B3%95%E5%BE%8B%E7%AC%94%E8%AE%B0/</guid>
        <description>&lt;h1 id=&#34;1-职场篇&#34;&gt;1 职场篇
&lt;/h1&gt;&lt;h2 id=&#34;11-创业未捷老板跑社保工资哪里讨&#34;&gt;1.1 创业未捷老板跑，社保工资哪里讨？
&lt;/h2&gt;&lt;p&gt;涉及职场的法律知识，劳动合同是重中之重。劳动合同是指员工和所在公司签订的确定劳动关系的合同，主要为了约定双方的权利和义务，因而对双方都具有约束力。劳动合同可以说是一个人在职场的“本命法宝”，从根本上保护着我们方方面面的权益。&lt;/p&gt;
&lt;p&gt;劳动合同的内容一般包括：&lt;/p&gt;
&lt;p&gt;试用期、工作期限、工作时间；&lt;/p&gt;
&lt;p&gt;工作岗位、工资待遇情况；&lt;/p&gt;
&lt;p&gt;有些还有保密条款和竞业限制；&lt;/p&gt;
&lt;p&gt;对于技术人员，现在的劳动合同还可能会涉及期权、股权激励等内容。&lt;/p&gt;
&lt;p&gt;关于保密问题和期权股权问题，我们以后会说到，现在可以不做多关注。&lt;/p&gt;
&lt;p&gt;但是，必须强调的是，和员工签订劳动合同是用人单位的法定责任。所以，任何找借口不签劳动合同的行为，不仅仅是耍“流氓”，更是违法的。当然，一旦由于种种原因确实没签成，只要员工有证据能证明确实工作过，也就是存在“事实劳动关系”，法律一样会认定为劳动关系进行并保护。只不过毕竟没有白纸黑字的证明，工资待遇等问题就比较被动了。&lt;/p&gt;
&lt;p&gt;而有的公司为了逃避法律责任，和员工签订的是劳务合同，试图变成平等主体间的法律关系。不过，实际上，我国法律对于劳动合同的认定，取决于双方真实的关系。如果双方构成了劳动关系，即使把名字写成劳务合同甚至随便叫什么合同，也是没用的，一样会被认定为劳动关系，员工自然同样受到《劳动合同法》的保护。&lt;/p&gt;
&lt;p&gt;这里我简单和你解释下，劳动合同和劳务合同的区别。劳动合同属于《劳动合同法》，规定双方在职责上有从属关系，属于人事关系，公司自然需要承担更多的责任；劳务合同属于《合同法》的范围，规定双方各自承担独立的责任，也就是刚刚提到的平等主体关系。&lt;/p&gt;
&lt;p&gt;另一个最为关注的，便是社会保险（区分于商业保险），简称社保，也就是通常所说的“五险一金”中的“五险”。“五险”包括养老保险、工伤保险、医疗保险、失业保险和生育保险，相关费用由公司和个人共同来出。其中公司需要交所有五项的费用，而个人只交养老、医疗和失业这三种种需要自已承担的部分”，所以有时候也叫做“三险一金”。&lt;/p&gt;
&lt;p&gt;要注意，社保具有强制性，公司不给你办理社保属于违法行为。另外，经常提到的“一金”则指住房公积金，通常作为公司的福利也会给交。&lt;/p&gt;
&lt;h2 id=&#34;12-保密还是卖身霸王条款怎么看&#34;&gt;1.2 保密还是“卖身”，霸王条款怎么看？
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;保密协议和竞业限制协议能约定永久期限吗？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;签了保密协议和竞业限制协议，但公司不支付任何费用，那这俩协议还有约束力吗？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果离职后使用在以前单位写的代码，到底算不算违法呢？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不管是保密协议还是竞业限制，都涉及到了商业秘密，也就是俗称的“商业机密”。商业秘密首先是秘密，秘密自然不能在社会上公开，不能被公众知晓，更重要的是，它能给公司方带来经济利益，具有商业价值，所以公司会采取相应的保密措施。&lt;/p&gt;
&lt;p&gt;商业秘密一般包括技术信息和经营信息这两种，技术信息包括源代码、设计图纸、生产配方、关键数据等等，经营信息则包括客户名单、营销策略、管理方法、货源信息等。&lt;/p&gt;
&lt;p&gt;公司为了保护商业秘密，通常会和员工在劳动合同中约定一些保密条款，或者是和员工另签一份保密协议。但是即使公司没有采取这些举措，员工也不能泄漏公司的商业秘密。&lt;/p&gt;
&lt;p&gt;因为，保密义务对于员工来说是法定的义务。&lt;/p&gt;
&lt;p&gt;如果泄漏了商业秘密，并因此给公司造成了经济损失，需要给公司赔偿。性质再严重点的，甚至可能会被追究刑事责任，已然属于侵犯商业秘密罪。&lt;/p&gt;
&lt;p&gt;说完商业秘密和保密协议，我们再来看看不那么熟悉的竞业限制。竞业限制其实是用人单位（通常包括企业、个体经济组织、国家机关、事业组织、社会团体等，以下简称单位）与部分员工针对离职后的新工作所做的限制，通常包括新工作的范围、地域还有期限等内容，目的也是为了保护商业秘密。&lt;/p&gt;
&lt;p&gt;这部分员工通常知晓本单位的商业秘密，一般包括三种人：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;对本单位的经营有重大影响的高级管理人员；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;掌握核心技术的高级技术人员；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其他有保密义务的人。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;竞业限制通常限定，这些人在离职后，在一定期限内不能去竞争对手家工作，比如那些生产同类产品的，经营同类业务的，或者有其他竞争关系的；也不能自己成为原单位的竞争对手，独自去生产同类产品或是经营同类业务。&lt;/p&gt;
&lt;p&gt;需要知道的是，竞业限制约定的期限&lt;strong&gt;不得超过二年&lt;/strong&gt;。即使协议中约定了再长的时间，超过两年的部分都是无效的。&lt;/p&gt;
&lt;p&gt;另外，员工在离职后履行了竞业限制协议里的义务，单位应当给一定的经济补偿。至于补偿金的数额，如果有约定好的数额和支付方式，就按约定来执行。&lt;/p&gt;
&lt;p&gt;如果没有明确约定，在竞业限制期限内，单位应按月给员工补偿，金额一般为员工离职前十二月的平均工资的 30%，比如说你离职前平均工资是每月 8000 元，补偿金就是每月 2400 元。而这笔钱如果低于当地的最低工资标准，则应该按照当地的最低工资标准来支付。&lt;/p&gt;
&lt;p&gt;协议签订后，若单位耍赖不给钱，达到一定期限后（注：各地规定不同，多为三个月）员工也是可以要求解除竞业限制的。若员工出尔反尔不守约定，也应该按照约定向单位支付违约金。&lt;/p&gt;
&lt;p&gt;记住，在竞业限制协议一事上，单位和员工双方都是既有权利，又有义务。&lt;/p&gt;
&lt;h2 id=&#34;13-致创业谁动了我的股权&#34;&gt;1.3 致创业：谁动了我的股权？
&lt;/h2&gt;&lt;p&gt;最近读到这么一句话：“朋友归朋友，生意归生意”。我对这句话颇有体会，一是源于自已的经历，二是平时办案的诸多感触。虽说每个人理解有所不同，但在我看来，主要还是说朋友之间不管有多么要好，多么亲密，合伙做生意还是要慎重。&lt;/p&gt;
&lt;p&gt;为什么这么说呢？对我个人而言，这方面最深的体会，就是自己大学刚毕业时，也曾和同学一起合伙做生意，结果因为一些事情没安排清楚，最后不但赔了钱，还伤害了友情。&lt;/p&gt;
&lt;p&gt;而从平常办案来看，我也接触了太多朋友翻脸的案例，本来是高高兴兴地开始合伙经营，最后却因各种纷争闹上了法庭，朋友也成了仇人。&lt;/p&gt;
&lt;p&gt;比如说，我一朋友老许就曾向我咨询过这么一件烦心事。&lt;/p&gt;
&lt;p&gt;老许是一名技术很牛的自动化工程师，在业界也有一定知名度。去年年初，他应好友小吴的邀请一起下海创业。初创业时，两个人也没签什么书面协议，只是粗略分工，并口头约定了“一起打天下、日后平分”。&lt;/p&gt;
&lt;p&gt;后来公司业务发展越来越好，也算是慢慢做起来了。但在需要签协议时却出了问题，两个人关于股权的分配产生了严重分歧。悬而未决的股权问题，成了老许一大块儿心病。&lt;/p&gt;
&lt;p&gt;两人的公司主要是这么个情况：&lt;/p&gt;
&lt;p&gt;公司最初的工商登记为小吴个人独资公司，老许加入后出资 30 万元，不过一直没签合同，也未做工商变更登记；&lt;/p&gt;
&lt;p&gt;公司管理上，老许负责产品和技术，小吴负责运营和财务；&lt;/p&gt;
&lt;p&gt;公司现有员工 30 多人，年净利润约为 200 万元。&lt;/p&gt;
&lt;p&gt;两人存在的争议主要在于：老许认为自己既出资 30 万元，又有技术出资，因此应该拥有一半股权；小吴则认为公司是自已创建的，老许最多占到 30% 股权。&lt;/p&gt;
&lt;p&gt;老许自认为吃了亏，但是两人又争执不下，该怎么办呢？&lt;/p&gt;
&lt;p&gt;刚入门就遇到这么大的争议，确实可见创业之路的坎坷。然而，老许需要解决的不仅是股权纠纷的问题，还有未来会面临的公司控制权、退出机制的问题。同样的，我们先来了解一下这些知识。&lt;/p&gt;
&lt;h3 id=&#34;131-法律知识&#34;&gt;1.3.1 法律知识
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;股权纠纷&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;关于股权方面的纠纷，比较常见的有股权确认纠纷、股东出资纠纷、股权转让纠纷等。其中：&lt;/p&gt;
&lt;p&gt;股权确认纠纷主要是确认股东资格的问题，通常还包括股东所占股权比例等内容。现实中比较常见的是代持股而引发的纠纷，隐名股东首先面对的就是股东资格问题。&lt;/p&gt;
&lt;p&gt;股东出资纠纷主要围绕股东是否按照股东协议、公司章程来履行出资义务而产生。现在成立公司时，并不要求实缴出资，也就是不用一次性交全资金，股东可以按照约定来分期出资，因此也产生了较多纠纷。&lt;/p&gt;
&lt;p&gt;股权转让纠纷主要是股权的转让问题，通常发生在股东和股东之间、股东和非股东之间。主要是指股权能不能转让、转让给谁、转让价格等问题发生的纠纷。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;公司控制权&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;控制权是指对公司的重大事项具有决定权，控制权的拥有者，一般是持股最高的人、或是事先协商好的人选。谁拥有控制权，谁就可以实际上控制公司。&lt;/p&gt;
&lt;p&gt;初创公司一般不存在这个问题，因为公司控制权都在创始人手中。当公司发展到一定规模时，有了董事的存在，对公司的控制主要就是对董事会的控制，所以创业者对控制权的转交要谨慎。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;股东退出问题&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;股东退出机制主要包括股东退出条件、股东退出的股权转让、股东退出的股权价值和股权的继承等问题。&lt;/p&gt;
&lt;p&gt;事实上，该问题主要依靠创始人对于股权分配的自行约定，有“五五分”、“成熟机制”等多种方案可作为参考。因为股东退出的问题会影响股权变更，进而涉及后期融资、投资等诸多情况，对公司能否平稳发展至关重要，所以应在初创阶段早早约定好。&lt;/p&gt;
&lt;p&gt;在股权转让方面，《公司法》有规定，股东之间可以相互转让全部或部分的股权。&lt;/p&gt;
&lt;p&gt;另外，股东也可以向股东之外的人进行转让，但向外部转让有一个前提：需要先通过书面的方式让其他股东知道你要转让。其他股东具有优先受让权，你可以理解为优先购买权。如果其他股东不购买，便可以向外部人员转让股权。&lt;/p&gt;
&lt;p&gt;特别注意的是，在没有书面通知的情况下，股权转让不具有法律效力。&lt;/p&gt;
&lt;h2 id=&#34;14-又见猝死工殇究竟是不是工伤&#34;&gt;1.4 又见猝死！工“殇”究竟是不是工伤？
&lt;/h2&gt;&lt;p&gt;听说程序员没有不加班的，不知道你是否经历过这样的场景？月明星稀，夜深人静，抽着根烟，睁大眼睛，寻找 bug。一旦找到 bug 位置，立刻扔掉烟头，在键盘上飞舞双手修改代码。消灭 bug 的心情很爽的，可代码是写不完的，bug 也是改不完的。如果长期下去，你的头发、腰椎、颈椎都还能受得了吗？&lt;/p&gt;
&lt;p&gt;比起这些问题，你可能还是会觉得，这是工作需要啊，没有办法，只能牺牲健康。但是，如果威胁到的是我们的生命，你还会这么想吗？&lt;/p&gt;
&lt;p&gt;前不久，南京一家医院的急诊中心就发生了这么一个悲剧。急诊中心半夜接诊了一位患者小王，因为胸口疼痛难忍而住院。尽管医院方面全力抢救，但突发大面积的心肌梗塞，最终还是夺走了小王的生命。&lt;/p&gt;
&lt;p&gt;后来经过医院的调查，才发现，小王虽然年纪轻轻刚刚 30 岁，但是身体一直属于亚健康状态。因为在外企做开发，他经常需要加班，最近一个月更是连续加班，天天熬夜，突发的心肌梗塞也跟这些脱不了关系。&lt;/p&gt;
&lt;p&gt;这样的例子并不少见，也非常可惜。毕竟人活着，才有一切可能，失去生命，没有了数字“1”，后面跟着再多的“0”都是没用的。工作健康问题真的不容忽视，毕竟身体是革命的本钱。另一方面，从我作为律师的角度来说，你也应该了解，一旦因为工作原因出了健康问题，到底要怎么办？公司究竟管不管？&lt;/p&gt;
&lt;h3 id=&#34;141-法律知识&#34;&gt;1.4.1 法律知识
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;工伤&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;首先来看第一个知识，工伤的定义。工伤，顾名思义，因为工作而受伤，一般主要有这么几种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;工作时间，在工作地点，因工作原因受到的伤害。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;工作时间前后，在工作地点，正在做相关的准备或收尾工作时受到的伤害。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;工作时间，在工作地点，履行工作职责时，受到的暴力等意外伤害。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因工外出期间，因工作原因受到的意外伤害、暴力伤害。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因工外出期间，因工作原因发生事故下落不明的，不管生死，都属于工伤。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;另外，特别强调的是，职业病和上下班途中的“机动车交通事故&amp;quot;都属于工伤。当然，机动车交通事故中，如果你本人不承担主要责任或全部责任时，受伤就属于工伤范围。&lt;/p&gt;
&lt;p&gt;职业病本身包含的范围太广，在这里我就不做详细说明了，有兴趣可以阅读《中华人民共和国职业病防治法》。而跟我们关系比较密切的几种工伤情况，稍后我都会讲到。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;工伤认定&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接下来我们再看第二个知识，工伤认定，也就是到劳动部门申请鉴定是否属于工伤。这里要注意的是，必须要有劳动部门出示证明，才能在法律上确认为工伤。而工伤认定本身，必须要由用人单位或者个人主动提出申请，才能够进行。没有申请，就没有认定。&lt;/p&gt;
&lt;p&gt;具体来看：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;通常，用人单位应该在，事故发生当天开始算起的 30 天内，向所在地的社会保障部门提出工伤认定申请；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果用人单位在 30 天内没有提出申请，那么受害者可以在事故发生起一年内，向单位所在地的人力资源和社会保障局提出申请。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;另外，用人单位没有在 30 天内提出申请的，在受伤者提出被认定为工伤时，这 30 天内的相关费用由用人单位承担。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;视同工伤&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第三个知识，我们来看，视同工伤，什么意思呢？其实就是原本不应该属于工伤，但是为了照顾员工的利益，法律上规定了一些情况也可以看成工伤对待，享受正常的工伤待遇。&lt;/p&gt;
&lt;p&gt;工伤的概念我们前面说了，主要是工作原因，而视同工伤更多是因为疾病引起的。因为发病原因是一般自身健康问题，我们又很难说清楚身体健康与工作的关系，自然也就难以界定是不是工伤。&lt;/p&gt;
&lt;p&gt;但是，员工发病死亡的例子实在不少见，给不少家庭也是带来了地震般的灾难。为了充分保护劳动者的利益，《工伤保险条例》对工伤认定做了扩展，把工作时突然发病死亡，或是发病后送到医院抢救无效，48 小时内死亡的情况，都认定为“视同工伤”。&lt;/p&gt;
&lt;p&gt;排除工伤认定
第四个知识，我来说一下排除工伤认定的情况。《工伤保险条例》规定了下面的几种情况，会被排除工伤认定：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;故意犯罪的情况；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;醉酒或者吸毒的情况；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;自残或者自杀的情况。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;也就是说，只要出现了这三种情况，不管其他情节是怎样的，都会被拒绝工伤认定以及视同工伤认定。&lt;/p&gt;
&lt;p&gt;不过，如果是工作期间，员工违反了工作流程，或者是疏忽大意、精力不集中等过失行为，造成了事故的，不属于上面三种情况，因此也不会影响工伤的认定。&lt;/p&gt;
&lt;p&gt;另外，如果用人单位聘用的是超过法定退休年龄的员工，工作时间、工作原因伤亡的，一样适用《工伤职险条例》的工伤认定，属于工伤的话，同样享受工伤保险待遇。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;工作保险待遇&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;工作保险待遇项目，主要有：治疗费、住院伙食补助费、康复治疗费、护理费、辅助器具费、一次性伤残补助金、伤残津贴、一次性伤残就业补助金、一次性工伤医疗被助金、一次丧葬被助金、抚恤金、一次性工亡补助金。一般要根据具体的工伤情况，判断可以享受哪些待遇。&lt;/p&gt;
&lt;h3 id=&#34;142-情景分析&#34;&gt;1.4.2 情景分析
&lt;/h3&gt;&lt;p&gt;第一个场景，因为连续加班，在工作时发病死亡，算不算工伤？如果是加班时发病死亡，就像我们开头故事里小王的情况，又算不算工伤呢？&lt;/p&gt;
&lt;p&gt;显然，因为加班，在工作时间发病死亡，视同工伤，享受工伤保险待遇。加班时间其实同样属于工作时间，发病死亡的也应视同工伤，享受工伤保险待遇。&lt;/p&gt;
&lt;p&gt;第二个场景，在工作中，突发脑溢血，送到医院抢救后，48 小时（两天）内死亡，算不算工伤？那如果是在医院抢救的 48 小时以后死亡，算不算工伤呢？&lt;/p&gt;
&lt;p&gt;前面提到过，工作中突然发病，如果送医院时没死，但抢救无效，48 小时内死亡的，视同工伤；而抢救无效，但超过 48 小时死亡的，就不能视同工伤了。你可能会疑惑，同样在工作时间发病然后抢救无效死亡，为什么 48 小时内就视同工伤，超过 48 小时就不算呢？&lt;/p&gt;
&lt;p&gt;其实这里的 48 小时，即使改成 72 小时，96 小时，依然不能覆盖所有人，只能说是根据现实情况，尽量地照顾到员工的利益，发病原因本身难说清楚，用人单位的成本自然也要考虑进去。另外，如果是在工作时发病但没有死亡的，不视为工伤，不能享受工伤待遇。&lt;/p&gt;
&lt;p&gt;另外要注意的是，第一、二场景提到的病，并不是职业病，主要是指自身原因造成的和工作无关的疾病。&lt;/p&gt;
&lt;p&gt;第三个场景，在上、下班途中，被汽车撞伤，算不算工伤？被自行车撞伤，算不算工伤？&lt;/p&gt;
&lt;p&gt;上、下班途中被机动车撞伤的，如果你无责任或者承担的是次要责任或同等责任的，那就属于工伤；但如果需要承担主要责任或是全部责任的，则不属于工伤。这里强调的是机动车，如果属于非机动车，比如说自行车、手推车，不管啥时候出事儿，也不管责任如何划分，都不属于工伤。&lt;/p&gt;
&lt;p&gt;第四个场景，也是很多程序员比较关心的问题，整天在公司加班写代码，回家也要继续写，整天久坐，得了颈椎病，算不算工伤呢？&lt;/p&gt;
&lt;p&gt;很遗憾，颈椎病目前还不能算工伤。《工伤保险条例》还没有拓展到这里，毕竟颈椎病只能算是普通病的范畴，连突发疾病没有死亡的都不算，更何况颈椎病呢。不管是颈椎病，还是高度近视、胃病，都很难划分为工伤，还是得靠我们自己注意健康，加强锻炼。&lt;/p&gt;
&lt;h2 id=&#34;15-期权的前世今生&#34;&gt;1.5 期权的“前世今生”
&lt;/h2&gt;&lt;p&gt;要说现在创业公司员工的两大迷雾，无非是相当火热的“股权”和“期权”。&lt;/p&gt;
&lt;h3 id=&#34;151-期权知识&#34;&gt;1.5.1 期权知识
&lt;/h3&gt;&lt;p&gt;“期权”，字面上可以理解为，你所期待的未来可能实现的某种权利。在一家公司里，你最期待的权利是什么呢？自然是股权。&lt;/p&gt;
&lt;p&gt;所以，期权，本质上是由公司或创始人书面承诺，在达成某项成就或者符合其他条件时，给某人一定比例的股权，让其可以成为公司的股东。&lt;/p&gt;
&lt;p&gt;期权的持有者，一般都是公司培养的核心员工，或是在业界有一定资源的管理人员。&lt;/p&gt;
&lt;p&gt;关于核心员工问题，公司为了留住优秀人才，会和员工签署期权协议。一般拿出一部分股权，以期权的形式给到员工手里。这种情况下，一般只要达到协议约定的行权条件（如工作年限、工作业绩等），员工就能获得股权，成为公司的实际股东。&lt;/p&gt;
&lt;p&gt;核心员工获得股权的方式通常有两种，取决于最初的约定。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一种是无偿得到股权；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;另一种是按协议约定的价格购买股权，当然，这个价格会远远低于市场价格。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于有资源的人才问题，这些人可能拥有高超的技术能力、丰富的管理经验，或是巨大的市场资源等，这些无形财富对创业公司尤为重要。所以，这些人在加入公司时，一般也会被授予期权，到一定的年限后则会无偿授予。&lt;/p&gt;
&lt;p&gt;其实除了上面这两种人才问题，还有一种情况，介于两者之间，可能也是我们很熟悉的一种模式。有些员工会选择去创业公司拿更低的工资，比如在其他大公司的工资是每月 6 万，而作为创业公司核心成员，只拿 3 万的月薪。&lt;/p&gt;
&lt;p&gt;这些人的目的也很明确，就是为了等待公司发展壮大，一旦条件成熟，就能转为股东，拿到股权。这样的附属条件，其实也是一种期权。&lt;/p&gt;
&lt;p&gt;目前，期权协议常见的行权期限是 4 年或 5 年，实现方式通常为分期行权，具体主要有这么两种方式。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一种是“一年一变更”，每满一年，按约定条件，把期权按比例转为股权。比如说约定了五年期限，而工作每满一年，你就可以把期权总额的 20% 转为股权，成为股东。满五年后，期权就全部转为股权了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一种是“两年一变更”，前两年按比例转换一次股权，剩下的满年限后再一次性全转完。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;16-裁员面前你能做的还有什么&#34;&gt;1.6 裁员面前，你能做的还有什么？
&lt;/h2&gt;&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;口头裁员真的有效吗？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果公司就这么拖着一直不签，能去新岗位就职吗？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;各种裁员形形色色，方式也是多种多样，并不都是法律条款规定里的模式。但是，一些基本的法律规定，我们还是必须了解的。再怎么多变的裁员，也都脱离不了法律上劳动合同的那些内容。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;161-劳动合同解除&#34;&gt;1.6.1 劳动合同解除
&lt;/h3&gt;&lt;p&gt;劳动合同解除，是指劳动合同约定的工作年限还不到，但双方协商或是任一方提出，要提前解除劳动关系，导致劳动合同提前终止，不再继续履行下去。&lt;/p&gt;
&lt;p&gt;一般情况下，按照方式不同，劳动合同解除可以分为三类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;协商解除；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;员工单方面解除；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;公司单方面解除。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解除方式不同，产生的法律后果也不同。接下来，我们就来看看这三种解除。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;协商解除&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;指公司和员工经过协商，达成一致意见，提前终止双方的劳动关系。这也是最常用的一种解除劳动合同的方式。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;员工单方面解除&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;员工单方面解除劳动合同，也就是我们通常所说的“辞职”。多数情况下，公司属于更强势的地位，所以，为了保护员工的权益，法律赋予了员工无理由解除合同的权利。&lt;/p&gt;
&lt;p&gt;也就是说，不管劳动合同有没有到期，公司有没有过错，员工都可以提前三十天，以书面形式通知公司解除劳合同。当然，如果是在试用期，员工只需要提前三天，书面通知给公司就可以了。&lt;/p&gt;
&lt;p&gt;另外，如果公司有过错，员工还享有法定的解除权。这种情况下，员工甚至不需要提前三十天通知，并且在提出解除劳动合同的同时，还可以索要经济补偿金。&lt;/p&gt;
&lt;p&gt;公司方面的过错，通常是指公司没有准时发工资，工资没发全，或没有依法给员工交社保等。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;公司单方面解除劳动合同&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;还是刚刚说过的，法律为了保护员工的权益，并不允许公司随意单方面解除劳动合同。只有发生下面三种情况，公司才可以解除。&lt;/p&gt;
&lt;p&gt;一是员工存在严重过错的情况。比如说员工不符合录用条件、在简历上弄虚作假、严重违反公司制度、严重失职或是犯罪等。这种情况下，公司不需要赔偿。&lt;/p&gt;
&lt;p&gt;二是员工没有过错，但是各种主、客观因素导致不能正常工作的情况。这里主要是指《劳动合同法》第四十条规定的三种情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;员工患病或受伤（非工伤），在规定的医疗期满后，不能从事原来的工作，也做不了公司另外安排的其他工作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;员工不能胜任工作，经过培训或调整工作岗位，仍然不能胜任。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;外部条件发生变化，跟签劳动合同时的情况有很大差别，导致劳动合同不能正常履行，并且双方协商也不能达成一致意见。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;三是特殊情况下的经济性裁员。看到裁员两个字，相信你的神经都紧绷了起来。这也是我们今天要学习的一个重点，法律意义上的裁员究竟是什么？你们公司的所谓裁员真的合法吗？接下来我们详细解读。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;经济性裁员&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;生活中，我们把某个公司集中、大规模地辞退员工叫做裁员，这其实只是一种笼统的称呼，并不准确。法律上的裁员，更准确应该叫做“经济性裁员”，属于公司单方面解除劳动合同，并且也是员工没有过错的情况。所以，法律对经济性裁员的条件和流程，有明确严格的规定。&lt;/p&gt;
&lt;p&gt;首先我们来看经济性裁员的含义。《劳动合同法》所称的经济性裁员，其实是指特殊情况下，公司进行的有人数限制的辞退行为。&lt;/p&gt;
&lt;p&gt;这里的特殊情况是指：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;公司依照破产法规定需要进行重整的；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;或者生产经营发生严重困难的；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;或企业转产、重大技术革新、经营方式调整的；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;或因劳动合同订立时客观情况发生重大变化，导致劳动合同不能继续履行的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里的人数限制是指，裁员在 20 人以上，或者不到 20 人，但占了员工总数 10% 以上。如果不符合这样的条件，并不能称为法律上的裁员。&lt;/p&gt;
&lt;p&gt;而公司裁员的流程，也有特定要求：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;要提前三十天，向工会或者全体职工说明情况，并听取意见。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;要向劳动行政部门报告裁减人员方案。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实际裁减人员，解除劳动合同。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不过要注意，这里的第二条“向劳动行政部门报告”，并不是必须得提前审批，而是一种事后或事前的报告行为，也就是要让劳动行政部门知道这件事。这样，必要时劳动行政部门可以采取监督措施，纠正违法行为，防止发生群体性维权事件。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;经济补（赔）偿&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果裁员已成定局，对于我们劳动者来说，最关心的就是补偿问题，也就是我们所说的经济补偿和经济赔偿。&lt;/p&gt;
&lt;p&gt;经济补偿金是公司解除劳动合同时，公司一次性给予员工的经济补偿，这是法律上的解释。&lt;/p&gt;
&lt;p&gt;我总结了下面四种情况，公司需要向员工支付经济补偿金：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;由公司提出，和员工协商，一致解除劳动合同。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由员工提出，理由是公司存在过错（比如没按时发够工资、没交社保），解除劳动合同。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由公司提前三十天提出，而员工并无过错，也就是上面讲到过的，公司单方面解除劳动合同的第二种：员工生病受伤、不能胜任工作、或情况发生重大变化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;经济性裁员。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;经济补偿金的标准按员工在公司的工作年限来算。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;每满一年，支付一个月工资；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;六个月以上不满一年的，按一年计算；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不满六个月的，向员工支付半个月工资。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以，如果你工作了 4 年，应该补偿 4 个月工资；如果工作了 4 年 8 个月，补偿 5 个月的工资；如果工作了 4 年 4 个月，则补偿 4.5 个月的工资。&lt;/p&gt;
&lt;p&gt;另外，如果公司违反法律规定解除劳动合同，公司要向员工支付经济赔偿金。经济赔偿金的标准是经济补偿金的两倍，也就是说，把刚刚计算出来的月份乘二就可以了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所谓的“N+1”补偿标准&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从 HR 那里或者在网上，你可能经常听到经济补（赔）偿的“N+1、N、2N”的说法。这些其实不是专门的法律术语，不过应用很广，在这里我也简单解释一下。&lt;/p&gt;
&lt;p&gt;“N”其实就是我们所说的经济补偿金，也就是符合那四种情况时，公司给你的补偿。比如说你工作 7 年，N 就是 7，你可以得到 7 个月的经济补偿。&lt;/p&gt;
&lt;p&gt;“N+1”的背景还是刚刚我们讲过的，公司单方面解除劳动合同的第二种：员工生病受伤、不能胜任工作、或情况发生重大变化。这里的“1”也被称为代通知金，不是法律上的专有名词，其实就是指这种情况下，因为没有提前 30 天通知而给的补偿。&lt;/p&gt;
&lt;p&gt;所以，在这样的背景下，公司如果没有提前 30 天通知员工，就需要额外支付 1 个月的工资。当然如果提前 30 天通知到了，就只需要按照 N 的方式，给相应的经济补偿金就可以了。&lt;/p&gt;
&lt;p&gt;“2N”指的是公司违法解除劳动关系的情况，一般有下面两种。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;法律明确规定了几种不能解除劳动关系的特殊情况，如果公司强行解除，就属于违法解除。比如在孕期、产期、哺乳期内，在规定的医疗期等特殊情况，就是违法解除。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;公司没有合法理由，也没有按照法定流程解除。这种情况一般不符合“N+1”的背景，也没有提前通知。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在这里，要特别注意两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;这里“N”按员工前 12 个月的平均工资计算；“1”按上个月的工资来算。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;N 和月工资的计算都有上限。公司经济补偿的工作年限，最高不超过 12 年；而员工月工资的标准，不高于公司所在地的年度职工平均工资的三倍，如果超过三倍，只按三倍计算。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;162-情景分析&#34;&gt;1.6.2 情景分析
&lt;/h3&gt;&lt;p&gt;第一个，口头裁员有效吗？&lt;/p&gt;
&lt;p&gt;我国《劳动合同法》明确规定，劳动合同的签订、变更、解除都需要用书面的形式，公司应用书面通知小蔡，而不能口头裁员。结合小蔡的描述，公司只是口头提出，但实际上双方没有解除劳动关系，劳动合同也继续生效。&lt;/p&gt;
&lt;p&gt;第二个，劳动关系存续期间，能否找新的工作，签新的劳动合同？&lt;/p&gt;
&lt;p&gt;虽然劳动关系继续，但是既然公司有裁员的意向，作为员工，提前找好新工作是无可厚非的，法律也不禁止。但在上一份劳动合同解除之前，尽量不要签新的劳动合同，否则会让自已陷入被动。&lt;/p&gt;
&lt;h2 id=&#34;17-加班工资休假你知道多少&#34;&gt;1.7 加班、工资、休假，你知道多少？
&lt;/h2&gt;&lt;h3 id=&#34;171-引子&#34;&gt;1.7.1 引子
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;加班待遇，你又了解多少呢？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;你真的清楚工资的构成吗？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;休假的具体规定，你是不是迷迷糊糊呢？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;172-法律知识&#34;&gt;1.7.2 法律知识
&lt;/h3&gt;&lt;p&gt;第一个概念，工资。工资是我们收入的主要组成部分，除此之外，员工的收入还包括家教费、翻译费等兼职所得，以及生育津贴等其他方面的收益。那法律上的工资是怎么定义的呢？&lt;/p&gt;
&lt;p&gt;《劳动合同法》里规定，公司要向员工及时支付足额的劳动报酬。劳动报酬分为三个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一是工资，包括基本工资、奖金、津贴、补贴等；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;二是实物报酬，包括公司发的各种物品或是提供的有价服务等；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;三是社会保险，主要就是我们所说的“五险”。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以我们法律上所讲的工资，是劳动报酬的一部分。这里需要注意的是，工资必须以货币的形式发放，不能用实物或其他有价证券的形式代替。&lt;/p&gt;
&lt;p&gt;特别补充一下不少人关心的试用期问题。法律规定，试用期的工资，不应该低于本公司相同岗位最低档工资或劳动合同约定工资的 80%，也不应该低于公司所在地的最低工资标准。&lt;/p&gt;
&lt;p&gt;第二个概念，加班。《劳动合同法》里规定，公司不得强迫或者变相强迫员工加班。如果公司安排加班，应该按照国家规定，向员工支付加班费。&lt;/p&gt;
&lt;p&gt;首先我们要了解加班时间的规定。我们实行的是 8 小时工作制，但并没有禁止公司安排 8 小时外的加班，只不过，法律上要求，公司安排加班，必须符合《劳动合同法》的限制性规定。&lt;/p&gt;
&lt;p&gt;法律规定，一般情况下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;每天安排的加班时间，不能超过 1 小时；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果因为特殊原因需要延长，在保障员工身体健康的条件下，每天不超过 3 小时；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每月安排的加班总时间，不能超过 36 小时；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;另外，公司不能安排未成年人、怀孕女员工以及哺乳期未满一年的女员工加班。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们还要了解加班费的规定。根据加班时间的不同，加班费的标准也不同。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;如果是普通工作日加班，公司应该 1.5 倍工资作为报酬；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果是休息日加班，公司应该发 2 倍工资作为报酬，或者可以选择补休；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果是法定节假日加班，公司应该发 3 倍工资作为报酬，不能选择调休来补偿。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第三个我们来看休假这个概念。休假也就是我们的假期，包括法定休假日、年休假、休息日、职工探亲假。其中我们熟悉的元旦、春节、五一劳动节、国庆节、中秋节等，都属于法定休假日。&lt;/p&gt;
&lt;p&gt;年休假，也就是我们通常所说的年假，是指员工每年可以享受的，保留工作和工资的一段连续休息时间。我国实行的是“带薪年休假”制度，也就是员工连续工作 1 年以上的，可以享受带薪休年假。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;根据《职工带薪年休假条例》规定，根据累计工作的时间，已满 1 年不满 10 年的，有 5 天带薪的年假；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;已满 10 年不满 20 年的，有 10 天带薪的年假；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;已满 20 年的，有 15 天带薪的年假。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;休息日就很好理解了，我们平时的双休日、调休的休息日、法定节假日之外的其他放假时间等，都属于休息日。而职工探亲假，好像大多数公司都没有，不过吧，这个福利如果也要给，估计好多老板都得哭了。所以，我们知道有这么个事就行了，也不要太过于计较。&lt;/p&gt;
&lt;h1 id=&#34;2-技术篇&#34;&gt;2 技术篇
&lt;/h1&gt;&lt;h2 id=&#34;21-今天你用vpn了吗&#34;&gt;2.1 今天你用“VPN”了吗？
&lt;/h2&gt;&lt;p&gt;今天我们就来讨论一下技术与法律的关系，一个典型就是“VPN”翻墙问题。我曾经见过这么一个案例，一家科技公司的开发工程师小李，因为公司业务要求，准备在网上搭建“VPN”服务器，然后卖翻墙软件和会员账号来赚钱。&lt;/p&gt;
&lt;p&gt;不过小李隐约感觉“VPN”是灰色地带，但又不太确定，所以来找我咨询。&lt;/p&gt;
&lt;p&gt;我给了小李怎样的答案呢？我们先来了解“VPN”相关的知识和规定，你就可以明白了。&lt;/p&gt;
&lt;h3 id=&#34;211-法律知识&#34;&gt;2.1.1 法律知识
&lt;/h3&gt;&lt;p&gt;“VPN”，即虚拟私人网络，是一种常用的安全通信方式。使用“VPN”软件连接外网，也就是通常所说的“翻墙”。&lt;/p&gt;
&lt;p&gt;过去有不少企业使用“VPN”来保护通信安全，防止泄露商业秘密。后来也有不少个人使用“VPN”来连接外网、获取信息，很多“VPN”软件商应运而生。&lt;/p&gt;
&lt;p&gt;但是，要注意的是，工信部曾明文规定，如果没有电信主管部门的批准，任何企业都不能自己建立或者租用“VPN”，开展跨境的经营活动。而对于有办公需要的外资企业和跨国企业，可以向合法的电信业务经营者来租用“VPN”。&lt;/p&gt;
&lt;p&gt;另外，私人“VPN”、经营“VPN”业务的公司，在我国也都是不合法的。&lt;/p&gt;
&lt;p&gt;2014 年网信办的成立，再次加大了监管的力度，“VPN”软件也更难存活。已经有很多的个人或公司因为销售“VPN”而被判刑，而且相当一部分人被指控为“提供侵入、非法控制计算机信息系统程序、工具罪”。因为这个罪名本身还有一些争议，在这里我不做过多讨论，你也不需要去记住它。但是，目前来看，私自搭建“VPN”并且售卖的行为，明显是违法的。&lt;/p&gt;
&lt;h3 id=&#34;212-情景分析&#34;&gt;2.1.2 情景分析
&lt;/h3&gt;&lt;p&gt;明白了这些，我们都清楚，小李自然不能接下这个任务。他应当明确拒绝，并说服老板，不然甚至可以考虑辞职了。因为，如果公司开展售卖“VPN”的业务，可能受到以下处罚。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;行政处罚&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;根据《互联网信息服务管理办法》的规定，开发“VPN”并对外销售，所有的违法收入都会被没收，还要交违法收入的 3 到 5 倍作为罚款。如果没有收入或者收入不到 5 万元，罚款为 10 万到 100 万元。情节严重的，网站也会被关闭。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;刑事处罚&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果“VPN”销售业务的经营数额达到 50 万元，或是非法收入达到 10 万元，那么相关经营者犯非法经营罪。&lt;/p&gt;
&lt;p&gt;而对于开发人员小李来说，如果他知道公司在做“VPN”的经营销售，还帮助公司搭建了服务器，就属于“知法犯法”。一旦公司行为构成了犯罪，小李就可能会被认定为“共同犯罪”，也就是“共犯”。&lt;/p&gt;
&lt;p&gt;当然，这一点并不能成为逃罪的借口，需要技术人员有合理的理由，证明自己“不知道也不应当知道”。&lt;/p&gt;
&lt;p&gt;这个界定，其实也就是我们所说的技术中立原则。&lt;/p&gt;
&lt;p&gt;技术中立，技术无罪，这话本身没任何问题。但要注意，这只是对技术本身的界定。就像我们说，一把刀作为工具本身是没有问题的，不管你买来是为了切菜剁肉还是打架砍人，都与生产厂商、刀具店的老板无关。但如果你明知某人要去寻仇，还送他一把刀，那就要另当别论了，你可能一不小心就是“共犯”了。&lt;/p&gt;
&lt;p&gt;我们要知道，《刑法》处罚的不是“物体”，而是人。开发人员是不是有罪，要看开发者主观心理状态和客观情况分析，如果明知或应当知道技术是用来犯罪的，却依然参与开发，就可能要承担法律责任了。&lt;/p&gt;
&lt;h2 id=&#34;22-漏洞在眼前可以悄悄破解吗&#34;&gt;2.2 漏洞在眼前，可以悄悄破解吗？
&lt;/h2&gt;&lt;h3 id=&#34;231-法律知识&#34;&gt;2.3.1 法律知识
&lt;/h3&gt;&lt;p&gt;首先我们来看，“非法获取计算机信息系统数据罪”这个罪名。罪名很长，你可以重点先记住前四个字，“非法获取”，跟我们后面讲到的另一个罪名做个区分。&lt;/p&gt;
&lt;p&gt;非法获取计算机信息系统数据罪是指违反国家规定，&lt;/p&gt;
&lt;p&gt;侵入计算机信息系统，注意这里是指除了国家事务、国防建设、尖端科学技术领域这三点外的其他领域。&lt;/p&gt;
&lt;p&gt;或者获取计算机信息系统数据。&lt;/p&gt;
&lt;p&gt;并且，符合“情节严重”这一特点的行为。&lt;/p&gt;
&lt;p&gt;在这里，我要重点解释几个概念。&lt;/p&gt;
&lt;p&gt;首先，这里的“计算机信息系统数据”是指计算机里存储、处理、传输的数据，不仅包括了计算机系统数据和应用程序，还包括了你在计算机里存放的各种个人信息。&lt;/p&gt;
&lt;p&gt;但是脱离了计算机存放的数据，比如光盘、U 盘中的计算机数据，不适用于这个罪名。比如说，别人 copy 你的 U 盘，然后把里面的信息数据转手在网上卖出去，或者是进行其他操作，就不属于这个罪了。&lt;/p&gt;
&lt;p&gt;第二，本罪里面的“情节严重”指的是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;获得10 组以上的网络金融服务的身份认证信息，包括支付结算、证券交易、期货交易等；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;获得500 组以上的其他内容的身份认证信息；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非法控制了20 台以上的计算机系统；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非法收入达到5000 元以上；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;造成经济损失达到10000 元以上。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上的五个情节，只要达到了一点，就要追究刑事责任了。通常会被判处三年以下的有期徒刑或者拘役，可能会有罚金。严重点的，可能就是三年到七年的大牢了。&lt;/p&gt;
&lt;p&gt;特别注意的是，违法收入只要达到 5000 元就构成了犯罪，而且即使你没赚钱，只要给公司造成了 10000 元以上的经济损失也同样构成犯罪。&lt;/p&gt;
&lt;p&gt;另外，非法获取计算机信息系统数据罪有明确的范围界定，指的就是我们普通的商业或者工业范围，不包括国家事务、国防建设、尖端科学技术领域这三个领域。那如果你触碰的是这三个领域的计算机系统呢？&lt;/p&gt;
&lt;p&gt;一定要特别注意我接下来要讲的，这三个领域万万碰不得！一旦你对国家事务、国防建设或是尖端科学技术领域的计算机做小动作，会犯另一个很严重的罪名，非法侵入计算机信息系统罪。&lt;/p&gt;
&lt;p&gt;这个罪名的重点，你也可以记住前四个字，“非法侵入”。“侵入”二字，一听就比“获取”正式、严重得多。事实上也是这样，我们前面所说的非法获取计算机信息系统数据这个罪名，本质上是因为你入侵系统后的其他操作，比如操纵系统、copy 或贩卖数据、或者传播等，也就是我们所说的“情节严重”的行为。&lt;/p&gt;
&lt;p&gt;而非法侵入计算机信息系统罪不考虑后果，属于行为犯（也就是以某个行为作为判罪的标准），侵入即犯罪！这里的“侵入”，是指没有国家部门的授权或批准，非法获取口令或许可证明后，冒充合法使用者，进入国家系统或者截收数据的行为。有些人甚至把自己的计算机和国家系统联网，同样犯罪。&lt;/p&gt;
&lt;p&gt;事实上，如果侵入了这些领域，一般会被处三年以下的有期徒刑或者拘役。&lt;/p&gt;
&lt;h2 id=&#34;23-爬虫真的合法吗&#34;&gt;2.3 “爬虫”真的合法吗？
&lt;/h2&gt;&lt;h3 id=&#34;231-法律知识-1&#34;&gt;2.3.1 法律知识
&lt;/h3&gt;&lt;p&gt;首先我来解释跟信息相关的两个重要概念。&lt;/p&gt;
&lt;p&gt;开头说到的骚扰电话，主要是因为获取了我们的一些个人信息，也就是法律上所讲的“公民个人信息”。公民个人信息，指以电子或者其他方式记录，能单独或结合其他消息，识别出某人身份或者反映某人活动情况的信息，包括姓名、身份号码、各种联系方式、住址、账号密码、财产状况和行踪轨迹等。&lt;/p&gt;
&lt;p&gt;第二个概念，侵犯公民个人信息罪，任何单位和个人，违反国家有关规定，获取、出售或者提供公民个人信息，情节严重的，都构成犯罪。而且罪名判定跟是否获利无关，只要你提供给了别人，不管你有没有获利，情节严重的都属于刑事犯罪。&lt;/p&gt;
&lt;p&gt;如果是在履行职责或者在提供服务的过程中，获取到的个人信息，再出售或者提供给别人，更是会从重处罚。&lt;/p&gt;
&lt;p&gt;接下来，我们来看商业方面的一个概念，不正当竞争。不正当竞争的定义来自于《反不正当竞争法》，指经营者违反本法规定，损害其他经营者的合法权益，扰乱社会经济秩序的行为。&lt;/p&gt;
&lt;p&gt;需要注意的是，不正当竞争的定罪对象是“经营者”，不管你是否有合法的营业执照，只要从事商品经营或者营利性服务的单位和个人，都属于这个范围。&lt;/p&gt;
&lt;h3 id=&#34;232-情景分析&#34;&gt;2.3.2 情景分析
&lt;/h3&gt;&lt;p&gt;第一个，骚扰电话的信息问题。这些信息的获得，除了传统模式，也就是管理人员的违法泄漏外，更多的是利用网站漏洞，通过爬虫获取，然后传播或者出售。&lt;/p&gt;
&lt;p&gt;这种“爬虫”的出发点就是为了获利，被不法分子用来推销或诈骗，而且信息本身也都属于隐私，显然构成了侵犯公民个人信息罪。&lt;/p&gt;
&lt;p&gt;第二个，用软件传播爱奇艺的付费视频，利用的是爱奇艺的市场资源。他们基本不用付出什么成本，就凭借着提供跟爱奇艺相同的视频体验，获得了内容上的竞争优势。&lt;/p&gt;
&lt;p&gt;他们虽然没有直接把视频卖钱，但是未经爱奇艺的授权获取了视频资源，并且他们获得的流量和广告费用，也都是基于这种优势。这种行为显然违背了诚实公平的商业伦理，也破坏了市场秩序，抢占了爱奇艺的市场机会，损害其利益。所以他们的行为已经属于不正当竞争。&lt;/p&gt;
&lt;h3 id=&#34;233-其他&#34;&gt;2.3.3 其他
&lt;/h3&gt;&lt;p&gt;爬虫在我看来，本质仍是一种工具，一种用机器人代替人手操作、搜集信息提高效率的工具。既然是工具，就像我在前面说到过的“菜刀无罪”的例子，技术本身没问题。究竟是怎么获取到的数据，获取数据范围是什么，以及把数据用来做什么，才是爬虫与信息的合法性问题的关键。&lt;/p&gt;
&lt;p&gt;那么，根据《中华人民共和国网络安全法》和一些相应的案例，在这里简单总结一下我的看法。&lt;/p&gt;
&lt;p&gt;第一，如果你爬取信息，严格遵守“Robots 协议”，没有任何越权的行为，搜集的也是公开可以查询的非隐私级的信息。&lt;/p&gt;
&lt;p&gt;另外，需要强调的是，“Robots 协议”本身并没有法律效力，但在行业内大家基本都会遵守，法院的判案也越发看重这一点。所以这类爬虫不难理解，没有恶意，也并不攫取非公开类的信息，虽然有时会遭到反感，但是并不违法，也是互联网发展必须的技术。&lt;/p&gt;
&lt;p&gt;第二，如果你爬虫获取信息，是为了证明被爬公司的数据造假，其获取的数据也都是通过公开渠道可以查询的，那么，在获取信息后公布于众的行为并不违法，也不侵犯被爬公司的民事权益。但是，如果你爬取公开免费的信息，是用来进行违法操作，比如造假、诽谤等，就有隐患了。&lt;/p&gt;
&lt;p&gt;第三，如果你利用爬虫获取其他公司的公开信息数据，用于自身公司的经营。而被爬公司的信息是投入了大量人力、财力，经过常年积累获得的，并且被爬公司本身也采取了反爬措施。这种情况下，虽然信息是公开的，但信息本身具有较高的商业价值，能够给使用者带来商业利益，此时的爬虫也是违法的。&lt;/p&gt;
&lt;p&gt;第四，如果你未经平台授权，强行突破反爬措施，导致被爬网站的运行受到严重影响，这种行为明显是违法的，这里涉及的就是我们上一个技术篇讲到的破解犯罪了。&lt;/p&gt;
&lt;p&gt;第五，如果你是第三方应用，想要通过开放平台获取用户信息时，更要注意授权问题。从用户对平台的授权、平台对第三方的授权、再到用户对第三方的授权，三重关卡都要通过才合法。&lt;/p&gt;
&lt;p&gt;这些都是常见的爬虫使用和获取信息的问题。其实，除了技术人员的非法获取，我们自身信息被泄露的情况很是恶劣，购房信息、网购信息、住宿记录、车辆信息等都可能会遇到。&lt;/p&gt;
&lt;h2 id=&#34;24-非法集资到底是个啥&#34;&gt;2.4 非法集资到底是个啥？
&lt;/h2&gt;&lt;p&gt;我们平常所说的非法集资，其实本身并不是一个确切的罪名。非法集资问题，一般会涉及到两种刑事犯罪，非法吸收公众存款罪和集资诈骗罪，我们习惯性都叫做非法集资类犯罪。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;非法吸收公众存款罪&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;非法吸收公众存款，也就是俗称的“非吸”，是指没有经过中国人民银行批准，面向社会大众而不是特定的人吸收资金，并且出具凭证，承诺会在一定期限内，还本金、付利息，或是支付其他有价值的财产。&lt;/p&gt;
&lt;p&gt;也就是说，你想要向社会大众征集钱财，必须要有中国人民银行的批准，才是合法的。&lt;/p&gt;
&lt;p&gt;另外注意，这里说到的是中国人民银行，可不是中国银行或者其他哪家银行。中国人民银行，其实是国务院的组成部门，属于正部级单位。&lt;/p&gt;
&lt;p&gt;事实上，你所知道的那些投资担保公司、财富集团等，不管名字有多高大上，一般都是没有经过中国人民银行批准的。所以不管他们说得天花乱坠，用什么形式让你的财富增值，你都得谨慎点。天上掉下来的可能不是馅饼，而是陷阱。贪图高利息、高回报，很有可能就是血本无归了。&lt;/p&gt;
&lt;p&gt;另外，对于非法吸收公共存款，法律上定罪的起点是比较低的。比如说，个人非吸的数额达到 20 万以上，或是单位非吸的数额在 100 万以上，就构成了犯罪，可以追究刑事责任了。&lt;/p&gt;
&lt;p&gt;不过呢，这类问题的真实情况是，受害人一般都是“不暴雷就不报案”。早期很少有人报案，也不容易被发现，所以往往捅出来就是群体性事件，出现“集体维权”的现象。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;集资诈骗罪&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;集资诈骗，这个其实更可恶，集资诈骗的人本质就是骗子，他们一般用各种欺骗手段来集资，比如说，虚构资金用途、提供虚假文件、或是谎称高回报率等。不同于非吸，集资诈骗的目的就是骗钱，一开始就没打算要还给受害者。&lt;/p&gt;
&lt;p&gt;其实非吸和集资诈骗并没有那么严格的界限，一旦发生下面这四种情况，就已经是集资诈骗了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;携带集资款跑路的；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;挥霍乱花集资款，导致集资款不能还给用户的；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用集资款做违法犯罪的事儿，导致无力还款的；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;或者存在其他欺骗手段，最终导致造成无力还款的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;集资诈骗罪定罪的起点更低，个人集资诈骗的数额达到 10 万，或是单位集资诈骗达到 50 万，就构成了犯罪。但也是同样的规律，不到最后一刻，很少有人报案。其实很容易理解，利益面前的冒险罢了。冒险不是错，但前提是你真的清楚风险有多大。&lt;/p&gt;
&lt;p&gt;另外，非法吸收公众存款罪和集资诈骗罪虽然手法相似，可量刑的差别就大了去了。&lt;/p&gt;
&lt;p&gt;非法吸收公众存款罪的最高刑期是 10 年。哪怕是你涉及的钱财有几个亿，只要定罪为非吸，判刑最高不超过十年。&lt;/p&gt;
&lt;p&gt;而集资诈骗罪的最高刑期是无期徒刑，以前还有更重的死刑，后来被废除了。但这并不意味着，刑罚变轻了，因为你一不小心可能就是无期徒刑。比如说，某个人做集资诈骗，一旦数额在 100 万元以上，就属于定罪条件里的“数额特别巨大”，量刑的话，基本就是十年以上或者无期了。&lt;/p&gt;
&lt;h2 id=&#34;25-黄色网站不仅仅是黄色罪名&#34;&gt;2.5 黄色网站？不仅仅是“黄色”罪名
&lt;/h2&gt;&lt;h3 id=&#34;251-法律知识&#34;&gt;2.5.1 法律知识
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;淫秽物品&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;淫秽物品，也就是我们通常所说的色情物品，是指具体描绘性行为，或者露骨宣扬色情的物品，通常有淫秽书刊、影片、录像带、录音带、图片等形式。&lt;/p&gt;
&lt;p&gt;不过要注意区分的是，下面两种情况，并不算淫秽物品。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;有关人体生理、医学方面的科学作品，不能算淫秽物品。我们常说医生眼中无男女，也正是因为生理知识不等于色情知识。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一些文学、艺术作品，虽然有一些色情内容，但本身有艺术价值，也不能算淫秽物品。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;传播淫秽物品罪 、传播淫秽物品牟利罪&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;明白了淫秽物品到底指什么，我们再来看看相关的罪名。日常生活中，最常见的罪名有两个，一个是传播淫秽物品罪，另一个就是传播淫秽物品牟利罪。&lt;/p&gt;
&lt;p&gt;传播淫秽物品罪，重点在于“传播”二字。传播上面提到书图影音在内的淫秽物品，情节严重的就会被定罪。情节严重主要包括这么几种情况：&lt;/p&gt;
&lt;p&gt;次数多：多次地、经常地传播淫秽物品。&lt;/p&gt;
&lt;p&gt;数量大：传播的淫秽物品数量比较大，比如说视频 40 个以上，就达到定罪条件了。&lt;/p&gt;
&lt;p&gt;受众广：虽然传播淫秽物品的次数不多、数量不大，但观看、浏览人数很多，造成严重后果多，也符合定罪条件。&lt;/p&gt;
&lt;p&gt;涉及未成年：在未成年人中传播，造成严重后果的等等。&lt;/p&gt;
&lt;p&gt;传播淫秽物品牟利罪，从名字上就可以看出，“传播”和“牟利”都是重点。&lt;/p&gt;
&lt;p&gt;根据相关的司法解释，我可以列举几个比较常见的情况，给你做个区分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;视频内容：单纯传播 40 个以上达到定罪条件，盈利传播 20 个以上达到定罪条件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;音频内容：单纯传播 200 个以上达到定罪条件，盈利传播 100 个以上达到定罪条件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;图片、短信、文章：单纯传播 400 个以上达到定罪条件，盈利传播 200 个以上达到定罪条件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实际点击数：单纯传播的点击数 20000 次以上达到定罪条件，盈利传播的点击数 10000 次以上达到定罪条件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;也就是说，在定罪门槛上，涉及盈利的传播淫秽物品牟利罪，比传播淫秽物品罪更低。&lt;/p&gt;
&lt;p&gt;那么相对应的，在惩罚上，传播淫秽物品牟利罪的量刑，也要比传播淫秽物品罪重得多。一般情况下，传播淫秽物品罪判刑最高是二年，而传播淫秽物品牟利罪，最高可能会判无期徒刑。&lt;/p&gt;
&lt;p&gt;当然，如果你想了解更具体的定罪标准，可以查看《最高人民法院、最高人民检察院关于办理利用互联网、移动通讯终端、声讯台制作、复制、出版、贩卖、传播淫秽电子信息刑事案件具体应用法律若干问题的解释》。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;互联网群组确责问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最后，我来说说，互联网的群组确责问题。2017 年 10 月 8 日，国家出台了《互联网群组信息服务管理规定》。这个规定一出来，我立刻就把自已建的好几个 QQ 群给解散了。&lt;/p&gt;
&lt;p&gt;为啥呢？我们来看看这个规定，你就明白了。规定的名字很长，你不用背下来，记住这两句话就是了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;谁建群谁负责&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;谁管理谁负责&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两点，基本就是这个规定的核心内容了。也就是说，在群里有犯法活动，不但发布者要负责，群主、管理员也都要承担一定的法律责任。&lt;/p&gt;
&lt;p&gt;我们平时所说的微信群、QQ 群、贴吧、支付宝群等，都属于这个规定里的互联网群组。比方说，有人在贴吧发黄色图片、违法信息，不仅贴吧要被解散，群主也就是这个贴吧的吧主，同样可能会受罚。&lt;/p&gt;
&lt;p&gt;这也就是我解散群的主要原因了，没时间管，也不愿承担那么大的责任。这几年，群组可以算是传播淫秽物品的一个主要场所了，群主一定要清楚自己的责任，看客也得注意自已的行为分寸。&lt;/p&gt;
&lt;h2 id=&#34;26-外挂真能大吉大利吗&#34;&gt;2.6 外挂真能大吉大利吗？
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;虽然我是一名律师，天天跟各色案件打交道，但在面对某些刑事案件时，也经常很无奈。比方说，曾经轰动全国的“内蒙古玉米案”。&lt;/p&gt;
&lt;p&gt;内蒙古的一个农民王力军，因为“无证收购粮食”被判缓刑，后来在各方努力下，再审才平反，最终无罪释放。如果你感兴趣，可以自己上网搜一下。&lt;/p&gt;
&lt;p&gt;老实讲，在这之前，我还真不知道，农村随处可见的收粮食行为竟然是违法的，甚至还构成了刑事犯罪。而这个被认定的罪名，正是我们今天学习的主角，被认为是“管得最宽”“啥都能装的口袋罪”——非法经营罪，这个饱受争议的罪名。&lt;/p&gt;
&lt;p&gt;听着很陌生，感觉跟你没啥关系？别急，我先给你看这么一个案件，让你感受一下“非法经营罪”。&lt;/p&gt;
&lt;p&gt;网游你应该不会陌生，像是很火的“吃鸡”“王者荣耀”这些，即使没玩过，也一定听说过。相应的“开挂”这个词，说的就是游戏中使用外挂的人。&lt;/p&gt;
&lt;p&gt;这个案件就是关于外挂的故事。某技术公司先后开发了两款网游，都拿到了国家版权局颁发的《计算机软件著作权登记证书》。游戏上市后火爆异常，玩家众多，小韩就是其中一员。&lt;/p&gt;
&lt;p&gt;不过不同其他玩家，小韩还是个技术大牛。为了快速升级，他编写了用 SG 命名的外挂程序，使游戏角色可以自动寻路、自动交接任务，还可以同时开启多个客户端窗口，甚至向服务器提供伪造数据。&lt;/p&gt;
&lt;p&gt;账号快速升级的同时，小韩也看到了商机。他开始在游戏论坛上发帖，售卖他的外挂程序。因为外挂功能强大，价格也不贵，小韩很快赚到了 30 多万元。&lt;/p&gt;
&lt;p&gt;结果正如你想的，小韩最后也是因为“非法经营罪”锒铛入狱。非法经营究竟是个什么罪名呢？我们先来了解一下。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;非法经营罪&lt;/strong&gt;
非法经营罪，顾名思义，是指违反国家规定，故意从事非法经营，严重扰乱市场秩序的行为。这里的非法经营行为，主要包括下面几种情节：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;未经许可经营特定物品，比如专营、专卖物品或其他限制买卖的物品；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;买卖进出口许可证、进出口原产地证明以及其他法律、行政法规规定的经营许可证或者批准文件；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从事其他非法经营活动，并且严重扰乱市场秩序。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;看到这些定义是不是有晕头转向的感觉？没关系，这个罪名确实包罗万象，这些定义也不需要你背下来，我来给你慢慢解释。&lt;/p&gt;
&lt;p&gt;非法经营罪在过去其实叫作“投机倒把罪”，家里的老一辈应该都不会陌生。非法经营罪最大的盲点在于最后一条，也就是《刑法》规定的这个“其他严重扰乱市场秩序的非法经营行为”，如果情节严重，就会构成非法经营罪。&lt;/p&gt;
&lt;p&gt;到底什么叫“其他严重扰乱市场秩序的非法经营行为”呢？&lt;/p&gt;
&lt;p&gt;事实上，这个还真不好说。非法经营罪对犯罪行为的界定，随着时间的推移也一直在发生变化。&lt;/p&gt;
&lt;p&gt;从 1987 年到现在，起码有几十种行为都被收入其中。具体的非法经营行为，种类实在太多，我就不一一列举了，在有关部门的通知、解释、规定里都有体现，如果你有兴趣可以自己查一查。&lt;/p&gt;
&lt;p&gt;非法经营罪在我们业界被称为“口袋罪”，言外之意就是，经营触犯到刑法时，很多行为都可以用这个罪名来定罪。当然，这也造成了重罚，很多行为本来用行政、治安处罚就够了，最后却因此被追究了刑事责任。虽然很多案件都得到了纠正，但是这个影响确实不容小觑。&lt;/p&gt;
&lt;h2 id=&#34;27-谁修改了我的积分资产&#34;&gt;2.7 谁修改了我的积分资产？
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;利用这些网站的漏洞，修改积分获利是否违法？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果违法，有什么后果呢？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其它方式，比如利用工作便利，获得积分再提现，又会怎样呢？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;网络虚拟财产&lt;/strong&gt;
网络虚拟财产跟我们平常所说的财产有什么关系呢？&lt;/p&gt;
&lt;p&gt;其实，法律上的财产，一般指的就是货币，或者其他可以用货币兑换的物品。所以前面学过的房子、车子、存款，都属于这个范围。&lt;/p&gt;
&lt;p&gt;而网络虚拟财产，尤其是我们接触比较多的网络游戏中的虚拟财产，主要包括账号等级、游戏装备、游戏币和积分等。这些东西大多是玩家花费大量时间、精力和金钱得到的，自然具有价值，同时一般也能用货币兑换（比如账号转卖、设备转卖、提现等），所以也是一种财产。&lt;/p&gt;
&lt;p&gt;所以，不管是虚拟财产还是其他财产，都受到法律的保护。恶意侵占别人的财产，就可能会涉及职务侵占罪或盗窃罪。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;职务侵占罪&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;职务侵占罪，指单位员工，利用职务便利，非法占用单位大额财产的行为。根据这个定义，我们也能看出，这个罪名的三个客观要素：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;利用自己职务的便利，不管是直接还是间接方式都算数；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有侵占的行为，不管是侵吞、偷窃还是骗取，非法私有化的行为都属于非法占用；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;财产数额比较大，如果数额比较小的也不能算作职务侵占，最低数额一般在 5000 到 20000 左右。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;另外要注意，这里的单位和员工，不包括国家机关、事业单位等，也不包括国家工作人员，国家工作人员如果有同样的行为，属于贪污罪。&lt;/p&gt;
&lt;p&gt;换句话说，职务侵占罪，适用的是非国家财产发工资的人。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;盗窃罪&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;顾名思义，盗窃一般是指秘密窃取别人的东西，并占为己有的行为。不过，随着时代的发展，秘密窃取四个字你可以看成是通俗的说法，因为我们生活中大张旗鼓的盗窃事件也不少，所以盗窃不一定是秘密的手段。&lt;/p&gt;
&lt;p&gt;盗窃的东西自然有一定的经济价值，而构成盗窃罪，对于数额也有一定的要求。
职务侵占罪，其实大多还是因为公司管理不到位，给某些特殊岗位的员工留了漏洞，创造了违法的条件。不管因为什么原因起了贪念，走错一步就是犯罪之路。&lt;/p&gt;
&lt;h2 id=&#34;28-如何看待从删库到跑路&#34;&gt;2.8 如何看待“从删库到跑路”？
&lt;/h2&gt;&lt;p&gt;&amp;ldquo;rm -rf /&amp;ldquo;应该是你非常熟悉的命令行，也是删库的罪魁祸首。“从删库到跑路”，大概是技术人，无人不知无人不晓的段子。你可能会心一笑，可能哈哈大笑，但是，这个几秒钟的简单操作，真的能像玩笑那么轻松吗？&lt;/p&gt;
&lt;p&gt;当然不。你可能觉得这是玩笑，但是国外真有人这么干过。荷兰的一家云主机商 Verelox，就曾经历过这样的惨剧，离职工程师把客户数据库给删了，公司几经修复，也不能恢复全部数据，最终造成了巨大的损失。&lt;/p&gt;
&lt;p&gt;这种时候，删库，或者说删数据的行为，还是玩笑吗？当然不是，是犯罪呀！&lt;/p&gt;
&lt;p&gt;不管国外还是国内，这样的恶意删除数据的行为，毫无疑问，不仅仅是泄愤，更是刑事犯罪。犯的什么罪呢？&lt;strong&gt;破坏计算机信息系统罪。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我想重点讲的，是你可能会疑惑的一点，删除数据为什么不属于财产性犯罪，比如故意毁坏财物罪？&lt;/p&gt;
&lt;p&gt;你可能觉得奇怪，数据对于公司来说有非常高的价值，甚至是公司的核心竞争力。破坏了公司的数据，基本就是破坏了公司的重要财产，为什么被定为破坏计算机信息系统罪呢？&lt;/p&gt;
&lt;p&gt;其实，这还是因为，数据目前还不属于法律上承认的“财产”，前面我们讲到过，虚拟财产可以与货币兑换，所以属于法律上的财产。但数据本身并不能兑换货币，所以还不属于这个范围。&lt;/p&gt;
&lt;p&gt;但是随着数据的价值越来越高，财产属性也确实在增强。起码在我看来，未来更健全的法制社会，一定会出台相关法律，承认数据的财产属性。那时候，再出现“删库事件”，估计就是故意毁坏财物罪了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;故意毁坏财物罪&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;故意毁坏财物罪，非常容易理解，主要有这么几个要素：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;主观上是故意或者恶意的；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;行为上毁灭或是损坏他人（公司或个人）的财物；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;后果是上造成的损失数额较大，或者存在其他严重情节。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;显然，这种罪往往是因为某些目的，想泄私愤、打击报复导致的。不过，这里要区分开，如果某人的目的是为了占有或盗窃，哪怕手段上可能损坏了财物，并不算是故意毁坏财物罪，而是要追究目的涉及的犯罪，比如侵占罪或盗窃罪。&lt;/p&gt;
&lt;p&gt;另外，如果毁坏的是法律规定的一些特定财物，罪名可能会严重很多。比如，损坏了交通设备、电力煤气燃气、交通工具等的话，可能就是危害公共安全类的犯罪，后果很严重的直接就是死刑了。&lt;/p&gt;
&lt;p&gt;最后，再来简单说一下，对于后果严重性的判断。&lt;/p&gt;
&lt;p&gt;“数额较大”，是指造成 5000 元以上的损失，就可以追究刑事责任。其实还有一种“数额巨大”的情况，指的是造成 5 万元以上的损失，会被判 3 年以上 7 年以下有期徒刑。&lt;/p&gt;
&lt;p&gt;“其他严重情节”，法律上明确规定的有这么几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;三次以上毁坏财物的行为；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;纠集三人以上，公然毁坏财物；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;毁坏重要物品；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;毁坏手段特别恶劣；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;动机卑劣并嫁祸他人等等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;再有，如果后果危害到了公共安全，可能也要追究危害公共安全的犯罪，比如放火、爆炸这些行为，判罪更重。&lt;/p&gt;
&lt;p&gt;了解了“数额较大”和“其他严重情节”的具体含义，你可能会想，如果损失达不到 5000 元，还会受惩罚吗？&lt;/p&gt;
&lt;p&gt;不幸地说，自然是会的。我国《治安管理处罚法》第四十九条就规定了，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;盗窃、诈骗、哄抢、抢夺、敲诈勒索或者故意损毁公私财物，拘留 5 天到 10 天，并处五百元以下罚款；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;情节较重的，拘留 10 到 15 天，并处一千元以下罚款。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;请注意，这个规定并没有数额的要求，说白了，只要你有故意毁坏他人财物的行为，轻一点的会被拘留、罚款，重一点的就是蹲大牢了。&lt;/p&gt;
&lt;h2 id=&#34;29-伪基站是你的避风港吗&#34;&gt;2.9 “伪基站”是你的避风港吗？
&lt;/h2&gt;&lt;p&gt;提到“伪基站”，有的人可能还比较陌生，但是说起伪基站干的那些事儿，估计就没人不知道了。&lt;/p&gt;
&lt;p&gt;比如说，开车多年的老司机们，最熟悉的，应该就是车里的广播吧，要说最讨厌的，那一定就是在某个地段碰上“黑广播”了。黑广播，一般就是因为这些地方放了伪基站。&lt;/p&gt;
&lt;p&gt;再比如说，我们更熟悉的，手机上的垃圾短信，你一定也见过不少。什么某某淘宝商家的广告，银行的账款通知，航班取消通知或者中奖通知等等，这些大多也是靠伪基站，进行诈骗和骚扰。&lt;/p&gt;
&lt;p&gt;光说伪基站做了些什么，你可能还会觉得，唉，挺有用啊，可以用来致富发家啊！但是，要知道了伪基站的法律严重性，这念头就一定会打消了。&lt;/p&gt;
&lt;p&gt;举个例子，前两年，我就曾办理过这么一起案件。年轻人小秦在京务工，先后换过几份工作，可都没能满足他赚大钱的心愿。后来，经过狐朋狗友的介绍，小秦听说了搞伪基站项目赚钱来得快，就入手了一台。&lt;/p&gt;
&lt;p&gt;小秦主要通过 QQ 群来接业务，然后活跃在四环五环的大街小巷里，背个基站骑个电动车到处跑，帮雇主发送“交通银行银行卡升级”等信息。日赚数千元，确实收入不菲。&lt;/p&gt;
&lt;p&gt;不过，因为每天都有不少人上当受骗报案，警方也注意到了此事。北京公安成立了专案小组，抓到了小秦，并在小秦的帮助下，抓捕了远在福建的雇主犯罪团伙。&lt;/p&gt;
&lt;p&gt;其实，直到此时，小秦也还是懵懵懂懂的，他觉得自己只是用伪基站、发了点假消息，竟然会有这么严重的后果？&lt;/p&gt;
&lt;p&gt;要说起这伪基站的罪行，估计能说个一天一夜都停不下来。今天，我们主要先来看看，法律上，使用伪基站要承担什么后果。&lt;/p&gt;
&lt;h3 id=&#34;291-法律知识&#34;&gt;2.9.1 法律知识
&lt;/h3&gt;&lt;p&gt;基站本身必须通过批准，才能设立运营。伪基站，顾名思义，伪造隐蔽的基站，说白了就是一种非法的无线电通信设备，既没有取得“电信设备进网许可”，也没有获得“无线电发射设备型号核准”。&lt;/p&gt;
&lt;p&gt;作为基站的虚假仿制品，伪基站有搜取附近手机信息的功能，还能强行向一定范围内的不特定用户手机发送短信。这个过程，会屏蔽正常基站的信号，非法占用公众正常的移动通信频率，局部阻断移动通信的网络信号。&lt;/p&gt;
&lt;p&gt;在 2014 年 3 月 14 日前，我国对设立“伪基站”、发送垃圾短信的行为，惩处的力度还不够。那会儿，我们只能按照，无线电管理条例中的“擅自设置、使用无线电台 (站)”，这一条例来处理，而惩罚措施，也只有查封或没收设备、没收非法收入。&lt;/p&gt;
&lt;p&gt;只有那些情节严重的，才会有 1000 元以上、5000 元以下的罚款。而那些利用“伪基站”犯罪的，也只有实施了确定的诈骗或是其他犯罪行为，才能以诈骗或其他犯罪的名义，进行刑事处罚。&lt;/p&gt;
&lt;p&gt;但事实上，非法生产、销售、使用“伪基站”设备，破坏的自然不仅仅是电信秩序。这不但会影响电信运营商的正常经营，严重扰乱市场秩序，也会危害通信安全和公共安全。&lt;/p&gt;
&lt;p&gt;哪怕对我们普通用户来说，也是不小的灾难。谁愿意看到一堆垃圾短信啊，一不小心点进去，甚至还有病毒危害。如果你家里有老人和小孩的话，一定对此感受更深。可以说，手机的正常使用，个人的财产权益，个人隐私利益，都受到了极大威胁，简直就是社会毒瘤。&lt;/p&gt;
&lt;p&gt;所以，2014 年 3 月 14 日，最高人民法院、最高人民检察院、公安部、国家安全部，联合出台了《关于依法办理非法生产销售使用“伪基站”设备案件的意见》。&lt;/p&gt;
&lt;p&gt;这个文件中，明确了非常重要的一点：非法生产、销售、使用“伪基站”的违法犯罪行为，可以依法按照 8 项罪名追究刑事责任。这 8 项罪名分别是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;非法经营罪；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;破坏公用电信设施罪；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;诈骗罪；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;虚假广告罪；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非法获取公民个人信息罪；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;破坏计算机信息系统罪；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;扰乱无线电通讯管理秩序罪；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非法生产销售间谍专用器材罪。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;至此，伪基站的犯罪后果，明显严重了很多。我们也就不难理解小秦被抓这件事了。&lt;/p&gt;
&lt;h2 id=&#34;210-网络诈骗真的离你很远吗&#34;&gt;2.10 “网络诈骗”真的离你很远吗？
&lt;/h2&gt;&lt;p&gt;不管是利用伪基站，还是破解密码、盗取后台数据的技术犯罪，我们都讲了不少内容。就像我经常强调的那样，技术犯罪的本质，是使用某个技术做的事情有不良影响，而非技术本身违法。最常见的这些技术犯罪，或多或少都涉及到了网络诈骗。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;网络诈骗手法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;网络诈骗，其实是抱着非法占有的目的，通过互联网虚构事实或者隐瞒真相，进行财物骗取的行为。&lt;/p&gt;
&lt;p&gt;由于网络诈骗的空间性、虚拟性都很强，即使受骗人报案，警方的侦查难度也非常大。犯罪手法更是多种多样，层出不穷：有冒充公安、法院、检察院、律师事务所的；有冒充淘宝、京东各种交易平台的；甚至还有充秦始皇后人的等等。&lt;/p&gt;
&lt;p&gt;目前，针对高智商群体的犯罪，主要有下面几类情况。&lt;/p&gt;
&lt;p&gt;第一类，主要是利用先进技术进行的诈骗活动。比较常见的有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;通过伪基站发送假的银行链接；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;发送假邮件，植入木马盗取账号信息；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;盗取联系人方式和社交信息，冒充亲友领导骗取财物；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;利用虚拟账号，冒充公安、检察、法院、税务等执法部门进行诈骗。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第二类，主要是利用受害人心理进行诈骗。比较常见的有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;发放招嫖卡片，冒充年轻女孩进行诈骗；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;发放招嫖信息，在受害人上钩后，进行敲诈勒索甚至抢劫（仙人跳）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;冒充黑社会进行敲诈勒索；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;偷拍偷录，然后作为证据恐吓并且敲诈等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;更可恨的是，骗子们的手法翻新还特别快，基本上每过一段时间就会销毁罪证，换另外一个旗号进行诈骗。即使抓到人，他们一般也是死不认账，如果不把明晃晃的证据摆到他们跟前，他们基本一概否认。这也是刑侦难度极大的重要原因。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;网络诈骗的刑罚&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当然，社会不会允许任何法外恶事的存在。法律上对于诈骗罪的惩罚相对较重。《刑法》第二百六十六条就规定了诈骗罪的惩罚，具体包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果诈骗数额较大，处三年以下有期徒刑、拘役或者管制，可以并处或单处罚金；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果诈骗数额巨大或有其他严重情节，处三年以上十年以下有期徒刑，并处罚金；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果诈骗数额特别巨大或有其他特别严重情节，处十年以上有期徒刑或无期徒刑，并处罚金或没收财产。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里我解释一下，诈骗罪中对于数额的认定：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;诈骗达到 2 千元以上，属于“数额较大”；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;诈骗达到 3 万元以上，属于“数额巨大”；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;诈骗达到 20 万元以上，属于“数额特别巨大”。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以你看，2000 元以上的诈骗，就已经是可以判刑的诈骗罪，比我们前面讲过的很多罪名门槛更低。&lt;/p&gt;
&lt;h1 id=&#34;3-生活篇&#34;&gt;3 生活篇
&lt;/h1&gt;&lt;h2 id=&#34;31-智斗中介北上广租房图鉴&#34;&gt;3.1 智斗中介：“北上广”租房图鉴
&lt;/h2&gt;&lt;p&gt;最近接连爆出的“隔断间”“毒房子”事件，把房屋中介再次推到了风口浪尖上。然而事实上，“租房黑”从来就不是个新鲜词儿。从大学毕业到现在，我们很多人都租过房，都和中介打过交道，也都难免遇到过不同程度、不同类型的黑心中介。&lt;/p&gt;
&lt;p&gt;可这么多年过去了，这类问题依然是屡禁不止，“悲剧”更是重复上演。显然，咱们不能总是在问题尖锐爆发后，才开始重视如何去解决。所谓防患于未然，今天，我就来说说关于租房应该注意的那些事儿。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;租赁合同&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们先来了解下法律上的一个名词——“租赁合同”。租赁合同，或称租赁协议，是指出租人和承租人关于租赁物的协议。在这里，出租人指的是把东西租出去的人，承租人是要租别人东西的人，这个被租出去的东西也就是租赁物。&lt;/p&gt;
&lt;p&gt;通常，出租人把租赁物租出去后，承租人要支付租金，才可以按约定的用途来使用，或是获得收益，而约定时间到了后，再把东西还给出租人。&lt;/p&gt;
&lt;p&gt;我们所说的租房合同，也就是法律上的房屋租赁合同，便属于租赁合同的一种，只不过租赁物特指房子。同样的定义下，房东、中介或者二房东作为出租人，可以把房子出租给我们，我们作为承租人，按约定用途使用，也就是可以居住或者经商，同时支付租金，到期还房就行。&lt;/p&gt;
&lt;p&gt;至于黑心中介，法律上并没明确的定义，根据我的经验，主要可以粗略分为两种情况，一种是“黑中介”、一种是“中介黑”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;黑中介&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;“黑中介”，本身属于不正规中介。一般他们发布虚假信息来忽悠租客，后期会用“暴力”“恐吓”等手段威胁租客，强行要钱。&lt;/p&gt;
&lt;p&gt;这些人要么用一个山寨的公司名字发布信息，实际上没有经过工商登记，也没有营业执照，属于无照经营；要么公司虽然在工商登记过，但没在建委备案，所以没有租赁资质，也是不合法的。&lt;/p&gt;
&lt;p&gt;不得不说，现在“黑中介”们的法律意识还挺强，违法的隐蔽性也很高。他们大都打着“民事纠纷”的幌子来行动，也不惧怕出了事会有民事诉讼。因为“黑中介”基本是“三无产品”，就是为了让你诉讼无门。即使“诉讼有门”，到最后也是啥都得不到，毕竟对方估计只是个空壳而已。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;中介黑&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那些有营业执照，也有租赁资质的正规中介。按理来说他们属于“白中介”的存在，但这群人黑起来却也是一点不手软。&lt;/p&gt;
&lt;p&gt;比如臭名昭著的“毒房子”事件，便是知名的“中介黑”问题。借用赵本山小品的一句经典台词，别人租房要的是钱，他们却有可能是要的是命！虽然这属于少数事件，但像是强制收费、合同欺诈这样的行为，也是屡见不鲜。&lt;/p&gt;
&lt;p&gt;“黑中介”和“中介黑”，二者名字很相似，其实存在的很多问题也相同，除去前者不正规后者正规外，他们在行为处事上并没有太大的界限。所以接下来我还是合并为黑心中介的情况来说，遇到差别较大、需要关注的地方，我也会特别强调。&lt;/p&gt;
&lt;p&gt;那么你想想，黑心中介的常用手法 有哪些呢？根据接触过的案例，我总结了一些例子给你作为防范：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;虚构房源信息，骗取定金或押金后（通常只随手写个收据条）直接失踪；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;玩合同游戏，拿合同条款的漏洞来多收费；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;以各种理由强制收费或者加价，来逼迫租客搬走；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;正常收费入住后，“黑中介”人间蒸发，真正房东来收房赶人（多见于“黑中介”）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;故意挖坑让你违约，并找各种理由不退押金。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;租房四要&lt;/strong&gt;
第一，要从正规中介租房。&lt;/p&gt;
&lt;p&gt;第二，要查验房产信息。要记得主动提出查看房子的产权信息，比如房产证这类证件，正规出租都应该有产权信息；另外要看出租期是否在房主授权给中介的权限内。&lt;/p&gt;
&lt;p&gt;第三，要实地看房。这一点特别重要。我也建议要找朋友一起去看房，最好是有租房经验的朋友，这样既是给自己壮胆，也能避免一个人的慌张和疏忽。这里要看的东西就比较多了：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;看中介承诺的信息和实际房屋是否一致，如地理位置、房间构造、居住条件等；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查清楚房子本身的水电燃气费是否有拖欠，免得平白无故揽一身债；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对房子里的原有物品要有明确说明，清点并检查是否有损坏，如果发现问题，赶紧拍照反馈，并记录为物品交割单。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第四，要注意“二房东”问题。若是从二房东手里租的房，要弄清楚这人是否得到了房主的授权可以转租。在二房东有转租权的情况下，还看要二房东本人的租赁期限还有多长时间，要在其租赁期限内承租。另外还要记得索要二房东的身份证复印件，免得日后房东找上门时，连谁租给你都不知道。&lt;/p&gt;
&lt;h2 id=&#34;32-买买买买房的避坑指南&#34;&gt;3.2 买买买！买房的“避坑”指南
&lt;/h2&gt;&lt;p&gt;老李前段时间通过中介买了套二手房，签合同当天，老李给房主交了 20 万元的定金，也给中介交了 10 万元的中介费。合同签好后，因为房价上涨，房主又反悔了，要求再加 30 万元才网签。老李现在也正烦恼着。&lt;/p&gt;
&lt;p&gt;显然，在这件事情上，我们应该重点关注这么两点：&lt;/p&gt;
&lt;p&gt;签了合同，也交了定金和中介费，却还没网签，会有什么风险？&lt;/p&gt;
&lt;p&gt;老李应该怎么做来保障自已的权益呢？&lt;/p&gt;
&lt;h3 id=&#34;321-法律知识&#34;&gt;3.2.1 法律知识
&lt;/h3&gt;&lt;p&gt;首先是定金、订金和押金这“三种金”，尤其要注意前两个词，第一个是确定的“定”，第二个是订单的“订”。现实生活中，你应该经常见到它们，甚至很多人可能以为这仨都是一个意思。事实上，一字不同，差别可是大了去了。用词不同，承担的法律后果就明显不一样。&lt;/p&gt;
&lt;p&gt;一、定金&lt;/p&gt;
&lt;p&gt;定金是具有惩罚性的。简单来说就是，签了合同交了定金后，如果交钱方违约，定金不用退；如果收钱方违约，应该双倍返还定金。这一点在法律上叫做定金罚则。&lt;/p&gt;
&lt;p&gt;定金的具体数目要由双方约定，但不能超过合同金额总数的 20%。比如说，总金额为 100 万的某个买卖合同，定金的数目就不能超过 20 万。超过这个比例，将不会得到法律的支持，属于无效约定。&lt;/p&gt;
&lt;p&gt;想必你已经发现，开头我们提到的老李故事中，他所支付的 20 万元就是这个“定金”。&lt;/p&gt;
&lt;p&gt;二、订金&lt;/p&gt;
&lt;p&gt;生活中我们还经常用到“订金”这个词，不同于第一个词，这个“订金”没有惩罚作用。如果双方合同上写的是订金，一旦发生违约，合同不能正常进行，收钱的人把订金退回去就行了。也就是说不管是哪一方违约，只要合同没法儿履行，需要解除，退钱就够了。&lt;/p&gt;
&lt;p&gt;三、押金&lt;/p&gt;
&lt;p&gt;押金则具有保证的属性。一旦交钱方违约不履行合同，收钱方可以不用退还押金；而如果收钱方违约，只用退还押金就行了。所以押金的存在，主要保障的是收取者的权益。遇到交押金的情况，就一定要慎重考虑了。&lt;/p&gt;
&lt;p&gt;所以在生活中，一定要根据具体的交易模式和需要达到的效果，来选择适合自已的“三种金”。看到这“三种金”的字眼，也一定要谨慎对待。“一字千金”，大概就是这三个词的使用差别了。&lt;/p&gt;
&lt;p&gt;另外一个重要的概念是“房屋网签”。房屋买卖的双方签订合同后，需要到房地产管理部门进行备案，并要公布在网上。备案后就会得到一个网签号，双方可以通过网签号在网上查到相关信息，并且网签后，卖房人就不能再通过合法渠道对房子二次出售。显然，网签主要是为了保障买房人的利益，防止有些房主“一房二卖”。&lt;/p&gt;
&lt;p&gt;另外，如果双方都同意，网签也是可以撤销的。网签备案合同和双方实际签订的购房合同往往是不一样的。实际生活中，当网签合同和实际签订的购房合同不一致的时候，要以实际签订的合同为准。&lt;/p&gt;
&lt;p&gt;明白了这些，再来思考我们提到的两个问题。&lt;/p&gt;
&lt;p&gt;第一个问题，老李目前的风险有哪些？&lt;/p&gt;
&lt;p&gt;对于老李来说，最大的风险来自于他已经交了 20 万的定金。因为房子没有网签时，房主仍然可以对外出售，或者用来抵押借款。一旦发生这样的情况，老李不但房子买不成，想退钱也得起诉才行，花钱又麻烦。当然，如果房主真的这么做了，也要承担违约责任和损失赔偿，并且还要承担惩罚性的赔偿责任。&lt;/p&gt;
&lt;p&gt;第二个问题，老李应该怎么做呢？&lt;/p&gt;
&lt;p&gt;首先老李应该尽快起诉房主，同时申请财产保全，查封这套房子，保证诉讼过程中房子不被交易或抵押出去。&lt;/p&gt;
&lt;p&gt;有时侯我们为什么不想打官司，就是因为害怕打完官司后，钱也花了，房子却没了，所以在这里的诉讼保全措施很重要，能够保障诉讼后的执行问题。现实中可不就是不怕无赖不给，就怕无赖没钱嘛！&lt;/p&gt;
&lt;p&gt;在起诉后，老李就有两种选择了。他可以选择解除合同，要求对方承担违约责任，如果违约责任不足以赔偿损失，也可以主张损害赔偿。他也可以要求继续履行合同，同时要求小张承担违约责任。&lt;/p&gt;
&lt;p&gt;对于老李来说，因为交了 20 万定金，所以最起码房主应该给他 40 万元，也就是我前面说到的“定金罚则”。当然如果还有其他的损失，或是约定的违约金高于这个数，还可以继续要求赔偿。&lt;/p&gt;
&lt;h3 id=&#34;322-购房常见纠纷&#34;&gt;3.2.2 购房常见纠纷
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;新房购买的纠纷&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;新房购买的纠纷，经常出现在三、四线城市，一般包括这么几种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;“五证”不全的楼盘，出现资金断裂、烂尾的纠纷；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新房在购买后降价，导致买房人集体要求退房的纠纷；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;交房后，因为发现了质量问题而引起的纠纷；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开发商为了规避政策，额外收费而引起的纠纷。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;二手房交易的纠纷&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一种是卖房人签了合同后，又单方面要求涨价，或是撕毁合同、另外出售而引起的纠纷&lt;/li&gt;
&lt;li&gt;另一种则是买房人因为房价下跌，违约不购买而引起的纠纷&lt;/li&gt;
&lt;li&gt;政策的调整，导致买房人不再有买房的资格或不能获得贷款，从而产生纠纷。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;323-购房注意事项&#34;&gt;3.2.3 购房注意事项
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;在购买新房时&lt;/strong&gt;
第一、要确认开发商的售房资质，也就是通常所说的五证：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;《商品房销售（预售）许可证》；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;《建设工程施工许可证》；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;《建设工程规划许可证》；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;《建设用地规划许可证》；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;《国有土地使用证》。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般情况下，只要开发商拿到了《商品房预售许可证》，就说明他具有合法的出售资质。因为通常，没有其他四证，他也拿不到预售证，所以这种情况一般比较安全。买房子时，只要你向销售提要求，他就会给你看这些证件的。如果仍然不放心，找当地的住建委咨询一下就可以了。&lt;/p&gt;
&lt;p&gt;第二、要细致阅读《认购协议书》的条款。因为这份协议书是开发商单方面制订的合同，往往会存在些霸王条款，要看清楚究竟能不能解除认购书，以及解除条件等内容。&lt;/p&gt;
&lt;p&gt;第三、要核对清楚《补充协议》的信息。因为《购房合同》一般是格式合同，具体的信息还是要看《补充协议》，核心包括交房时间、违约责任、房产证的办理时间、贷款情况、房款的支付时间等内容。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在购买二手房时&lt;/strong&gt;
在购买二手房时，你应当注意以下这么五点&lt;/p&gt;
&lt;p&gt;第一、一定要查看房本原件，确认产权情况。如果你要从已婚人士那里买房，房子可能是的夫妻共同财产，一定要让双方到场签字，以免以后有麻烦。&lt;/p&gt;
&lt;p&gt;另外，有的房子产权更复杂一些，比如说通过继承而获得的房子，虽然房子只登记在一个人名下，但有好几个共有权人。如果你买的是这样的房子，一定要确认所有的共有权人都在合同上签字，或者他们共同委托了某一人来出售房屋。&lt;/p&gt;
&lt;p&gt;第二、要注意产权证办理和交房问题。一般情况下，是先办产权过户手续、再办理交房，或者这两者同时进行。这里一定要考虑清楚，资金能否全部到位，至少你也要保证，交房前能拿到银行的贷款批准通知。&lt;/p&gt;
&lt;p&gt;第三、弄清楚户口迁出问题。如果房子本身落有户口，要考虑清楚这个户口能不能迁出去。另外，要约定好如果户口迁不出去的违约责任，因为一旦出现户口不能迁出的情况，法院也不能强制迁出，对于买房人来说，也只能通过诉讼来主张违约责任，要求对方给点钱了。&lt;/p&gt;
&lt;p&gt;第四、约定一些“弹性条件”。房地产交易的程序复杂，周期也比较长，所以通常可以在合同中约定好，因房价涨跌造成损失的处理方法，约定相应的调价条款或解除条款。&lt;/p&gt;
&lt;p&gt;比如说可以约定，在产权变更登记前，如果房价涨跌不足 20%，风险应该如何分担；如果超过 20%，又应该如何分担的问题等等。&lt;/p&gt;
&lt;p&gt;第五、处理好中介问题。二手房一般会涉及到中介费，在中介合同里明确约定，一旦房子交易失败，中介就要退还全部的中介费。至于交易失败后多长时间内退钱，以及中介费的多少，也都应该在合同中说清楚。&lt;/p&gt;
&lt;p&gt;面对政策调整带来的问题，我只能提醒八个字，“及时关注、提前约定”。现实生活中，政策调整可能导致购房资格、贷款资格或者是税费出现问题。在签合同时，谁都不知道未来会有什么变化，但我们还是可以根据经验，做好预防。&lt;/p&gt;
&lt;p&gt;还是那句话，合同就是一切。你需要在合同中提前约定好，政策调整后该怎么办，是双方无责任解除合同呢，还是有条件地继续履行。&lt;/p&gt;
&lt;h2 id=&#34;33-闪婚又闪离彩礼怎么理&#34;&gt;3.3 闪婚又闪离，彩礼怎么理？
&lt;/h2&gt;&lt;h3 id=&#34;331-引子&#34;&gt;3.3.1 引子
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;男生小张和女生丽丽两人是相亲认识的，互相感觉还不错。因为两人年纪也不小了，家里老人催得挺紧，没两个月，两人就把婚约给定了下来。&lt;/p&gt;
&lt;p&gt;按照咱们的老祖宗的规矩，订婚的话彩礼当然不能少。小张本身是个程序员，挣得不少，也还挺喜欢丽丽，所以并没过多思考，慷慨给了女方家里 20 万元作为彩礼钱。&lt;/p&gt;
&lt;p&gt;可惜好景不长，订婚后没多久两人明显感觉性格不合，经常因为鸡毛蒜皮小事吵架、冷战。女方家觉得小张性子太直，脾气还很不好，就找了个“八字不合”的借口要求退亲。&lt;/p&gt;
&lt;p&gt;这下小张家里发了愁：人还没娶着，20 万怎么办？&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;你看，是不是很熟悉的情节？其实小张的问题还是比较简单的。怎么办呢？我们根据生活经验也能猜到，那就是去找女方把彩礼给要回来。&lt;/p&gt;
&lt;p&gt;但是如果协商后，女方家不想退还这 20 万，那该怎么办呢？简单来说，小张可以向女方所在地的人民法院提起诉讼，要求返还全部礼金。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;引出问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果两个人举办婚礼没多久，还没领结婚证，男方不同意在一起了，彩礼还用退吗？女方不同意的话还能退吗？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果已经领了结婚证，也办了婚礼，离婚时还能要回彩礼吗？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果是同居期间，女方怀孕做过流产，但男方又不同意结婚了，还能要求返还彩礼吗？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;332-法律知识&#34;&gt;3.3.2 法律知识
&lt;/h3&gt;&lt;p&gt;首先我们来看，什么是彩礼？这个词想必你不会陌生，各地叫法不一，有称财礼或是聘礼的。法律上是指为了缔结婚姻关系，一方给另一方、或双方互相给对方的嫁妆和礼金。通俗来说，也就是订婚时所给的财物。&lt;/p&gt;
&lt;p&gt;彩礼的历史可谓源远流长，早在西周就已经出现。在上个世纪，我们常说的有“四大件”（即缝纫机、自行车、手表和电视机）、还有“三金一冒烟”（即金耳环、金项链、金戒指这三件金首饰和会冒烟的小汽车）。到了今天，一般还有房子、钞票、股票等大额财物。&lt;/p&gt;
&lt;p&gt;必须强调的一点是，我们国家明确“禁止包办、买卖婚姻，禁止借婚姻索取财物”。涉及文化习俗，在这里我们不讨论彩礼的存在是否合理。但是如果以结婚的名义勒索、诈骗钱财，违背了婚姻的自愿原则，都是违法行为，会受到法律的惩处。&lt;/p&gt;
&lt;p&gt;结婚又该如何理解呢？法律上所讲的婚姻关系成立，是指男女双方亲自到民政局的婚姻登记处，去办理结婚登记手续，领结婚证。不过呢，现实生活中，还有很多人觉得只要办了婚礼请了客，就等于结婚了。&lt;/p&gt;
&lt;p&gt;很明显，法律上的结婚概念和传统的理解并不相同。只有领了结婚证，才能说双方的婚姻关系成立。也就是说，不管你有没有办婚礼、请客，哪怕已经生了孩子，只要没领证，在法律意义上，婚姻关系都不成立。&lt;/p&gt;
&lt;h3 id=&#34;333-情景分析&#34;&gt;3.3.3 情景分析
&lt;/h3&gt;&lt;p&gt;先厘清了这两个概念，我们回过头来看小张的问题，和刚刚的几个“如果”。&lt;/p&gt;
&lt;p&gt;原则上，小张、丽丽未领证，不管哪一方先结束了关系，小张都可以提起诉讼要求返还彩礼。&lt;/p&gt;
&lt;p&gt;如果两人领了证，但没共同生活过，小张也可以请求返还彩礼。&lt;/p&gt;
&lt;p&gt;如果两人领了证，但某一方因为出的彩礼钱太多，而导致生活困难的，也可以向法院请求返还彩礼。&lt;/p&gt;
&lt;p&gt;当然，我们这里提到的是“可以请求”，至于具体能返还多少，还要结合双方生活花费和各方损失情况，比如说同居期间共同消费，再比如说女方怀孕流产等等情况，法院根据公平原则来认定返还的具体数额。&lt;/p&gt;
&lt;p&gt;综上，我们可以得出这样一个结论：&lt;/p&gt;
&lt;p&gt;&lt;em&gt;不管有没有举办婚礼、有没有请客、有没有共同居住、有没有怀孕流产，也不管是哪一方提出结束关系，只要符合法律规定，都可以请求返还彩礼，法院会根据实际情况来认定返还多少。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;而彩礼问题上，不管下列哪种情况，男方或女方都可以请求返还彩礼：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;男女双方未领证；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;虽领证但没有共同生活；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;领证并共同生活过，但婚前给的彩礼过多，导致生活困难的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;34-离婚还想和平你要这么做&#34;&gt;3.4 离婚还想和平？你要这么做
&lt;/h2&gt;&lt;h3 id=&#34;341-引子&#34;&gt;3.4.1 引子
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;前几天一熟人突然打电话，说是遇到点事儿，想跟我聊聊。原来是他亲戚小李的婚姻出了问题。小李老婆名叫小敏，和公司的主管悄悄好上了，最近一直在跟小李闹离婚。他俩孩子还小，只有三岁多，但双方已经闹了一年多，也确实是过不下去了。因为谈不拢离婚条件，事情一直没结果，小李备受折磨，所以想找我咨询一下。&lt;/p&gt;
&lt;p&gt;这两人的争执主要有这么几点：&lt;/p&gt;
&lt;p&gt;房子：两人有一套房子，是结婚前小李父母出首付买下的，登记在小李名下，婚后则是两人共同还房贷。小敏提出，房子属于共同财产，房子可以给小李，但小李必须给她一些现金作为补偿，比如说房子市场价的一半。&lt;/p&gt;
&lt;p&gt;车子：两人结婚后买了辆尼桑，记在了小敏名下。小敏要求车子归自已，以后送孩子上学方便。&lt;/p&gt;
&lt;p&gt;存款：两人平时的钱都交给小敏保管，小李知道的有 50 万左右在小敏名下。小敏要求各自名下的存款各自拥有。&lt;/p&gt;
&lt;p&gt;孩子：女方小敏要求孩子归自己抚养，由男方小李支付抚养费。&lt;/p&gt;
&lt;p&gt;感情走到了尽头，两人还要就孩子、财产问题争执不下，不得不说是件糟心的事。
这一类的婚姻感情问题，想必你一定不会陌生，例如行业里前段时间的 WePhone 开发者苏享茂事件。悲剧发生后，引起了社会上广泛的争议，然而孰是孰非又怎样，人最宝贵的东西——生命没了。&lt;/p&gt;
&lt;p&gt;再如轰动一时的明星王某某离婚纠纷，其采取的法律措施应该让你印象深刻，在几乎获得压倒性的舆论支持的同时，自己利益也得到了法律的保护。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;342-法律知识&#34;&gt;3.4.2 法律知识
&lt;/h3&gt;&lt;p&gt;离婚，顾名思义，解除夫妻关系。古有“和离”、“休妻”等手段，这种称呼和当时的封建男权社会性质有关。到了现代社会，根据不同的方式，离婚一般可以分为两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;协议离婚，指的是合法婚姻关系中，男女双方自愿达成离婚协议，到民政部门办理离婚手续并领取离婚证；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;诉讼离婚，则是指婚姻关系中，某一方不同意离婚，或者双方对于财产分割、债务分担、子女抚养等问题无法达成一致意见时，向法院起诉离婚，由法院来根据双方实际情况来判定，判决是否同意离婚，并对相关争议做出处理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现如今，离婚原因无非那么几种，双方性格不合、家庭关系不和睦、家庭暴力或者是出轨等。其实在离婚问题上，和平分手还是占主流的，至于分手之后能否做朋友，那就完全分人了。而诉讼到法院的情况，往往是因为涉及到财产分割、孩子抚养以及损害赔偿等争议无法达成一致意见。&lt;/p&gt;
&lt;p&gt;说到损害赔偿，你可能相对陌生，但“精神损失费”这个词你一定听过或用过，而精神损失、人身伤害以及财产损失都属于损害赔偿。你可以把它简单看成是一笔道歉费。离婚纠纷中也会存在损害赔偿，哪些情况下会有呢？婚姻法规定的有四种情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;重婚；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有配偶又和他人同居；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;家庭暴力；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;虐待、遗弃家庭成员。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然，婚姻中的损害赔偿通常是综合性的，一般主要指对另一方的精神伤害，有时也包括人身方面的伤害损失，比如家暴。&lt;/p&gt;
&lt;h3 id=&#34;343-情景分析&#34;&gt;3.4.3 情景分析
&lt;/h3&gt;&lt;p&gt;具体涉及到的财产、孩子以及损害赔偿等问题，我们依次来看。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;财产分割&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;财产问题通常包括房子、车子和存款等。&lt;/p&gt;
&lt;p&gt;在小李事件中，房子为婚前父母帮其出的首付购买，登记在小李名下，房子就应当属于男方的个人财产，至于婚后共同还贷的钱及增值部分，男方对女方参照市场价格进行补偿。&lt;/p&gt;
&lt;p&gt;车子为婚后购买，虽然登记在女方名下，也属于夫妻共同财产，既然车子登记在女方名下，可以由女方所有，但女方需要按市场价的一半补偿男方。&lt;/p&gt;
&lt;p&gt;至于存款问题，钱不管是存在谁的名下，都属于夫妻共同财产，通常应平均分配。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;孩子抚养&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一般情况下，二周岁以下的孩子跟随母亲生活，特殊情况除外。目前两人孩子已经三岁，应根据根据双方的工作情况、经济能力、感情基础以及过错程度等来综合判断，选择最有利于孩子健康成长的一方。&lt;/p&gt;
&lt;p&gt;经了解，两人的孩子是通常由爷爷奶奶（男方父母）来带，而双方经济能力相当，再结合女方存在过错，因此由男方抚养更合适，女方则需要每月支付一定费用。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;过错赔偿&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;女方出轨，导致了夫妻双方感情破裂，属于过错方，男方可以适当主张损害赔偿。&lt;/p&gt;
&lt;p&gt;通过以上的分析，我们显然发现，从法律角度来看，女方的大部分要求都不能得到法律支持。&lt;/p&gt;
&lt;p&gt;其实，在离婚问题上，争议比较大的往往还有房产问题。双方不能达成一致意见时，法院会怎么看呢？我也在这儿总结一下：&lt;/p&gt;
&lt;p&gt;第一，婚前某一人出钱买房，当然也包括他的父母为他出钱，房子应属于这人的个人财产；婚前两人一起出钱买房，同样的包括双方父母出钱，房子应属于共同财产。&lt;/p&gt;
&lt;p&gt;第二，婚前某一人出首付来贷款买房，婚后两人共同还贷，房子应属于婚前的购买者，而对于共同还贷的部分，则由房子的所有者补偿给另一人。&lt;/p&gt;
&lt;p&gt;第三，婚后由某一人的父母出钱购买，并且只登记在这个人名下的房子，属于其个人财产；婚后由两人父母共同出钱买的房子，即使只登记了其中一人的名字，也属于按份共有的共同财产。&lt;/p&gt;
&lt;p&gt;在这里我解释一下按份共有，指的是双方分别按照确定的份额共同拥有，也就是说，如果两方出钱的比例为 5:5，那么他们对于房子的所有权也是五五分。&lt;/p&gt;
&lt;p&gt;另外，不管以上哪种情况，除非特殊约定过，否则只要房产证上写的是男女双方的名字，就不用考虑谁出钱的问题了，都以产权登记为准，属于夫妻共有财产。&lt;/p&gt;
&lt;h2 id=&#34;35-遗产继承的爱恨情仇&#34;&gt;3.5 遗产继承的爱恨情仇
&lt;/h2&gt;&lt;h3 id=&#34;351-引子&#34;&gt;3.5.1 引子
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;生老病死是我们人生中的大事，学习法律也不可避免这些。虽然我们都不大乐意谈“死亡”，但遗产问题，确实是每个人都不可避免的。正好前几天有个朋友来咨询，借着这个案子，我也来说说遗产问题。&lt;/p&gt;
&lt;p&gt;咨询的朋友，我们都叫她张大姐。张大姐和张二是亲姐弟关系，两人的母亲在 2013 年已经去世，父亲也在去年，也就是 2017 年去世了。他们的父母去世后，留下了一套拆迁房，就在北京昌平区，拆迁款估计能有 1000 多万。&lt;/p&gt;
&lt;p&gt;不幸的是，弟弟张二今年因为癌症也不在了，而张二目前的唯一继承人是他儿子，张小二。现在，张大姐和张小二，正因为这套拆迁房而争执不下。为什么呢？这就必须提到张大姐的父亲，也就是张小二的爷爷留下的一份遗嘱了。&lt;/p&gt;
&lt;p&gt;张大姐的父亲住院期间，留下了一份遗嘱，内容是把所有财产都留给儿子，也就是张二来继承。现在张二因病去世，张小二自然觉得这些财产，包括房子，就应该是自己的了。&lt;/p&gt;
&lt;p&gt;但是张大姐显然不同意，她觉得遗嘱是有问题的。因为遗嘱是在她父亲重病期间立下的，并且是由其他人打印出来，她父亲只是最后签了字。虽然那个人以证明人的身份，在遗嘱上也签了字。但是毕竟只有这么一个人在场，张大姐还是很怀疑遗嘱是否有效。&lt;/p&gt;
&lt;p&gt;这事究竟该怎么看呢？其实，这里面主要涉及三个问题：&lt;/p&gt;
&lt;p&gt;张小二究竟有没有权利，继承他爷爷奶奶的全部财产？&lt;/p&gt;
&lt;p&gt;遗嘱到底有没有法律效力呢？&lt;/p&gt;
&lt;p&gt;遗产最后究竟应该怎么分?&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;352-法律知识&#34;&gt;3.5.2 法律知识
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;继承&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们首先来看“继承”这个概念。某人死亡后，把自己的财产、债务、可以世袭的官位等转移给别人，就叫做继承。在继承中，死亡的这个人叫做被继承人，被转移的东西也就是我们通常所说的遗产，而继承遗产的也就是继承人。继承人可以是一人，也可以是多个人。&lt;/p&gt;
&lt;p&gt;继承一定是从被继承人的死亡开始的，活人自然不存在继承问题，更不存在履行问题。继承的方式一般有两种，遗嘱继承和法定继承。在没有遗嘱的情况下，被继承人死后，遗产由法定的继承人来继承。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;转继承&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第二个概念我们来看“转继承”。如果某次继承已经开始，但是继承人还没实际拿到遗产就去世了，那么这个继承人的法定继承人，有权代其拿到这笔遗产，这也就是转继承。已死继承人的继承人，其实就是转继承人。&lt;/p&gt;
&lt;p&gt;整理来看，其实就是被继承人死亡，遗产留给继承人，但在实际收到遗产前，继承人也死了，就由转继承人实际上继承这笔遗产。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;遗嘱&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第三个，我们来了解一下“遗嘱”。遗嘱是指，某人生前在法律允许的范围内，用法定方式对财产或其他事务，做出死亡后的归属安排。 立下遗嘱的这个人，一般叫做遗嘱人。遗嘱人死亡时，遗嘱开始生效。&lt;/p&gt;
&lt;p&gt;遗嘱人可以用遗嘱的形式，把自己的财产指定给某一个法定继承人来全部继承，也可以把财产安排给法定继承人以外的人。原则上，只要遗嘱的形式符合法律规定，内容是遗嘱人的真实意愿，遗嘱都可以生效，也就是遗嘱人可以把财产给任何人。&lt;/p&gt;
&lt;p&gt;另外，遗嘱常见的形式有自书遗嘱、代书遗嘱、公证遗嘱这三种。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;自书遗嘱，要由遗嘱人亲笔书写并且签名，同时必须注明年、月、日。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;代书遗嘱，要有两个以上的见证人在场，然后由其中一个见证人来代写，同样要注明年、月、日，最后还要有代写人、其他见证人、还有遗嘱人的签名。在这里，见证人和继承人不能有利害关系，比如说，见证人不能是继承人的妻子、儿女等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;公证遗嘱，遗嘱人亲自到公证机关口述或书写遗嘱，然后由公证人员审查遗嘱的真实性、合法性，最后确认有效后，公证人员会给出一份《遗嘱公证书》。一旦立下公证遗嘱，变更、撤销也要到公证机关来处理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;法定继承顺序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一顺序包括配偶、子女、父母。&lt;/p&gt;
&lt;p&gt;第二顺序包括兄弟姐妹、祖父母、外祖父母。&lt;/p&gt;
&lt;p&gt;有第一顺序人选的，遗产由第一顺序的人来继承，第二顺序的人没有继承资格。如果没有第一顺序的人选，再由第二顺序替补来继承。&lt;/p&gt;
&lt;p&gt;另外，不管你婚生还是非婚生，也不管是血缘关系还是收养关系，或是再婚家庭的扶养关系，在法律面前，一律属于平等地位。具体来说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;《继承法》的子女，包括婚生子女、非婚生子女、养子女和有扶养关系的继子女。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;《继承法》的父母，包括生父母、养父母和有扶养关系的继父母。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;《继承法》的兄弟姐妹，包括同父母的兄弟姐妹、同父异母或者同母异父的兄弟姐妹、养兄弟姐妹、有扶养关系的继兄弟姐妹。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;353-情景分析&#34;&gt;3.5.3 情景分析
&lt;/h3&gt;&lt;p&gt;首先，张小二有没有权利，继承他爷爷奶奶的全部财产呢？&lt;/p&gt;
&lt;p&gt;答案应该是没有。张小二的爷爷奶奶去世后，他的父亲张二有权继承遗产，注意这里，我没有说“张二有权继承全部遗产”，因为还要看遗嘱是否有效，而遗嘱问题待会儿我会解释。&lt;/p&gt;
&lt;p&gt;第二个问题，可能也是我们最关心的，遗嘱是否有效呢？&lt;/p&gt;
&lt;p&gt;前面说了，遗嘱生效至少要满足两个条件，一是形式要符合法律规定，二是内容要符合遗嘱人的真实意愿。这个案子的遗嘱，是在老人病重期间立下的，确实不能保证内容是遗嘱人的真实意愿。&lt;/p&gt;
&lt;p&gt;另外，这份遗嘱既不能算是自书遗嘱，也不符合代书遗嘱的法律条件。而且，遗嘱不是遗嘱人亲自书写并打印的，就可能出现第三人删改、编造的情况，所以遗嘱显然是无效的，不受法律认定。自然，张二也就无权继承全部遗产，张小二这个转继承人，更是没有资格。&lt;/p&gt;
&lt;p&gt;那么第三个问题，遗产怎么分，答案就比较明了了。&lt;/p&gt;
&lt;p&gt;既然遗嘱无效，就应该按照法定继承来处理遗产问题。法定继承的顺序，前面我已经讲过了，在这个案子中，张大姐和张二显然都属于第一顺序继承人，也是唯二的两个继承人。同时，法定继承遵循的是“男女平等、遗产均分”的原则。&lt;/p&gt;
&lt;p&gt;所以，假定本案中遗产最终被确认为 1000 万，简单来说，就应该是张大姐和张二各得 500 万。然而张二没有实际继承就去世了，张小二这个转继承人，就应该获得张二的这笔 500 万。&lt;/p&gt;
&lt;p&gt;事实上，我们退一步来说，即使遗嘱本身符合法定形式，内容也是张小二爷爷的真实意愿，遗嘱本身还是有问题的。为什么呢？&lt;/p&gt;
&lt;p&gt;因为张小二爷爷并没有权利处置整套房子。&lt;/p&gt;
&lt;p&gt;细心的同学，应该注意到了，开头我专门强调的两个时间。张小二的奶奶 2013 年去世，爷爷则是 2017 年去世。事实上，在奶奶去世时，就已经有了法定继承的开始。&lt;/p&gt;
&lt;p&gt;当时的财产，比如说 1000 万的房子，本身是爷爷奶奶的夫妻共同财产，首先应该有一半属于爷爷，而剩下的，也就是属于奶奶的另一半才是遗产，应该由爷爷、张大姐和张二平分，每人各得六分之一。&lt;/p&gt;
&lt;p&gt;所以说，奶奶去世后，房子其实是张小二爷爷、张大姐、张二的共有物，并不是爷爷的个人财产，只不过他占有的份额最大而已。因而，他没有权利立遗嘱处置他人财产。&lt;/p&gt;
&lt;h2 id=&#34;36-老人倒地扶不服&#34;&gt;3.6 老人倒地，“扶”“不服”？
&lt;/h2&gt;&lt;p&gt;老人摔倒了，扶不扶？这一直都是个不小的社会问题，也是不少人茶前饭后谈论的“八卦”。这类事情大规模引起注意，应该是因为 2014 年春晚上，一个叫《扶不扶》的小品。&lt;/p&gt;
&lt;h3 id=&#34;361-第一种情况遇到老人摔倒要怎么办&#34;&gt;3.6.1 第一种情况，遇到老人摔倒，要怎么办？
&lt;/h3&gt;&lt;p&gt;帮忙是一定要帮的，但是怎么帮就比较有讲究了。在出手扶老人前，你一定要有这么两个意识。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;不要急匆匆先去扶人，最好先打急救电话联系医生，以防给老人造成二次伤害。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;考虑一下自己能不能提供证据，证明自己的清白。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;“不要贸然先扶人”这一点，主要是为受伤者考虑。其实不仅仅是倒地老人，遇到其他病人或者伤患倒地的情况，也是一样的处理原则。&lt;/p&gt;
&lt;p&gt;如果伤者意识清楚，先问清楚伤者摔倒的情况以及记忆是否清晰。如果伤者已经想不起来了，可能是脑血管相关的疾病，更不能贸然移动，应该立刻报警或者打“120”急救电话，并在附近尝试呼救，寻求专业人士帮忙。&lt;/p&gt;
&lt;p&gt;考虑证据这一点，倒不是不顾人和人之间基本的信任，故意把人往坏处想。实际上，很多时候，上了年纪的人在路上走着，一分神儿可能真没注意到，到底是谁把他给撞倒的。这时候你来帮忙，他会下意识地认为，如果不是你撞的，为什么就你来帮忙。&lt;/p&gt;
&lt;p&gt;所以，我们做好人好事，前提一定要明确责任，能够自保，这也是好人好事行为的基本原则。&lt;/p&gt;
&lt;p&gt;综合来说，如果是在白天发现老人摔倒，一般周围会有其他路人，你就可以向其他人求助一起帮忙。哪怕对方不愿意一起伸手，也可以让路人帮忙摄像，这样你就可以安心出手了。&lt;/p&gt;
&lt;h3 id=&#34;362-第二种情况遇到发生交通事故的老人要怎么办&#34;&gt;3.6.2 第二种情况，遇到发生交通事故的老人，要怎么办？
&lt;/h3&gt;&lt;p&gt;这种情况，相对来说更好解决，你也能清楚判断出，究竟是不是交通事故。&lt;/p&gt;
&lt;p&gt;如果你只是路人角色，你可以及时为受伤老人提供帮助，比如说报警、打“120”、维持秩序、联系家人等。这里面需要注意的就是，如果你没有开车，自然能轻松洗清嫌疑。如果你本身开了车，别把自己的车停在事故发生地，防止招惹是非。&lt;/p&gt;
&lt;p&gt;如果你是交通事故的当事人，首先千万不要逃跑，肇事逃逸的罪名就很严重了。第一时间还是应该报警、打“120”，及时让警方和医生介入。报警是为了查明事故的真相，找医生是为了第一时间提供救助，这样也可以杜绝“碰瓷”现象。&lt;/p&gt;
&lt;p&gt;另外，任何交通事故发生后，最不建议的方案就是“私了”。举个例子，有个老人闯红灯，结果被你正常开车给撞到了。按理来说，你不用负责，而老人也承认这是自已的问题，让你先走。可是，万一你走后，再被老人反咬一口，没有证据的话，岂不成了肇事逃逸吗？&lt;/p&gt;
&lt;p&gt;其实，还是那句话，证据为王。如果事情发生后，你能找到证据（比如视频、录音、证人证言等），证明不是自己的责任，离开现场自然无可厚非。&lt;/p&gt;
&lt;p&gt;如果你不能证明这一点，为了不留后患，最好还是要及时报警，彻底解决问题。&lt;/p&gt;
&lt;h3 id=&#34;363-第三种情况已经救了人却反被诬陷要怎么办&#34;&gt;3.6.3 第三种情况，已经救了人，却反被诬陷，要怎么办？
&lt;/h3&gt;&lt;p&gt;如果不幸被诬陷，首先还是要收集证据，不管是寻找当时的路人作证，还是调取监控，都应该第一时间去做。&lt;/p&gt;
&lt;p&gt;如果更加不幸，找不到证据来证明自己的清白，我有这么两点建议。&lt;/p&gt;
&lt;p&gt;第一，诉讼要坚持“谁主张谁举证”。单方面的诬陷口说无凭，想要让你负责，被救方必须提供充分的证据，能证明你伤害了他。这样，被救方很可能因为举证不明而败诉，你也可以避免不能提供证据、证明自己清白的责任。&lt;/p&gt;
&lt;p&gt;第二，诉讼要拒绝息事宁人。法院不是万能的审判者，也有可能在证据不足的情况下，做出不严谨的判断，让你们和解来解决。这种情况下，态度要坚决，不能背锅、也不能宽容，应该坚决上诉。 宽容未必结出善良之花，公平公正才是基本的保障。&lt;/p&gt;
&lt;h2 id=&#34;37-如何让欠债还钱真正天经地义&#34;&gt;3.7 如何让欠债还钱真正“天经地义”？
&lt;/h2&gt;&lt;p&gt;关于朋友间“借钱”的话题，有很多种说法。有的说既然是朋友张口了，该借；有的说朋友之间千万别借钱，谈钱就伤感情。还有一句经典语录，结束友情的方式有很多种，最彻底的方式是借钱不还。&lt;/p&gt;
&lt;h3 id=&#34;371-没有借条证据怎么找&#34;&gt;3.7.1 没有借条，证据怎么找？
&lt;/h3&gt;&lt;p&gt;我们日常生活的借钱，经常碍于情面，没有签过欠条，但到了法庭上就比较无力了。单纯的流水单或其他转账记录，不能独立证明借贷关系，需要我们提供其他证据。&lt;/p&gt;
&lt;p&gt;第一，可以收集你借给他钱的证据，比如聊天记录、邮件记录、电话录音、证人证言等，然后结合各种转账记录，增强这个事实的可信度。&lt;/p&gt;
&lt;p&gt;第二，可以收集你催他还钱的证据，证据类型跟刚刚的的基本一样。因为在撕破脸前，一般人不会直接否认借钱的事实，最多辩解几句没钱还、或者过些天再给。这些证据虽然不如借钱的证据那么直接有力，但是结合转账记录，也可以增加说服力。&lt;/p&gt;
&lt;p&gt;这里提到的录音证据，我再简单说一下。录音材料只要不侵犯到对方的利益，是可以作为证据的。如果没有提前准备好，你也可以用手机的录音功能，即时取证制作。&lt;/p&gt;
&lt;p&gt;不过，录音本身有一定的要求，要清晰、真实、完整，必须清楚反映你们的借钱关系和借钱内容，也要反映欠债人的真实意志。&lt;/p&gt;
&lt;p&gt;所以录音材料的取证中，沟通技巧就比较重要了。这一点，建议你还是找专门的律师来协助进行。&lt;/p&gt;
&lt;p&gt;第三，可以收集对方的财产信息。为了防止出现胜诉却拿不到钱的情况，你还可以起诉前调查对方的财产情况，如银行账户、房车、股票等情况。当然，这个事情本身难度较大，即使是专门的律师，也很难全部查清楚，所以只能作为辅助手段。&lt;/p&gt;
&lt;h3 id=&#34;372-没有借条怎么追债&#34;&gt;3.7.2 没有借条，怎么追债？
&lt;/h3&gt;&lt;p&gt;收集到了证据，接下来要怎么追债呢？&lt;/p&gt;
&lt;p&gt;追债的第一选择，一定是协商。但如果协商不成，可以用法律来帮忙了。比如，可以委托律师向对方发律师函。律师函可以起到警告作用，很多人见到律师函就会清醒不少，及时还款。不过，律师函不能强制要回，如果对方仍然拒绝，就应该起诉了。&lt;/p&gt;
&lt;p&gt;起诉的流程，前面我们讲过，我主要强调几个细节。&lt;/p&gt;
&lt;p&gt;起诉之前，你可以申请诉前财产保全，查封对方的财产，防止对方悄悄转移。&lt;/p&gt;
&lt;p&gt;如果胜诉后拿不到钱，可以向法院申请强制执行。&lt;/p&gt;
&lt;h3 id=&#34;373-健康的借钱方式&#34;&gt;3.7.3 健康的借钱方式
&lt;/h3&gt;&lt;p&gt;讲了这么多追债的内容，其实我最希望的，还是我们都有足够的法律意识，健康低风险地借钱还钱。我觉得亲友借钱，最好能做到这么几点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;借钱尽量立借条。先小人后君子，其实任何事情，在一开始就明确好界限，说清楚利弊，并不会伤感情，尤其是跟钱相关的事情。借别人的钱，你可以自己主动打欠条；借给别人，也不要不好意思提。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果实在张不开嘴，一定保留证据。短信、微信等各种记录，银行、支付宝的各种转帐记录，都保留好。转账时，最好也在转账的备注页面写清楚是借给朋友的钱。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;借钱之前，尽可能了解对方的用途。赌博吸毒一类的救急借钱，一律别理睬，那基本上是无底洞了；所谓高利息的诱饵，也要警惕，高利贷、非法集资随时可能坑你；如果明知道对方要违法犯罪，更不能沾上关系。这样的借款不受法律保护，损失得你自己扛。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，我也给出了法律有效的借条的样式，分别是文字和图片格式，你可以自己保存下来，留作备用。&lt;/p&gt;
&lt;h3 id=&#34;374-借条的正确打开&#34;&gt;3.7.4 借条的正确打开
&lt;/h3&gt;&lt;p&gt;借条&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;今收到出借人何三，以转账或现金方式出借人民币 5000 元整，月利率为 2%，于 2018 年 12 月 22 日归还，此钱用于饭店经营。
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;若到期未还，每迟延一日，按应还款金额的 1% 支付日违约金。若发生争执，由何三经常居住地法院管辖。
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;借款人：李四，身份证号： ，住址：
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;年 月 日
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这里要注意，约定的月利率不能超过 2%。另外，管辖法院约定为何三的经常居住地，是为了方便在李四不还钱时，何三可以就近起诉。否则，如果李四在海南，何三在北京，何三还得跑到海南才能起诉，增加了起诉成本。&lt;/p&gt;
&lt;h2 id=&#34;38--从透支到盗刷人人须知的银行卡纠纷&#34;&gt;3.8  从透支到盗刷：人人须知的银行卡纠纷
&lt;/h2&gt;&lt;p&gt;银行卡，我们每个人都不陌生，钱包里放着四五张银行卡可能都很正常。同时，银行卡也十分重要，毕竟可能就是我们的全部家当了。不过，虽然每天会用到，你真的清楚了解它的规则和风险吗？&lt;/p&gt;
&lt;p&gt;我估计答案是否定的，毕竟每年的银行卡纠纷案子，可真不少见。使用规则主要涉及经济领域，我就不多说了，我今天想讲的，正是银行卡的风险和法律问题，毕竟保管不善或者使用不当，都可能让你的银行卡陷入危机。&lt;/p&gt;
&lt;h3 id=&#34;381-信用卡诈骗罪&#34;&gt;3.8.1 信用卡诈骗罪
&lt;/h3&gt;&lt;p&gt;银行卡，根据银行划定的不同使用范围，可以分为借记卡和信用卡：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;借记卡，就是我们平常所说的储蓄卡，在老一辈人口中也常被笼统叫做“银行卡”，可以存款、取款，并没有透支功能。一般来说，发工资、存款、理财等，我们用的正是借记卡。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信用卡，是具有透支功能的卡片。在银行授权额度内，你可以提前消费，以后再还款。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;现在办理银行卡越来越简单。很多都是在公司楼下或人多的地方，简单摆摊儿放个桌子，你只要提供身份证就能当场办理。没有人会告诉你，办卡，尤其是办信用卡会有啥风险，更不会告诉你，透支甚至会构成刑事犯罪，也就是信用卡诈骗罪。&lt;/p&gt;
&lt;p&gt;要了解信用卡诈骗罪，首先要清楚这个罪名的“信用卡”的法律含义。这里的信用卡，跟我们刚刚所讲的，银行分类里的信用卡意义不同。&lt;/p&gt;
&lt;p&gt;法律角度来说，信用卡诈骗罪中的“信用卡”，是指商业银行或其他金融机构发行的，具有消费支付、信用贷款、转账结算、存取现金等全部功能或部分功能的电子支付卡。换句话说，法律上的“信用卡”范围更广，我们刚刚所说的两种银行卡其实都属于这个信用卡。&lt;/p&gt;
&lt;p&gt;那么哪些情况，会构成信用卡诈骗罪呢？&lt;/p&gt;
&lt;p&gt;一般来说有这么四种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用伪造的信用卡；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用假身份证办理信用卡；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;冒用别人的信用卡；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;恶意透支信用卡，尤其数额较大的情况。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;前面三种，因为涉及假证或者类似盗窃的行为，很好理解，一般人也不会去碰。但第四种透支问题，估计是普通人最常犯也最受伤的情况，也让不少人都觉得挺冤枉。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;恶意透支&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;事实上，如果构成恶意透支，真的很严重。刑法规定的恶意透支，是指持卡人以非法占有为目的，超过规定额度或规定时间，透支使用信用卡，并且在银行催款 2 次后，超过 3 个月仍不还钱的行为。&lt;/p&gt;
&lt;p&gt;我解释一下这里的“非法占有为目的”，一般是指这么五种情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;明知道没有还款能力，却大额度透支用卡，最终还不起的情况。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;肆意挥霍透支得到的钱，最终还不起的情况。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;透支后跑路或者换联系方式，以逃避银行催债的情况。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;抽逃、转移资金等各种隐藏自己的财产，以逃避还款的情况。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用透支得来的钱财，进行违法犯罪活动的情况。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这五种情况，基本上覆盖了所有透支的场景。这类情况下，只要你透支达到一定额度，并且在银行催款 2 次后，超过 3 个月仍不还钱的，都会涉嫌信用卡诈骗罪。&lt;/p&gt;
&lt;p&gt;信用卡诈骗罪的量刑也是比较重的，主要根据恶意透支的钱数进行判定：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;1 万以上、10 万以下的，属于数额较大，可能会判五年以下有期徒刑或拘役；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;10 万以上、100 万以下的，属于数额巨大，可能会判五年以上、十年以下有期徒刑；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;100 万以上的，最高会判无期徒刑。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;382-被盗刷了怎么办&#34;&gt;3.8.2 被盗刷了，怎么办？
&lt;/h3&gt;&lt;p&gt;首先，及时拨打发卡行的客服电话，对银行卡紧急干预，比如挂失、冻结等。这样，银行也可以根据具体情况，及时通过警方并冻结这笔钱，及时止损。&lt;/p&gt;
&lt;p&gt;另外，拨打银行客服时，记得通话录音。这样在报案时，录音就可以作为证据，证明案件的真实性，使你的案件容易被警方立案。&lt;/p&gt;
&lt;p&gt;第二步，尽快带着银行卡，到附近银行办理业务，并保留好底单；或者到 ATM 机上存款，并保留好存款底单。这么做，是为了证明卡还在自已身上，并没丢失。所以，不是因为把卡给了别人，或者丢了卡，才导致的丢钱。&lt;/p&gt;
&lt;p&gt;第三步，报警处理。一般银行卡被盗，正确的报案地点，应该是发卡银行当地的公安机关，或者钱财被盗刷地点的公安机关。在做完前两步后，应该及时去公安机关报案，这样，警方可以调取相关转账信息来破案。&lt;/p&gt;
&lt;p&gt;第四，和银行沟通，要求银行赔偿，如果沟通不顺利，及时带着上面的这些证据，咨询律师并起诉银行。银行卡就在自已身边，却被盗刷了这么多钱，即使自己有一定的责任，更多的防范责任也一定是在银行身上。&lt;/p&gt;
&lt;h3 id=&#34;383-盗刷追钱四部曲&#34;&gt;3.8.3 盗刷追钱四部曲
&lt;/h3&gt;&lt;p&gt;而你的银行卡如果被盗刷，一定要记住“追钱四步曲”：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;尽快挂失、冻结银行卡；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尽快去银行办理业务，证明卡在自已身上，不存在“人卡分离”；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;向公安机关报案；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;和银行交涉或起诉。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;39-远离套路贷的套路大全&#34;&gt;3.9 远离“套路贷”的套路大全
&lt;/h2&gt;&lt;h3 id=&#34;391-引子&#34;&gt;3.9.1 引子
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;张三是一个创业公司的 CEO。2010 年，他在海淀区买了一套学区房，当时花了 200 多万，只不过一直闲置，很少有人住。&lt;/p&gt;
&lt;p&gt;去年，因为公司周转不开急用钱，张三在网上找了一家小额贷款公司，准备把房子抵押出去。贷款手续倒是挺简单，按要求前几份文件、办理公证手续，并把房本抵押给贷款公司，当天就收到了贷款公司以个人名义转账的 90 万，借期半年。&lt;/p&gt;
&lt;p&gt;当然，张三现在的房子，市值已经有 600 多万了，所以一切看着都挺合理，张三也在贷款当天，就现金支付了利息和保障金，等着度过难关后，再把房子收回来。&lt;/p&gt;
&lt;p&gt;然而，没俩月，张三发现自己的房子被人给低价卖了，还是个陌生人卖的？张三完全不知所措，找到了我来办这个案子。我一看，这不典型的套路贷吗？调查后才发现，借款时，张三无意中签了两份委托书，内容正是委托这个陌生人卖房，委托书还经过了公证。&lt;/p&gt;
&lt;p&gt;张三很气愤，同时也糊涂了。小额贷款，怎么还有这么多的门道？套路贷，到底是又怎么回事呢？&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;392-法律知识&#34;&gt;3.9.2 法律知识
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;套路贷&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在这里，我们先要搞清楚套路贷的意思。其实，套路贷这个词，并不是法律上的概念，只不过太常见了，我们就起了这么个名字来称呼。在我看来，套路贷的重点在于恶劣的套路，说白了就是这么几个特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;打着“民间借贷”的旗号；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用无抵押、放款快、低利息等名义吸引客户；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用虚增债务、虚假资金流水、虚假借款手续、虚假诉讼、暴力威胁催收款等套路；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结果一定是，大量侵吞借款人的财产。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;套路贷表面上看起来天衣无缝，但实际上，所有法律手续都不符合实际情况。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;无抵押贷款&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;无抵押贷款，又叫无担保贷款，也是我们平常所说的信用贷。真正的无抵押贷款有吗？&lt;/p&gt;
&lt;p&gt;确实有，但是这种通常来自银行或者支付宝、微信，一般基于大数据分析你的工作、收入、住房、消费等情况，结合你的信用情况来发放贷款。额度比较科学，对发款方来说，风险也比较低。&lt;/p&gt;
&lt;p&gt;我们今天讨论的“无抵押贷款”，主要是指网上常见的那种广告语，承诺得天花乱坠，就是为了哄你上钩。当然，这也是套路贷中的一种。&lt;/p&gt;
&lt;h2 id=&#34;310-危险酒驾为什么被罚那么重&#34;&gt;3.10 危险！酒驾为什么被罚那么重？
&lt;/h2&gt;&lt;h3 id=&#34;310-1--引子&#34;&gt;3.10. 1  引子
&lt;/h3&gt;&lt;p&gt;元旦出门办事时，朋友大宝正好同路，所以我就坐了趟真正的“顺风车”。正系安全带时，我突然看到前面的手扣里，放了一瓶二锅头。还没等问出口，大宝就一脸炫耀地告诉我，放这瓶酒的目的是为了防止酒驾被抓。&lt;/p&gt;
&lt;p&gt;我非常惊讶，这是哪来的歪理？大宝说出了他所谓的办法，如果酒后开车被警察查住了，那就立刻拿着这瓶“救命酒”下车，然后当着警察的面把酒给喝了。这样，警察就不能认定刚刚他是酒后开车了。&lt;/p&gt;
&lt;p&gt;听完大宝的说法，我差点没直接动手抽他。这是对法律有多大的误会啊，才会觉得“救命酒”能钻得了法律的空子。我估计不少人都听过这样的法子，甚至有人实践。&lt;/p&gt;
&lt;p&gt;事实上，如果你酒驾被查住后，当着警察的面喝酒，真的能躲过处罚吗？如果不能，又会怎样呢？&lt;/p&gt;
&lt;h3 id=&#34;3102-法律知识&#34;&gt;3.10.2 法律知识
&lt;/h3&gt;&lt;p&gt;2011 年的 5 月 1 日，对很多酗酒分子并不那么友好。因为《刑法》再一次修正了，因为醉酒驾车正式入刑了。&lt;/p&gt;
&lt;p&gt;从那一天起，《中华人民共和国刑法修正案 (八)》正式实施，其中规定，在道路上醉酒驾驶机动车的，处拘役，并处罚金。从此，全国开始加大对饮酒驾驶机动车的打击力度。&lt;/p&gt;
&lt;p&gt;这里我要区分一下，刚刚提到的两个词，饮酒驾车和醉酒驾车。都是酒后驾车，而法律上对这两者的区分，主要在于血液中的酒精含量。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;饮酒驾车，是指你开车时，血液中的酒精含量大于或等于 20mg/100ml，但是小于 80mg/100ml。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;醉酒驾车，是指你开车时，血液中的酒精含量大于或者等于 80mg/100ml。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;危险驾驶罪，是指在道路上驾驶机动车的这么几种行为。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;追逐竞驶（比如飙车），并且情节恶劣的行为；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;醉酒驾车的行为；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;校车或者客车，严重超载或者严重超速的行为；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运输危险化学品，危害公共安全的行为。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于这个罪名，生活中最常见的犯罪行为，其实就是醉酒驾驶和追逐竞驶。很多追逐竞驶的例子，往往也是因为喝了酒。&lt;/p&gt;
&lt;p&gt;也就是说，只要你喝了酒又去开车，被查到体内血液的酒精含量大于或等于 80mg/100ml，就构成了危险驾驶罪，会被判处拘役。&lt;/p&gt;
&lt;p&gt;现实生活中，醉酒驾驶被抓后，一般走“快审快结”程序，大概三个月的时间，就能从侦查开始，到审判结案。同时，要注意的是，酒驾被抓基本不能被取保候审。&lt;/p&gt;
&lt;h3 id=&#34;3103-情景分析&#34;&gt;3.10.3 情景分析
&lt;/h3&gt;&lt;p&gt;现在再来看大宝的所谓攻略，真得承认就是个昏招。真要那么做了，他可能遇到这么几种情况。&lt;/p&gt;
&lt;p&gt;第一种，大宝本身喝了酒，但是血液中的酒精含量低于 20mg/100ml，那就不属于法律上的饮酒驾车，遇到警察也不会被处罚。&lt;/p&gt;
&lt;p&gt;但是，在他当着警察的面喝完二锅头后，情况就不一样了。警察将会按喝完后的情况来判定，也就是说，很有可能这时的血液中酒精含量超标，那进看守所这事儿基本没得跑了，危险驾驶罪在等着他。&lt;/p&gt;
&lt;p&gt;第二种，大宝本身喝了酒，血液中的酒精含量大于或等于 20mg/100ml，小于 80mg/100ml，那就属于法律上的饮酒驾车，会被警察暂扣六个月的驾驶证，驾驶证上也会被记 12 分。同时他会被罚款 1000 元到 2000 元。&lt;/p&gt;
&lt;p&gt;同样，如果他当着警察的面再喝酒，跟上面情况一样，等于板上钉钉进看守所。&lt;/p&gt;
&lt;p&gt;第三种，大宝本身喝了酒，并且血液中的酒精含量大于 80mg/100ml，那他会直接构成危险驾驶罪，被判六个月以下的拘役，驾驶证也会被吊销。&lt;/p&gt;
&lt;p&gt;不要以为这就是最严重的情况，所以觉得再当着警察面喝酒也没啥影响。事实上，如果这时候他再喝一瓶二锅头，血液中的酒精含量肯定还会继续增加，一旦超过 200mg/100ml，面临的就是危险驾驶罪从重处罚的结果了。&lt;/p&gt;
&lt;h2 id=&#34;311-发生交通事故如何处理&#34;&gt;3.11 发生交通事故，如何处理？
&lt;/h2&gt;&lt;h3 id=&#34;3111-引子&#34;&gt;3.11.1 引子
&lt;/h3&gt;&lt;p&gt;我们先来看看周律师郁闷的一天。&lt;/p&gt;
&lt;p&gt;还记得 2018 年 12 月最冷的一天，从我起床后，脑子就一直特别晕乎。状态不太好，我也不准备加班了，想着就去首都图书馆坐会儿，找两本书看看得了。&lt;/p&gt;
&lt;p&gt;状态不好时，往往运气也比较差。到达停车位时，我一不小心就把路边停着的一辆车给蹭了。虽然那辆车本身停得比较斜，没有入位，可车主不在，又是我把别人的车给蹭了。哪怕天寒地冻，穿得很薄，我也不敢擅自离开。&lt;/p&gt;
&lt;p&gt;这时，刚好一好友打电话找我。我告诉了他这个情况，好友觉得既然对方停车不规范，也不能全怪我，就建议我直接走人，不用再等。这种情况下，究竟应该怎么办呢？等，还是不等？&lt;/p&gt;
&lt;p&gt;在给出我的解决方案之前，老规矩，我们先来了解一下相关的法律知识。&lt;/p&gt;
&lt;h3 id=&#34;3112-法律知识&#34;&gt;3.11.2 法律知识
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;道路交通事故&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我国法律规定的道路交通事故，指的是车辆在道路上的行驶途中，因过错或者意外造成的，人身伤亡或者财产损失的事件。&lt;/p&gt;
&lt;p&gt;这里有几个关键词，“道路”“车辆”“过错或意外造成”“人身伤亡或财产损失”。在交通事故的定义中，这几个词缺一不可，否则就可能算不上是法律上所讲的道路交通事故。&lt;/p&gt;
&lt;p&gt;首先是“道路”，不仅包括公路、城市道路这些常见的道路，还包括那些虽然在单位管辖范围，但是允许社会机动车通行的地方，比如广场、公共停车场等公众通行的场所。常见的小区内的路面，就属于“道路”。&lt;/p&gt;
&lt;p&gt;接着是“车辆”，构成道路交通事故，必定要和车辆有关。比方说，因为天冷路滑，某人在道路上自已摔倒受伤，就不能叫道路交通事故，而属于人身损害。当然，这里的车辆，既包括机动车，也包括了非机动车。我们常见的自行车、电动车，就属于非机动车。&lt;/p&gt;
&lt;p&gt;再来看“过错或意外造成”，这里就排除了那些故意造成的事故。一般来说，故意造成事故涉及到的可能是骗取保险（俗称的“骗保”）或故意犯罪等问题，属于严重刑事犯罪问题。&lt;/p&gt;
&lt;p&gt;最后来看“人身伤亡或财产损失”，既然被称为事故，自然是因为有损失，不论是人身受到了损害，还是有财产损失，都属于这个范围，否则就不能构成事故。当然这也可能是单方的，某人造成了自已的财产损失，或他人的财产损失，对方并没有过错。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;交通事故逃逸&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;交通事故逃逸，顾名思义，是指某人发生交通事故后，为了逃避法律责任而逃跑的行为。常见的交通事故逃逸有这么几类情况：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;明知道已经发生交通事故，仍然驾车逃离现场；&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;事故发生后，自认为没有责任（事实相反），直接离开现场；&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;有酒驾或无证驾驶的嫌疑，报案后不在现场等候处理，弃车离开现场又重新返回；&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;发生事故后，把伤者送到了医院但没有报案，并且无故离开了医院或留下假地址、假姓名、假电话后离开医院；&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;离开现场且不承认发生过交通事故，但有证据证明，他应该知道事故发生；&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;事故发生后，双方协商不能达成一致意见，所以没有留下真实信息，强行离开现场等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些都是最常见的情况。然而，一旦有交通事故逃逸行为，你需要承担事故的全部责任，除非你能证明对方也有过错，才可以适当减轻。这个漏子真心钻不得，逃是逃不了的。&lt;/p&gt;
&lt;p&gt;至于具体的处罚，主要分下面这几种情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;发生交通事故后逃逸，但是不构成刑事犯罪的，由公安机关交通管理部门，处 200 元以上 2000 元以下的罚款，可以并处 15 日以下的拘留。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;发生交通事故，并且构成犯罪的，依法追究刑事责任，并由公安机关交通管理部门吊销驾驶证（醉酒驾驶要求五年不能再考取，一般情节的犯罪要求两年不能再考取）；如果还有逃逸情节的，吊销驾驶证，且终生不能重新取得驾驶证。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果是更严重的交通肇事罪，处 3 年以下有期徒刑或者拘役；交通肇事后逃逸的，处 3 年以上 7 年以下有期徒刑；因为逃逸导致伤者死亡的，处 7 年以上有期徒刑。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;发生事故怎么办？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过上面的学习，你应该知道我的处理原则了，那就是坚决不能不辞而别。虽然整个过程很苦逼，但我还必须就这么处理。&lt;/p&gt;
&lt;p&gt;首先，我先下车查看情况。判断自已应该负全责，就赶紧拨打了保险公司的电话。在保险公司指导下，我从前后左右等不同角度拍了 8 张照片， 然后把车开到空余停车位停好，等待保险公司的后续动作。（30 分钟左右）&lt;/p&gt;
&lt;p&gt;然后，我拨打交通事故报警电话“112”，告诉了事故的基本情况，然后等接警平台安排交通队的工作人员联系我。挂完电话没多久，交通队的电话来了，问清楚情况后，开始帮我联系被蹭车辆的车主。因为车主电话无人接听，交通队决定派出交警来现场处理，同时要求我继续在现场等待。（30 分钟左右）&lt;/p&gt;
&lt;p&gt;终于，我等来了交警，他们开始勘查现场并且登记情况、划定责任，而我也认可他们给出的全责结果。后来，交警安排我可以开车离开，如果车主联系上交通队，他们再联系我。我总算是能回去了。&lt;/p&gt;
&lt;p&gt;最后，到了晚上，交通队又打电话来，说是车主联系上了，让我到交通队去拿事故责任认定书。第二天我去交通队解决了此事，又把车子送去维修，完结了这次事故。&lt;/p&gt;
&lt;p&gt;如果那天我直接走人，会是怎样的后果呢？那估计可能是两种结果，要么虽然顺利逃逸，但是心里一直惴惴不安，像是等待审判未果的犯人；要么逃逸失败，然后警察打来电话，通知我去接受处理，且不说 200 到 2000 元不等的罚款，能不能逃得过拘留也是未知的。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>区块链学习--7从业区块链</title>
        <link>https://zhenyu0324.github.io/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0--7%E4%BB%8E%E4%B8%9A%E5%8C%BA%E5%9D%97%E9%93%BE/</link>
        <pubDate>Sun, 14 Feb 2021 01:00:05 +0800</pubDate>
        
        <guid>https://zhenyu0324.github.io/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0--7%E4%BB%8E%E4%B8%9A%E5%8C%BA%E5%9D%97%E9%93%BE/</guid>
        <description>&lt;h2 id=&#34;71-从业区块链需要了解什么&#34;&gt;7.1 从业区块链需要了解什么？
&lt;/h2&gt;&lt;h3 id=&#34;711-行业现状&#34;&gt;7.1.1 行业现状
&lt;/h3&gt;&lt;p&gt;目前区块链领域的人才需求大致可以分为以下几种。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;根据客户的需求，搭建基于 DLT 技术的分布式账本应用，在 DLT 上实现客户要求的业务需求，这类与传统解决方案型的人才十分接近。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;公司已经具有了某些行业的资深经验，目标是通过技术选型选择某个公链，在此公链上开发基于区块链的应用。目前游戏与社交类的项目比较成熟，游戏类有以太养猫、LeBloc 等，内容社区类有 Steemit、币问、币乎等项目。这一类的特点是可以很好地与现有技术结合，在业务层面利用区块链的资产数字化特性，商业潜力大，技术发展空间也很大，进入门槛较低，风险较低。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;公司获得融资或者在海外发起 ICO，目标是研发新一代公链，这一类是为了通过改进现有的区块链技术不足而创建的项目，技术发展空间最大，进入门槛最高，风险也最高。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;区块链生态基础设施类。数字资产交易平台、数字资产管理、移动钱包、硬件冷钱包、数字金融媒体、区块链咨询、矿池运营等都属于此类，这些都是目前商业利润最高的区块链产业，技术发展空间较大，进入门槛较低，风险也较低。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;目前区块链的人才供应需求远远不足以支撑如此庞大的市场。换句话说就是人才极度稀缺，人才的稀缺与过高的估值形成鲜明对比，这也就是泡沫的形成。&lt;/p&gt;
&lt;h3 id=&#34;712-人才现状&#34;&gt;7.1.2 人才现状
&lt;/h3&gt;&lt;p&gt;我们分析了区块链行业的现状，接下来我们看看现有的人才构成。我们如果把现在互联网的人才划分一下，大致分为 5 个类别：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;技术决策者，这类主要指 CTO、技术总监、技术专家等；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;代码生产者和维护者，也就是广大 IT 从业者、开发工程师；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;需求产生和归纳者，产品经理、需求分析师；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;交互与可视化，前端工程师、UI/UE 与视觉设计等；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;产品运营，实际与用户接触，吸纳和维持用户。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;目前的区块链产业基本以数字货币交易、数字资产管理、资讯类 App 为主，细分来说就是移动 App 钱包、炒币用行情工具、区块链资讯类 App，以及一些简单的区块链 App 应用，对人才的需求大致符合互联网产业的需求，也就是上述 5 类人才都是需要吸纳的。&lt;/p&gt;
&lt;p&gt;我们可以发现区块链产品的模式还比较单一，处于非常早期的状态。但就算是这些单一的 App 应用，从业人员也是不足的。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>区块链学习--6区块链与当下互联网</title>
        <link>https://zhenyu0324.github.io/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0--6%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E5%BD%93%E4%B8%8B%E4%BA%92%E8%81%94%E7%BD%91/</link>
        <pubDate>Sun, 14 Feb 2021 00:49:44 +0800</pubDate>
        
        <guid>https://zhenyu0324.github.io/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0--6%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E5%BD%93%E4%B8%8B%E4%BA%92%E8%81%94%E7%BD%91/</guid>
        <description>&lt;h2 id=&#34;61-互联网身份与区块链数字身份&#34;&gt;6.1 互联网身份与区块链数字身份
&lt;/h2&gt;&lt;h3 id=&#34;611-什么是身份&#34;&gt;6.1.1 什么是身份
&lt;/h3&gt;&lt;p&gt;数字身份是一个依托互联网产生的概念，那么在谈论数字身份之前，我觉得有必要先和你达成一下“身份”这个概念的共识。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;身份是指有关你发生的一切客观历史的事件集合。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;例如，你的身份证上简要记录了有关你的客观事实：你的出生日期、民族、户籍所在地，为了证明这些信息属实，所以国家给了这么一个证件，为此还戳上了一个唯一编号，也就是你的身份证号。&lt;/p&gt;
&lt;p&gt;但我们要弄清楚的是，身份证并不是你的身份，只是你的凭证，你真正的身份托管在政府机构、银行、医院、社交平台的数据库中，换句话说，有关你的重要客观历史事件记录被这些机构所记录下来，这些记录组成了独一无二的你，使得你变得具有一定的辨识度。&lt;/p&gt;
&lt;p&gt;你的身份记录也分为了两种，一种是资产和消费记录，另外一种是社交记录。支付宝做了前者，微信做了后者，这两者都是中心化的设施。&lt;/p&gt;
&lt;p&gt;从历史上来看，身份主要经历了三个阶段。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;印章实物身份&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个很好理解，就是自己给自己颁发一个刻章，这个章由于带有私人标记，一般独此一份，很难被人模仿，例如玉玺、虎符等，这些就是为了表达身份的概念。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;卡片型身份&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;随着技术发展，卡片的流行发展了身份的概念，这里的典型就是名片、护照、身份证、驾照等等。&lt;/p&gt;
&lt;p&gt;但这些卡片背后记录的依然是割裂的身份片段，例如医院就诊记录归医院所有，出入境记录归出入境管理局所有，商场消费记录归商场所有，这些记录都是割裂的。&lt;/p&gt;
&lt;p&gt;如果出入境管理要你出具商场的消费记录，显然就变成了你的跑腿工作，这就是你的身份片段割裂所引起的。&lt;/p&gt;
&lt;p&gt;不过这种情况在国内稍有改善，这得益于身份实名制的强制实施，身份证编号是被所有系统统一的唯一索引，通过打通身份后台系统，可以共享一些基本信息。&lt;/p&gt;
&lt;p&gt;卡片型身份也在自我迭代，目前多数都被做成了芯片卡的样式，里面集成了一些基本的终端验证信息，所以可以提供电子化身份。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;互联网身份&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个阶段就有了一些真正意义上的身份概念了。&lt;/p&gt;
&lt;p&gt;你的出生地、户籍、微信朋友圈的记录、授权过的 App、消费记录、挂号就医记录，通过微信或支付宝可以将以往的身份片段串联起来，形成一个可定义你的唯一身份。&lt;/p&gt;
&lt;h3 id=&#34;612-现阶段的身份问题&#34;&gt;6.1.2 现阶段的身份问题
&lt;/h3&gt;&lt;p&gt;总结来说，我们正处于卡片型和信息化身份混用的阶段，我们在日常交流中需要的身份证件，例如护照、驾照、社会保险卡、商品序列号等，基本都是由国家或第三方机构颁发的，虽然这可能是模拟现实世界运作的首要方法，但这种方式也逐渐凸显了许多问题。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;如果国家撤销其证书，个人可能会失去他们的身份，身份应当是与生俱来的概念，国家可以选择承认与否，但不应该存在黑户这样的人群。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;某个中心机构签发的身份证明，往往不能被其他机构所接受。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;集中控制的身份管理，只能在一个辖区或一个在线服务内有效。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;随着区块链的出现，身份证明的瓶颈逐渐缓解，就像使用比特币并不需要申请账户一样，它也创造了重新定义身份的崭新机遇。&lt;/p&gt;
&lt;h3 id=&#34;613-从互联网身份到区块链数字身份&#34;&gt;6.1.3 从互联网身份到区块链数字身份
&lt;/h3&gt;&lt;p&gt;互联网本身其实是围绕着机器建立的，而不是人类，换句话说，互联网虽然提供了信息高速公路，但是并没有提供中立、开放、统一的身份层。&lt;/p&gt;
&lt;p&gt;W3C 以及一些标准化组织，提供了一些互联网身份的标准。这些标准的初衷是为了更好地服务互联网应用，但是这些标准被实施的过程中，仍然凸显了很多问题，例如前段时间 Facebook 8000 多万账户数据滥用事件。&lt;/p&gt;
&lt;p&gt;面对这些问题，我们这里总结了互联网身份问题以下的几个点。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;身份数据的安全性问题，面临泄露和被篡改的风险。&lt;/li&gt;
&lt;li&gt;不同机构之间的身份数据的兼容成本很高，带来身份数据碎片化且不一致的问题。&lt;/li&gt;
&lt;li&gt;用户无法控制属于自己的数据，例如你今天发布的照片，并不知道会被哪个推荐系统采用。&lt;/li&gt;
&lt;li&gt;重复创建和管理不同应用下的身份，典型案例就是重复注册各种账户。&lt;/li&gt;
&lt;li&gt;虚假身份欺诈，这个比较好理解，就是被我的身份被盗用，尤其在账户泄露的时候。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;概括起来主要是三个方面：非用户自主的身份、身份数据安全与隐私问题、身份数据所有权问题。&lt;/p&gt;
&lt;p&gt;如果想做区块链数字身份，我认为，这里必须涵盖身份的两大核心功能：&lt;strong&gt;验证和授权&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当然，机遇越大，挑战也越大。这里，我也总结了一下区块链数字身份面临的三个挑战。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如何控制个人身份在区块链上的隐私边界？&lt;/li&gt;
&lt;li&gt;现实中会产生庞大的身份数据，区块链无法承载这么多数据该如何解决？&lt;/li&gt;
&lt;li&gt;如何兼容上述三种类型的身份，例如已经存在的互联网身份？&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;62-区块链即服务baas&#34;&gt;6.2 区块链即服务BaaS
&lt;/h2&gt;&lt;p&gt;“区块链即服务”，也就是 Blockchain as a Service。&lt;/p&gt;
&lt;h3 id=&#34;621-什么是区块链即服务&#34;&gt;6.2.1 什么是“区块链即服务”
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Paas&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;PaaS 的英文是“Platform as a Service”&lt;/p&gt;
&lt;p&gt;它是一组通用业务组件（Component）的集合，它能够提供开箱即用的业务服务，但并不类似于 AWS 的 Amazon Translate 服务、阿里云的短信服务这样单纯的技术框架或者代码包。&lt;/p&gt;
&lt;p&gt;例如我们希望可以在云计算平台快速实例化一个比特币的全节点，而不是自己去比特币的官网下载，并经历将区块同步至最新的漫长过程。&lt;/p&gt;
&lt;p&gt;从技术角度考虑，比特币全节点本身提供的查询 API 功能有限，查询负载也非常有限，我们不可能使用部署多个比特币钱包集群的方式来分担负载，因为全节点的数据非常庞大，5 个比特币全节点已经是 TB 级别，而且还在一直增长。&lt;/p&gt;
&lt;p&gt;随之而来的，还有各种区块链软硬分叉维护、节点宕机监控，简直是噩梦。&lt;/p&gt;
&lt;p&gt;但是暂停一下，我们回过头来看看，这难道不就是以往 PaaS 解决过的痛点吗？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;“区块链即服务”是指：提供多种方式的查询、交易广播、交易验证服务，使得公有区块链的服务可以集成到到互联网应用的架构中，这些服务包括了数字货币、数字资产、身份验证服务、第三方监管服务。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;622-架构集成与快速构建&#34;&gt;6.2.2 架构集成与快速构建
&lt;/h3&gt;&lt;p&gt;架构集成主要考虑在已知的系统架构模式情况下，如果让“区块链即服务”可以更快速方便地被已有架构集成。&lt;/p&gt;
&lt;p&gt;这里的挑战困难主要包括两个方面:&lt;/p&gt;
&lt;p&gt;第一、系统级的多币种私钥管理体系。因为区块链本身就包含了大量资产，这些资产可以看做是线上资产，如果有没有进行良好的权限管理，那么资产将面临极大的失窃风险。&lt;/p&gt;
&lt;p&gt;第二、稳定可控的区块链服务。稳定可用是考虑任何一个钱包稳定连续运行，一旦被控制或者被分叉，系统可以快速识别并警告运营者。&lt;/p&gt;
&lt;h3 id=&#34;623-互联网公司在区块链领域的尝试&#34;&gt;6.2.3 互联网公司在区块链领域的尝试
&lt;/h3&gt;&lt;p&gt;一线互联网公司更倾向 DLTs（destributed leder technology) 技术，也就是 BTaaS 类，三四线以及业绩边缘化的互联网公司倾向于 Token 为代表的经济生态，也就是 BaaS 技术。&lt;/p&gt;
&lt;p&gt;下面是我们公司的 Frank 收集分类的国内应用案例，涉及的行业有金融、公益、互联网、食品溯源、物流、电商等领域，我在这里列出来供你参考。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;蚂蚁金服区块链，联盟链。 蚂蚁金服技术实验室宣布开放区块链技术，支持进口食品安全溯源、商品正品溯源、支付宝爱心捐赠平台。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;阿里健康区块链，联盟链。 阿里与常州市政府就医疗数据保护达成共识，推出了国内首个在医疗行业的区块链解决方案——阿里健康。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Symbiont，其起源于 Counterparty（合约币）项目，旨在建立第一个用于发行区块链智能证券和交易智能证券的平台。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;跨境食品溯源，联盟链。 阿里巴巴与普华永道（PwC）达成合作关系共同开发一种使用区块链技术的系统来减少食品假冒。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;阿里邮箱 + 法链，公链。 将使用名为“法链”的区块链技术，推出基于阿里云平台的邮箱存证产品等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;阿里云 +Hyperledger，联盟链。 阿里云上推出了 Hyperledge Fabric 区块链自动化配置和部署的解决方案。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数字雄安区块链实施平台，联盟链。 阿里巴巴、蚂蚁金服与雄安签署战略合作协议，将承建“数字雄安区块链实施平台”。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;天猫奢侈平台 Luxury Pavilion 溯源，联盟链。 阿里云发布区块链解决方案，支持天猫奢侈平台 Luxury Pavilion 推出全球首个基于区块链技术的正品溯源功能。未来消费者只需点击“一键溯源”，便可了解产品产地、入境报关时间等信息。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;金链盟 FISCO BCOS 区块链平台，联盟链。 由腾讯牵头，集结了微众银行、平安银行、招银网络、京东金融、华为等 31 家企业。旨在整合及协调金融区块链技术研究资源，形成金融区块链技术研究和应用研究的合力与协调机制，提高成员单位在区块链技术领域的研发能力，探索、研发、实现适用于金融机构的金融联盟区块链，以及在此基础之上的应用场景。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;微黄金，联盟链。 腾讯财付通与工商银行合作，以工商银行的黄金产品为基础，联合推出的在线黄金交易服务。其中，由腾讯提供联盟链的底层技术支持。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;公益寻人链，联盟链。 将区块链技术应用到公益领域，连接腾讯内部多个寻人平台，实现各大公益平台的信息共享。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;星贝云链，联盟链。 以腾讯区块链技术为底层打造的供应链金融服务平台“星贝云链”，是国内首家与银行战略合作共建的基于区块链的供应链金融平台，也是国内首个基于大健康产业构建的供应链金融平台。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;TrustSQL，联盟链。 腾讯发布区块链项目 TrustSQL，旨在以区块链基础设施构建安全高效的解决方案，为企业及机构搭建价值连接器，共同推动价值互联网发展。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;腾讯云金融级解决方案 BaaS，联盟链 + 私链。 腾讯云发布区块链金融级解决方案 BaaS(Blockchain as a Service)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;腾讯云 +Hyperledger，联盟链。 腾讯云加入 Hyperledger，参与国际区块链生态建设，推动区块链技术以及相关标准的制定。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;区块供应链联盟链 + 云单平台，联盟链，腾讯与中国物流与采购联合会（简称“中物联”）签署了战略合作协议，并发布了区块供应链联盟链及云单平台。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;京东区块链平台，联盟链。 京东发布自己的区块链平台，愿景是协同盟友构建新一代基于互联网的“可信价值传递基础设施”，服务于商业数据的高效可信传递。与此同时，京东积极推动自身的零售和供应链大数据“上链”，通过场景数据在区块链中的传递，助力基于区块链技术实现规模化应用，建立社会化跨主体共享的区块链联盟链网络。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;国内信用证信息传输系统，联盟链。 苏宁银行加入由中信银行上线的国内首个区块链信用证信息传输系统，成为联盟成员。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;区块链黑名单共享平台，联盟链。 苏宁金融宣布上线基于区块链黑名单共享平台系统，即采用超级账本 Fabric 联盟链技术，将金融机构的黑名单数据加密存储在区块链上，金融机构可通过独立部署节点接入联盟链，开展区块链黑名单数据上传和查询等业务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;小米移动 +Hyperledger，联盟链。 北京小米移动软件加入超级账本项目。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;网易星球，区块链应用。 网易星球为用户构建星球居民身份，集合用户的社交、娱乐、购物、出行等相关数据（实际跟区块链技术并无天多关系）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;玩客云，区块链应用。 迅雷推出基于区块链技术的玩客云共享计算生态、CDN 共享经济，并发行代币玩客云（现已改名链克，停止了内地转账功能）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;迅雷链，公链。 迅雷发布了拥有百万级并发处理能力的区块链项目——迅雷链。采用独创的同构多链框架，在业内率先实现了链间的确认和交互，不同交易可以分散在不同链上执行，从而达到百万 TPS。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;暴风播酷云，区块链应用。 它是一台可以赚取 BFC 积分的家庭私人影院智能终端。在非工作状态下，用户通过闲置的存储空间和宽带帮助暴风系列软件、第三方 CDN 业务、第三方区块链业务进行超大文件网络加速甚至区块链网络全节点部署，不仅可以共享资源，还可以赚取 BFC 积分。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;63-数字货币钱包服务&#34;&gt;6.3 数字货币钱包服务
&lt;/h2&gt;&lt;h3 id=&#34;631-数字货币钱包的分类&#34;&gt;6.3.1 数字货币钱包的分类
&lt;/h3&gt;&lt;p&gt;下图展示了按照不同属性区分的区块链钱包。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0--6%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E5%BD%93%E4%B8%8B%E4%BA%92%E8%81%94%E7%BD%91/post/blockchain6/01.jpeg&#34;
	width=&#34;926&#34;
	height=&#34;504&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0--6%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E5%BD%93%E4%B8%8B%E4%BA%92%E8%81%94%E7%BD%91/post/blockchain6/01_hu_e6a79e1fbc85c204.jpeg 480w, https://zhenyu0324.github.io/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0--6%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E5%BD%93%E4%B8%8B%E4%BA%92%E8%81%94%E7%BD%91/post/blockchain6/01_hu_a08d2e16712aafbe.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;183&#34;
		data-flex-basis=&#34;440px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;左一是按照用户端平台划分的钱包，这种钱包实际是在服务端运行的，用户端的钱包实际上只是一个代理，所以用户不需要关心钱包的细节，使用起来十分方便，典型的例子是各种在线钱包。&lt;/p&gt;
&lt;p&gt;左二是按照货币类型分类的钱包，主要是指这款钱包到底是否支持多币种，这里的多币种可以是基于以太坊 ERC20 Token 的同一个区块链上的多币种，也可以是集成了比特币和以太坊等不同区块链的多币种。&lt;/p&gt;
&lt;p&gt;右二是按照私钥存储的方式来区分的钱包，实际上这里主要涉及了用户私钥是否被平台托管，如果不托管直接存储在用户端，也就是硬件、终端设备、纸质记录，这些都可以被称为 On-chain 的钱包；如果用户无法接触到私钥，私钥被托管在平台，那么这种钱包也被称为 Off-chain 的钱包。&lt;/p&gt;
&lt;p&gt;右一是按照访问方式进行分类的钱包，例如可以多个人共同管理，同时它也是需要多重签名支持的钱包，否则就变成了个人私有的钱包。&lt;/p&gt;
&lt;p&gt;以上的分类并不是绝对的，一个钱包可以兼具以上不同的属性，例如某个 Mobile 钱包是提供 On-chain 的，也提供多重签名、提供多币种的钱包，这种钱包通常就是业界比较流行的钱包类型。&lt;/p&gt;
&lt;h3 id=&#34;632-扫描区块技术-block-scan&#34;&gt;6.3.2 扫描区块技术 Block scan
&lt;/h3&gt;&lt;p&gt;我们之前在深入区块链技术部分介绍过，构成区块链的四个核心技术是：P2P 网络协议、分布式一致性算法、加密签名算法、账户与交易模型。这四个技术对应到数字货币钱包中就是，P2P 网络、持久化存储、账户以及私钥管理、共识与交易验证四大模块。&lt;/p&gt;
&lt;p&gt;其中，持久化存储模块是由全节点钱包自带的嵌入式数据库提供的，这里有 LevelDB、BerkerlyDB、SQLite3 等多种选择。&lt;/p&gt;
&lt;p&gt;对于平台开发来说，显然选择服务器级别的数据库是更为合适的选择。那么这里就涉及了一个问题，如何把全节点钱包中的数据转换成为数据库服务器中的数据，这就需要用到一种扫描区块技术，简称扫块。&lt;/p&gt;
&lt;p&gt;扫块，顾名思义，就是指扫描全节点钱包中的所有区块，然后将其解析后存储到数据库服务器的过程，这些数据库可以是 MongoDB，也可以是 MySQL，取决于你的业务需要。&lt;/p&gt;
&lt;h3 id=&#34;633-区块浏览器&#34;&gt;6.3.3 区块浏览器
&lt;/h3&gt;&lt;p&gt;扫块，顾名思义，就是指扫描全节点钱包中的所有区块，然后将其解析后存储到数据库服务器的过程，这些数据库可以是 MongoDB，也可以是 MySQL，取决于你的业务需要。&lt;/p&gt;
&lt;p&gt;从技术上看，一个区块浏览器的主要工作就是把区块扫描到数据库服务器中，然后搭建一个 Web 访问服务，用户只需要输入交易哈希或者区块哈希，即可查询到交易是否已经被打包和确认。&lt;/p&gt;
&lt;p&gt;目前比特币和以太坊的流行区块浏览器比较多，不局限在某一个区块浏览器，因为大家看到的区块数据是一样的，区别就是如何更好地展示，做得更好的话，还可以集成一些咨询和资产托管的功能。&lt;/p&gt;
&lt;p&gt;从产品意义上来说，我认为区块浏览器更适合叫做资产浏览器，因为它为人们提供了资产证明的服务，而不必肉眼识别交易或者自行手动解析交易，一般来说，区块浏览器也提供基本的 API 查询服务。&lt;/p&gt;
&lt;h2 id=&#34;64-区块链与供应链&#34;&gt;6.4 区块链与供应链
&lt;/h2&gt;&lt;h3 id=&#34;641-供应链领域&#34;&gt;6.4.1 供应链领域
&lt;/h3&gt;&lt;p&gt;供应链领域又分供应链管理和供应链金融，我们先从供应链管理开始。&lt;/p&gt;
&lt;h4 id=&#34;6411供应链管理&#34;&gt;6.4.1.1供应链管理
&lt;/h4&gt;&lt;p&gt;供应链管理就是指对整个供应链系统进行计划、协调、操作、控制和优化的各种活动和过程，其目标是使这一过程所耗费的总成本最小。需要注意的是：这里的总成本是指整个供应链参与的企业总成本最小，不是指单个环节的成本最小。&lt;/p&gt;
&lt;p&gt;我们已经知道了，供应链涉及了供应商、制造商、渠道商等角色。那么连接这些角色的，主要是采购（Purchasing）、库存（Inventory）、物流（Logistics）等一系列事务。采购、库存和物流主要围绕仓储、配送中心、物流运输展开，所以我们也可以把供应链看作是由供应商、制造商、渠道商、仓库、配送中心、物流运输等构成的网络。&lt;/p&gt;
&lt;p&gt;在这个网络之中，各个角色之间最大的问题就是信任问题，因为只有建立信任才能协作完成一个完整的产品制造和销售过程。供应链管理面对的首要问题就是如何降低信任成本，将原本松散的企业形成互信的链式结构，每个角色必须通过有效的链上管理来协调自身和外部的资源，从而满足市场需求。&lt;/p&gt;
&lt;p&gt;在这个链式结构中，有信息流、物流、资金流三种流动过程。&lt;/p&gt;
&lt;p&gt;信息流：是指每个角色需要了解并追踪产品在供应链中的当前位置和状态；
物流：是指产品或原材料被转移到目标角色手中的过程；
资金流：是指上下游资金结算的过程。
&lt;img src=&#34;https://zhenyu0324.github.io/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0--6%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E5%BD%93%E4%B8%8B%E4%BA%92%E8%81%94%E7%BD%91/post/blockchain6/02.jpeg&#34;
	width=&#34;1286&#34;
	height=&#34;650&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0--6%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E5%BD%93%E4%B8%8B%E4%BA%92%E8%81%94%E7%BD%91/post/blockchain6/02_hu_1ec7fb6d794634fe.jpeg 480w, https://zhenyu0324.github.io/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0--6%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E5%BD%93%E4%B8%8B%E4%BA%92%E8%81%94%E7%BD%91/post/blockchain6/02_hu_6e02ae71857c85f2.jpeg 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;197&#34;
		data-flex-basis=&#34;474px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;上述图片展示了在供应链管理过程中，物流指向需求侧，资金流指向供应侧，信息流则需要在各个角色之间共享。&lt;/p&gt;
&lt;p&gt;而目前供应链的现状是，资金流、信息流、物流各自独立运行，资金流靠银行，信息流靠供应链管理工具，物流靠运输行业，它们都是围绕一个或多个核心企业展开的，所以各个角色极度依赖核心企业，这种模式暴露了以下几个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;核心企业对上下游的延伸和掌控范围有限；&lt;/li&gt;
&lt;li&gt;上下游可能因为竞争关系，存在信息流作假和被篡改的风险。&lt;/li&gt;
&lt;li&gt;市场供需变化无法及时传导到供给侧，从市场需求到供给侧的风险依次放大。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;6412-供应链金融&#34;&gt;6.4.1.2 供应链金融
&lt;/h4&gt;&lt;p&gt;供应链金融和供应链是两个概念，因为多了金融两个字，于是严格来说，供应链金融属于金融的范畴，它是专门为供应链服务的金融。&lt;/p&gt;
&lt;p&gt;供应链金融 (supply chain finance, SCF) 可以泛指各种融资工具，它可用于为供应链中的各方提供资金，通过短期信贷手段来平衡上下游之间的流动资金差，从而最大限度地减少总供应链成本，企业也可以利用供应链融资与供应商建立更牢固的关系，降低金融风险和提高流动性。&lt;/p&gt;
&lt;p&gt;与其他金融一样，供应链金融的核心也是风险管理，良好的风险管理前提是供应链信息真实可靠的透明共享。传统供应链金融围绕银行展开，银行在供应链信息上的收集也受制于传统技术，并不能完全掌握企业之间的真实订单情况，那么风险控制则十分依赖对企业的信誉判断了。&lt;/p&gt;
&lt;p&gt;所以，如果所有的参与方都可以真实准确地查阅整个供应链的流程和状态，那么风险管理就变成了整个供应链参与方共同分担，而不仅仅只是核心企业和银行。&lt;/p&gt;
&lt;h3 id=&#34;642-区块链为供应链带来的新曙光&#34;&gt;6.4.2 区块链为供应链带来的新曙光
&lt;/h3&gt;&lt;p&gt;区块链为供应链主要带来了思维上的变革，不再是以围绕核心企业打造的生态，而是共治的生态，区块链作为基础设施可以为参与方提供良好的可信环境，从而降低供应链的成本。&lt;/p&gt;
&lt;p&gt;通过上文我们知道，供应链有三流：物流、信息流、资金流。理想的情况其实是“三流合一”，也就是由区块链本身提供信息流、资金流、物流三流管理。&lt;/p&gt;
&lt;p&gt;区块链应用到供应链上也有很多著名案例，比如业界经常提到的几个案例：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;马士基（Maersk）和 IBM 的海运保险区块链平台案例；&lt;/li&gt;
&lt;li&gt;沃尔玛利用区块链进行食品追踪溯源案例；&lt;/li&gt;
&lt;li&gt;众安的区块链养鸡场实时记录和追溯整个鸡的成长过程案例；&lt;/li&gt;
&lt;li&gt;海航科技基于区块链技术的物流端到端的虚实融合信息流平台。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;实际上，通过仔细分析我们可以发现，以上机构使用的是 DLT 技术，也就是联盟链，并非公链。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>区块链学习--5数字货币与数字资产</title>
        <link>https://zhenyu0324.github.io/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0--5%E6%95%B0%E5%AD%97%E8%B4%A7%E5%B8%81%E4%B8%8E%E6%95%B0%E5%AD%97%E8%B5%84%E4%BA%A7/</link>
        <pubDate>Sun, 07 Feb 2021 18:03:26 +0800</pubDate>
        
        <guid>https://zhenyu0324.github.io/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0--5%E6%95%B0%E5%AD%97%E8%B4%A7%E5%B8%81%E4%B8%8E%E6%95%B0%E5%AD%97%E8%B5%84%E4%BA%A7/</guid>
        <description>&lt;h2 id=&#34;51-比特币专题一历史与货币&#34;&gt;5.1 比特币专题（一）历史与货币
&lt;/h2&gt;&lt;h3 id=&#34;511-比特币的逆袭史&#34;&gt;5.1.1 比特币的逆袭史
&lt;/h3&gt;&lt;p&gt;比特币的历史总结起来大约有四个时期：创立前期、创立期、成长和稳定期。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创立前期&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在比特币创立之前，世界上已有多种类似技术产品，最早的是 Ecash 协议，接着 Ecash 又有多种数字货币产品出现，其中以亚当·贝克的“Hashcash”和戴维 (Wei Dai) 的“B-money”、尼克·萨博的“Bit-gold”，以及哈尔·芬尼在“Hashcash”技术上发展出来的“RPOW”等技术产品。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创立期&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2008 年 11 月，中本聪发表了比特币的白皮书《比特币：一种点对点的电子现金系统》，接下来的时间中本聪实现了他所描述的比特币系统。&lt;/p&gt;
&lt;p&gt;2009 年 1 月 3 日，比特币网络正式开始运行。&lt;/p&gt;
&lt;p&gt;2009 年 1 月 9 日，Bitcoin v0.1 版本发布，12 日中本聪进行了第一次交易，这一次交易中，中本聪给海尔发送了 10 个比特币。&lt;/p&gt;
&lt;p&gt;2009 年秋天, 一个叫“新自由标准”的用户通过 Paypal 支付了 5.02 美元，购买了 5050 个比特币，折合 0.000994 美元一个比特币，这是比特币和法币的第一次兑换。&lt;/p&gt;
&lt;p&gt;2009 年到 2010 年初，已经有一些其他的开发者被逐渐吸引过来，大家一起开发、维护、挖矿，那时候普通电脑还可以挖到比特币。&lt;/p&gt;
&lt;p&gt;2010 年 4 月, 一个叫拉斯诺的人发现可以使用 GPU 来挖比特币，5 月 22 日，他用挖到的比特币购买了两个比萨，共花费 10000BTC，这是比特币第一次被用于实物支付，也就是著名的比特币披萨事件。&lt;/p&gt;
&lt;p&gt;2010 年 7 月，世界上第一家比特币交易所在日本东京成立，名叫 Mt.Gox，中文“门头沟”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;成长期和稳定期&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;2014 年 2 月，发生“门头沟事件”，门头沟交易所被黑一事震惊全球，比特币价格应声跳水；&lt;/p&gt;
&lt;p&gt;2014 年 6 月，以太坊开始了为期 42 天的 ICO，众筹使用的是 BTC；&lt;/p&gt;
&lt;p&gt;2017 年 11 月 28 日，比特币价格超过一万美元。&lt;/p&gt;
&lt;h3 id=&#34;512-比特币的意义&#34;&gt;5.1.2 比特币的意义
&lt;/h3&gt;&lt;p&gt;首先比特币没有通常意义上的实用价值，不单单是比特币，所有的信用货币，包括黄金白银在内都不具备实用价值。&lt;/p&gt;
&lt;p&gt;这里的实用价值是指解决人的低层次需求，如果按照马斯洛需求层次理论来分，是指衣食住行等生存需求。&lt;/p&gt;
&lt;p&gt;比特币到底有什么不同？它的意义超过信用货币吗？我个人认为是超过的。老生常谈的去中心化、防篡改我这里就不谈了，我们接下来换几个角度来聊聊它。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.无国界的共识&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;它打破了一般信用货币的局限性，我称作无国界的共识。&lt;/p&gt;
&lt;p&gt;比较常见的论调，比特币你信它就有价值，不信就什么用途也没有。这里隐含的语义是“承认过程”。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.记账是本职&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比特币的本职是记账，不要想得太复杂，它就是来帮你记账的。例如你在宜家买了一套家具，比特币可以帮你记下来，当然不是说这个事件，而是帮你记录价值转移，你动用了你曾经创造的价值的多少（BTC）来购买这套家具。&lt;/p&gt;
&lt;p&gt;这个记账过程防篡改能力非常强，几乎没人能操控，也没有国界之分，只要你的交易方承认比特币，这笔买卖就可以达成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3.高效的资源调度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比特币使用的是 PoW 算法，这个需要消耗大量能源进行挖矿的算法一直被人诟病；但是结合上述记账本职，我们也换个角度来看看这件事。&lt;/p&gt;
&lt;p&gt;目前全国的电力分配不均，中国的内蒙东北有着丰富的风力电，可惜这些富余的电力难以调度，超高压输电线路造价高昂，甚至超出了电厂本身。&lt;/p&gt;
&lt;p&gt;而比特币挖矿恰好需要极大地耗费能源，如果在偏远的资源丰富地区进行挖矿，相当于将架设超高压输电线路蜕化为网络通信设施，地方政府可以把庞大的风电资源转化成比特币，最多只需要十分钟，就可以在资本市场变现。所以每个人每次使用比特币的过程，相当于让偏远地区获得了平等参与社会运作的过程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 三权分立的社区自治形态&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这里讨论的三权分立的形态，并不是指政府组织结构的形式，而是指矿工、开发者、投资者三者组成了相互制衡的数字货币的治理形态。&lt;/p&gt;
&lt;p&gt;比特币并没有真正意义上完全地去中心化，在记账权上，它目前被 5 大矿池所把持。当人们抨击 EOS 的 21 个节点有中心化的嫌疑时，BM 总是拿出比特币矿池的例子来反击。&lt;/p&gt;
&lt;p&gt;实际上这里偷换了概念，比特币中矿工的权力其实是有限的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;技术限制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于 PoW 的特性，矿工无法进行长程攻击（Long Range Attack），篡改和分叉的边际成本随着篡改的区块数量线性攀升&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;开发者制衡&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;扩容之争是很好的例子，我们下一篇会详细介绍，矿工是逐利的，而开发者决定了比特币的长期发展，所以从某种意义上来说，作弊不如和开发者合作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;投资者制衡&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;矿工是比特币的直接利益相关者，无论是社区分歧还是主链分叉，矿工首先确保的是收益稳定，黑天鹅事件造成的巨大价格波动是不利于收益预期的。&lt;/p&gt;
&lt;h3 id=&#34;512-bip-及其发展&#34;&gt;5.1.2 BIP 及其发展
&lt;/h3&gt;&lt;p&gt;比特币 BIP（Bitcoin Imrpovement Proposals) 是一种设计文档，用来描述比特币新特性的提案，第一个比特币 BIP 是 2011 年 8 月 19 号一个名为 Amir Taaki 的人提交的，编号 bip001，它描述了 BIP 本身是什么。&lt;/p&gt;
&lt;p&gt;随后几年直到现在，比特币的 BIP 编号将近 200 个，它展示了比特币强大的社区协作能力。&lt;/p&gt;
&lt;p&gt;很多人认为某个区块链项目一旦上线这个链就稳了，实际上，做公链好比一场没有尽头的马拉松长跑，主网上线表示长跑开始，接下来才是真正拼实力的时候。&lt;/p&gt;
&lt;p&gt;具体怎么拼？则要看 IP（Improvement Proposal）。可以说 IP 代表了一个区块链项目的生命力。例如 HD 账户是 bip32 和 bip39 提出的，最开始的比特币是没有这个功能的，隔离见证也是由一系列 bip 组成的。&lt;/p&gt;
&lt;h2 id=&#34;52-比特币专题二扩容之争ifo与链上治理&#34;&gt;5.2 比特币专题（二）：扩容之争、IFO与链上治理
&lt;/h2&gt;&lt;h3 id=&#34;521-扩容之争&#34;&gt;5.2.1 扩容之争
&lt;/h3&gt;&lt;p&gt;扩容之争是比特币历史上影响较大的事件，它也是比特币社区治理的经典案例。扩容之争的背后其实是社区治理的难题：如何让社区达成一致。&lt;/p&gt;
&lt;p&gt;扩容的需求是由于比特币的使用人数逐渐增长，于是比特币的网络也日益拥堵。关于如何解决这种网络拥堵的问题，比特币社区出现了两种不同的解决方案。&lt;/p&gt;
&lt;p&gt;方案一：极端扩容，直接将区块的上限进行扩容，它的优点是可以快速解决问题，缺点是十分直接，只能舒缓一时的拥堵，并没有从根本上解决问题，更不能带来新的特性。
方案二：隔离见证，要求坚守 1MB 的容量上限，通过隔离见证的方法绕过 1MB 的限制。这种方式改动比特币交易的结构，它的优点是结构的改变可以带来崭新的特性，缺点也不少，不但花费的时间较长，用户的使用感知也并不算完美。&lt;/p&gt;
&lt;p&gt;社区就上述的两种方案，产生了不同的分歧，分为以下几派：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;极端扩容派&lt;/li&gt;
&lt;li&gt;隔离见证派&lt;/li&gt;
&lt;li&gt;调停和解派系&amp;mdash;-打太极&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;522-扩容之争引起的-ifo&#34;&gt;5.2.2 扩容之争引起的 IFO
&lt;/h3&gt;&lt;p&gt;扩容之争基本在 2017 年 11 月结束，比特币硬分叉出比特币现金已经成了定局。比特币现金的出现还带来了一件新事物，就是 IFO——Initial Fork Offering，也就是分叉比特币形成新的数字代币，这其实就是 ICO 的替代品。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;这里要提一句，2017 年 9 月 4 号七部委发文明令禁止 ICO，所有和人民币挂钩的交易所都必须限期关闭。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;ICO 的中文名是首次代币发行，又称为区块链众筹，这是一种新型的融资模式，投资者可以用手中的比特币或其他代币投到其他的区块链创始项目。&lt;/p&gt;
&lt;p&gt;ICO 从本质上来说就是一纸白皮书，接下来全靠吹，忽悠散户投币，“我要出一个新的代币了，你们快来买吧。”&lt;/p&gt;
&lt;p&gt;而 IFO 的集资依靠的是与比特币的关联，“我要出一个代币了，这个代币是由比特币分叉出来的哦，你们快来买吧！”靠着与比特币的连带性，IFO 打了一记集资的擦边球。&lt;/p&gt;
&lt;p&gt;所以国内诸多项目方和经验资深的投资方一拍即合，搞 IFO 吧。但是 IFO 比 ICO 限定在只能从比特币上分叉，所以技术的发挥仍然有限。&lt;/p&gt;
&lt;h3 id=&#34;523-链上治理&#34;&gt;5.2.3 链上治理
&lt;/h3&gt;&lt;p&gt;链上治理指的是人们直接在区块链发起社区提案，并进行决策的过程。&lt;/p&gt;
&lt;p&gt;这里首先要求的是链上支持基本治理协议，这套协议可以规定或强制执行提案，链上治理直接决定了区块链本身的发展方向。链上治理的参与方包括了投资者、使用者、开发者、矿工四类人群。&lt;/p&gt;
&lt;p&gt;链上治理与链下治理的区别在于，区块链本身是否提供强制执行的机制让少数服从多数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;各种类型的链上治理&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;比特币 BIP 和区块投票&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;以太坊 Gas limit 投票&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;比特股 BTS 和柚子 EOS 的链上治理&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;链上治理的几个问题&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;升级的实际执行者矿工总是理性的，也就是追求自身利益最大化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;惰性投票，只有很少一部分人会真正地去投票。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;投票权过度集中，大户持有者往往话语权更重。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;链下治理相比链上治理，更接近我们现实社会的方式。链上治理不是一个设计问题，它是社区制度问题，“如何让区块链更好地发展”相比“区块链项目应当设定什么样的发展目标”，是排在第二位的。&lt;/p&gt;
&lt;p&gt;社区在自身追求目标的过程中，会自发地找到最佳治理结构，人为设计可能会有诸多漏洞和缺陷，也限制了可开发性。&lt;/p&gt;
&lt;p&gt;例如链上治理至少存在以下几个问题。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;公地悲剧&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当所有人都觉得别人会投票的时候，也就没有人投票了，这个典型案例是英国脱欧公投。&lt;/p&gt;
&lt;p&gt;2.女巫攻击&lt;/p&gt;
&lt;p&gt;目前区块链很难映射现实中人的身份，如果按照身份去投，大户是可以扮演多个伪造身份进行投票的，在产生区块链数字身份之前，链上治理只能依托于币的数量进行权重投票。这便造成一个代币一票，持币多的选民有更大的话语权。&lt;/p&gt;
&lt;p&gt;3.贿选&lt;/p&gt;
&lt;p&gt;这其实是女巫攻击的延伸，链上治理节点可以承诺将获得的收益与其他节点进行分享，这种拉票方式其实就是贿选，如果恶意节点可以通过贿赂成为记账节点，进而左右区块链的升级过程，后果非常可怕。&lt;/p&gt;
&lt;h2 id=&#34;53-数字货币和数字资产&#34;&gt;5.3 数字货币和数字资产
&lt;/h2&gt;&lt;h3 id=&#34;531-区块链应用范围统计&#34;&gt;5.3.1 区块链应用范围统计
&lt;/h3&gt;&lt;p&gt;据统计，截止 2018 年 3 月，全球数字货币共计 1500 多种，总市值超 3200 亿美元。然而市值分布占比不够分散，单比特币就占了一半市值，剩下以太坊、瑞波币、比特币现金等数字货币占了另外一半。&lt;/p&gt;
&lt;p&gt;大致来分，目前区块链首先在金融领域发力，其次在信息通讯、底层基础设施、教育、能源、医疗等行业应用地比较广泛。&lt;/p&gt;
&lt;p&gt;从占比来看，金融和信息通讯类占比最高，占所有区块链项目类型接近七成。&lt;/p&gt;
&lt;h3 id=&#34;532-从数字货币到数字资产&#34;&gt;5.3.2 从数字货币到数字资产
&lt;/h3&gt;&lt;p&gt;数字货币是数字资产的清算底层，数字资产的经济活动依赖数字货币。&lt;/p&gt;
&lt;p&gt;数字货币一般只能是公链项目，数字资产依靠公链生态提供，这种支撑型结构决定了数字货币的种类不会很多，而数字资产会非常多。&lt;/p&gt;
&lt;p&gt;比特币本身是最成功的数字货币项目，同时也是最成功的区块链项目。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;比特币的应用生态主要集中在全球无国界支付结算上，由于比特币本身是一种原生资产，它没有与任何其他资产锚定，所以比特币的应用生态取决于人们的共识，这点比特币已经做到了。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;只要比特币的社区不发生大的动乱，那么比特币的地位是很难超越的，尽管有诸多崭新的区块链技术冒出来，如提升共识效率、提升网络容量等等。&lt;/p&gt;
&lt;p&gt;但是比特币的共识经过了近十年的历史开创，形成成熟稳定的生态结构，这一点在技术上是无法取代的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数字货币&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;原生数字货币&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;原生型数字货币特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非营利性社区自治；&lt;/li&gt;
&lt;li&gt;依赖社会共识承认；&lt;/li&gt;
&lt;li&gt;超级结算工具；&lt;/li&gt;
&lt;li&gt;可用于支持数字资产。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;锚定型数字货币&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;锚定型数字货币特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;商业性自治；&lt;/li&gt;
&lt;li&gt;依赖广泛的承兑商；&lt;/li&gt;
&lt;li&gt;稳定的支付结算工具；&lt;/li&gt;
&lt;li&gt;可用于支持数字资产。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;535-数字资产的宏观分类&#34;&gt;5.3.5 数字资产的宏观分类
&lt;/h3&gt;&lt;p&gt;数字资产所产生的金融我们称为数字金融，国内又称为通证和通证经济。&lt;/p&gt;
&lt;p&gt;Token 是数字资产最直接的表现形式，Token 的生态结构具有自发和原生性，大致可以分成这几种类型。一种是基础设施型生态，一种是金融型生态，还有一种是商业垂直应用生态，这三种生态都非常有潜力。&lt;/p&gt;
&lt;h4 id=&#34;5351-基础设施型-token&#34;&gt;5.3.5.1 基础设施型 Token
&lt;/h4&gt;&lt;p&gt;基础设施一般就是指公链的权益代币，很多公链都在做这个领域的研究，当然这也是最迫切需要被突破的，有了成熟的基础设施，区块链应用才得以广泛普及。&lt;/p&gt;
&lt;p&gt;这类的 Token 的典型是以太坊上的以太币 Ether，除了以太坊，还有 EOS、NEO 等，可以说能够支持发行 Token 的公链都具有较高的潜在价值，它们目前处于军阀混战时期，后期是垂直细分还是一统江山很难判断。&lt;/p&gt;
&lt;p&gt;另外基础设施型 Token 本身也具备数字货币的功能。&lt;/p&gt;
&lt;h4 id=&#34;5352-金融型-token&#34;&gt;5.3.5.2 金融型 Token
&lt;/h4&gt;&lt;p&gt;这类 Token 的典型是 Tether、bitCNY 等锚定型数字货币，以及交易平台的 Token，例如火币的 HT、OKEX 的 OKB 和币安的 BNB。&lt;/p&gt;
&lt;p&gt;这类 Token 的典型特点是在为原生数字资产创造流动性，它是数字金融发展的必然结果。&lt;/p&gt;
&lt;p&gt;金融型 Token 有点接近证券，只能在流动性高的地方产生，例如数字资产交易所、承兑平台。&lt;/p&gt;
&lt;h4 id=&#34;5353商业垂直生态型-token&#34;&gt;5.3.5.3商业垂直生态型 Token
&lt;/h4&gt;&lt;p&gt;这一类 Token 具有非常大的商业潜力，释放的能量也是最大的，这里当然不是指单个 Token，而是某个商业生态形成的一类 Token。&lt;/p&gt;
&lt;p&gt;例如游戏直播平台可以打通形成一类 Token，文化产权也可以打通形成一类 Token。这类 Token 是非常好的连接器，连接局部商业，在行业内部形成流动市场。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最后我们总结一下，以上三类 Token 依赖关系是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;商业垂直生态型 Token 依赖基础设施型 Token；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;金融型 Token 依赖基础设施型 Token；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;商业垂直生态型 Token 可能依赖金融型 Token。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Token 的流动性大小依次是：&lt;/p&gt;
&lt;p&gt;基础设施型 Token &amp;gt; 金融型 Token &amp;gt; 商业垂直生态型 Token&lt;/p&gt;
&lt;p&gt;Token 的种类数量分布依次是：&lt;/p&gt;
&lt;p&gt;商业垂直生态型 Token &amp;gt; 金融型 Token &amp;gt; 基础设施型 Token&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;536-数字资产的属性分类&#34;&gt;5.3.6 数字资产的属性分类
&lt;/h3&gt;&lt;h4 id=&#34;5361-普通-token&#34;&gt;5.3.6.1 普通 Token
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;积分型。这种 Token 可能比较常见，因为我们经常遇到，例如超市积分，产品积分等等，这种在产品运营上可能换了一种形式，相比较原来的积分体系，流动性可能有所提升。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;会员型。大多数会员制的营销方式，相当于是使用权预售，例如苹果手机预售发行，不必局限在某个渠道商，可以以发行 Token 的方式进行预售。这种类型的 Token 也可以映射到当下现实场景中去。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分红型。这种类型的 Token 典型是币安的 BNB，利润回购是分红型 Token 常见的手段，但由于操作不够透明，很可能会遇到问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;5362-价值型-token&#34;&gt;5.3.6.2 价值型 Token
&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;特点&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;使用权，表示 Token 可交付产品或服务；&lt;/li&gt;
&lt;li&gt;可交易，流动性是数字资产的基本需求；&lt;/li&gt;
&lt;li&gt;可升值，这是由第二条带来的附加属性，也就是升值。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;54-弄懂数字货币交易平台一&#34;&gt;5.4 弄懂数字货币交易平台（一）
&lt;/h2&gt;&lt;h3 id=&#34;541-交易的两种模式&#34;&gt;5.4.1 交易的两种模式
&lt;/h3&gt;&lt;p&gt;先来说说交易模式，交易模式分为两种：场内交易和场外交易。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;场内交易，又称成交单优先模式，指的是有交易场所将买卖双方聚集在一起，进行竞价交易的交易方式。这种交易方式中，交易场所负责用户的资产托管、交易撮合、资产结算、履约担保等功能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;场外交易，又称报价单优先模式，指的是买卖方不通过第三方而直接成为交易对手的交易方式。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;542-传统交易所的运作流程&#34;&gt;5.4.2 传统交易所的运作流程
&lt;/h3&gt;&lt;p&gt;区块链领域的交易所与传统金融的结构十分相似，但也存在了一些区别，为了讲清楚这种区别，我先简述一下证券交易的结构。&lt;/p&gt;
&lt;p&gt;传统一般有四种角色，分别是投资者，在国内大部分是散户，其次是证券公司，接着是交易场所，这里的交易场所仅指场内交易场所，最后是证监会。它们的关系如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0--5%E6%95%B0%E5%AD%97%E8%B4%A7%E5%B8%81%E4%B8%8E%E6%95%B0%E5%AD%97%E8%B5%84%E4%BA%A7/BlockChain_5-1.png&#34;
	width=&#34;1422&#34;
	height=&#34;794&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0--5%E6%95%B0%E5%AD%97%E8%B4%A7%E5%B8%81%E4%B8%8E%E6%95%B0%E5%AD%97%E8%B5%84%E4%BA%A7/BlockChain_5-1_hu_f8e4ef672ea70f17.png 480w, https://zhenyu0324.github.io/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0--5%E6%95%B0%E5%AD%97%E8%B4%A7%E5%B8%81%E4%B8%8E%E6%95%B0%E5%AD%97%E8%B5%84%E4%BA%A7/BlockChain_5-1_hu_109cf645aa51268.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;179&#34;
		data-flex-basis=&#34;429px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;通常投资者在证券公司开户，然后投资者委托证券公司下单，证券公司接受投资者下单并收取一定的佣金，然后买卖单由证券公司在交易场所进行交易，这个过程叫做委托，投资者是委托者，证券公司是受托者。&lt;/p&gt;
&lt;p&gt;换句话说，普通投资者是无法直接接触交易所的，这是因为交易所采取会员制，只有成为交易所的会员且有交易席位，才可以接收其他投资者的委托，所以这就限定了机构投资者，也就是证券公司了。&lt;/p&gt;
&lt;p&gt;而这里交易所是非盈利性的事业法人，它接受国家证券主管机关证券委员会及证监会的领导、管理和监督。证券交易所本身并不参与证券交易，不能决定证券价格。&lt;/p&gt;
&lt;p&gt;所以对于投资者来说，只和证券公司有直接联系，这里的流程可以简述为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;投资者到证券公司开户，然后下单给证券公司；
2 证券公司再将这些订单传递到交易所，订单在交易所完成撮合成交；&lt;/li&gt;
&lt;li&gt;接着交易所将订单和成交数据传到证券登记结算公司，结算公司据此进行资金和证券账户的结算；&lt;/li&gt;
&lt;li&gt;结算结果再回传给证券公司，证券公司通过自己的平台显示给投资者，例如成交信息，账户余额等等。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;543-数字资产交易平台&#34;&gt;5.4.3 数字资产交易平台
&lt;/h3&gt;&lt;p&gt;数字货币交易平台也叫做数字资产交易平台，主要为人们提供交易数字货币或数字资产撮合交易服务。&lt;/p&gt;
&lt;p&gt;这种交易市场是一种典型的买单、卖单交易市场，所以这些平台以场内交易为主，通过提供买单卖单的撮合服务然后赚取手续费，这个过程中也发展出了层次丰富的金融工具，例如杠杆交易。&lt;/p&gt;
&lt;p&gt;人们提供了买、卖交易数字资产的过程，这个过程是一种数字货币交换到另外一种数字货币的过程。&lt;/p&gt;
&lt;p&gt;这种交易市场通常是数字货币对数字货币的，当然这显然不够，所以这就催生了法币对数字货币的交易，这也是中心化交易平台的由来，目前流行的法币与数字货币的交易有美元、欧元、日元、澳元等。&lt;/p&gt;
&lt;p&gt;传统交易所依赖券商，属于金字塔型结构，用户聚集在券商处，资金托管在银行，证券登记结算在第三方机构，本质上交易场所只提供了撮合、监管辅助、信息辅助等功能。&lt;/p&gt;
&lt;p&gt;而由于数字货币的去中心化特性，数字货币交易平台属于扁平型结构，资产管理本身就内置在交易所内部。&lt;/p&gt;
&lt;p&gt;所以任何一个交易平台都不需要第三方机构登记结算数字货币，这带来了业务架构上的易部署特性，用户流量和资金流量最终全部汇聚在数字货币交易所。&lt;/p&gt;
&lt;p&gt;虽然利润和流量都超大，但中心化交易平台也面临了一些天花板，例如动不动就被爆出被黑事件，这也着实让用户提心吊胆，所以我归纳了一些如下缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;内幕操作，交易所相当于是一个黑盒，内部操作不透明带来了巨大风险；&lt;/li&gt;
&lt;li&gt;监管缺失，信息披露不完善，项目方跑路风险；&lt;/li&gt;
&lt;li&gt;持仓风险，用户的资金完全托管在交易所；&lt;/li&gt;
&lt;li&gt;趋利优先，区块链本身的发展是在盈利之后才会被考虑的；&lt;/li&gt;
&lt;li&gt;交易所破产倒闭风险。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;544-数字货币交易平台的三种类型&#34;&gt;5.4.4 数字货币交易平台的三种类型
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;模式一：中心化模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;资金管理系统与区块链账本各自记账，包含充币提币的过程，需要人工干涉。模式一的代表有很多，现在市场上主流的交易所主要的有 Binance、Bittrex、Bitfinex、Gate.io、Huobi.pro、Okex、Kraken 等，它们为数字货币和数字资产的发展提供了全球化、7*24 小时不间断的流动性，也就是上文我们介绍的数字货币交易平台。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模式二：半中心化模式&lt;/strong&gt;
半中心化模式，交易撮合与行情模块是中心化的，而资产是在区块链上直接结算的。代表有 0x Project、Keyber Network 这些前沿的项目。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;模式三：完全去中心化模式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;完全去中心化模式 ，比模式二更进一步，所有模块都是去中心化的，包括交易撮合和行情部分。代表有比特股和 EtherDelta。&lt;/p&gt;
&lt;p&gt;比模式二更进一步，所有模块都是去中心化的，包括交易撮合和行情部分。代表有比特股和 EtherDelta。&lt;/p&gt;
&lt;p&gt;模式二和模式三我们统称为去中心化交易所，目前是区块链数字资产领域研究的一个前沿方向，多数方案都还不成熟，例如用户产品体验差、稳定性不足、数字货币流动性不足等等，当然更多还处于研发阶段。&lt;/p&gt;
&lt;h2 id=&#34;55-弄懂数字货币交易平台二&#34;&gt;5.5 弄懂数字货币交易平台（二）
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;中心化模式下的数字货币交易平台&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;551-两套账本&#34;&gt;5.5.1 两套账本
&lt;/h3&gt;&lt;p&gt;数字货币交易平台的技术基本沿用了金融交易技术中的系统架构，只是把原来针对法币和证券（或平台代币）的部分，也就是我们通常称作资金管理系统的部分，完全替换为针对数字货币的数字货币管理系统，换句话说，就是换了一套内部账本。&lt;/p&gt;
&lt;p&gt;然而我们知道，区块链本身也是用来记账的，也算作一种金融账本，所以一套内部账本，一套区块链本身的账本，这里就出现了两套账本，如何管理这两套账本，就是资金管理系统的首要任务。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0--5%E6%95%B0%E5%AD%97%E8%B4%A7%E5%B8%81%E4%B8%8E%E6%95%B0%E5%AD%97%E8%B5%84%E4%BA%A7/BlockChain_5-2.png&#34;
	width=&#34;1430&#34;
	height=&#34;528&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0--5%E6%95%B0%E5%AD%97%E8%B4%A7%E5%B8%81%E4%B8%8E%E6%95%B0%E5%AD%97%E8%B5%84%E4%BA%A7/BlockChain_5-2_hu_1252b68adf427e18.png 480w, https://zhenyu0324.github.io/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0--5%E6%95%B0%E5%AD%97%E8%B4%A7%E5%B8%81%E4%B8%8E%E6%95%B0%E5%AD%97%E8%B5%84%E4%BA%A7/BlockChain_5-2_hu_c54775019928e372.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;270&#34;
		data-flex-basis=&#34;650px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;解释一下这张图，图的左边表示了多个区块链账本，右边的数字货币交易所有自己的内部账本，这两套账本是独立的。&lt;/p&gt;
&lt;p&gt;交易所内部的账本记录的是交易 Trade，这个交易是由用户挂单，接着被撮合引擎撮合成交而产生的，而区块链账本上的交易 Transaction，是当且仅当用户发起充币提币请求并被执行时，才会产生的。&lt;/p&gt;
&lt;p&gt;这两种交易都用了中文“交易”来表示，但是它们所属的语境不同，前者的交易表示的是金融交易语境下的资产交换，也就是 Deal；后者表示的是区块链上的技术概念，表示资产转移的一次记账过程，上述特意用英文以表区别，希望你能够区分。&lt;/p&gt;
&lt;h3 id=&#34;552-数字货币交易所包含哪些系统模块&#34;&gt;5.5.2 数字货币交易所包含哪些系统模块
&lt;/h3&gt;&lt;p&gt;一个数字货币交易所的后端其实至少有四部分构成：Web 业务逻辑系统、交易撮合系统、运营后台管理系统、资金管理系统。资金管理系统其实就是刚才说到的内部账本。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0--5%E6%95%B0%E5%AD%97%E8%B4%A7%E5%B8%81%E4%B8%8E%E6%95%B0%E5%AD%97%E8%B5%84%E4%BA%A7/BlockChain_5-3.png&#34;
	width=&#34;1426&#34;
	height=&#34;528&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0--5%E6%95%B0%E5%AD%97%E8%B4%A7%E5%B8%81%E4%B8%8E%E6%95%B0%E5%AD%97%E8%B5%84%E4%BA%A7/BlockChain_5-3_hu_ea2e2411b2928b87.png 480w, https://zhenyu0324.github.io/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0--5%E6%95%B0%E5%AD%97%E8%B4%A7%E5%B8%81%E4%B8%8E%E6%95%B0%E5%AD%97%E8%B5%84%E4%BA%A7/BlockChain_5-3_hu_d0016539d9caee33.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;270&#34;
		data-flex-basis=&#34;648px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;Web 业务逻辑系统：这个模块通常包含了用户账户模块、登录网关、账户安全管理、KYC 认证、行情推送等等，这个模块更偏向用户，也与通常的电商账户系统十分类似。
交易撮合系统：这个模块是一个交易所的核心模块，为所有的用户提供订单撮合。
运营后台管理：这个模块是一个交易所运营人员使用的系统，交易所内部人员才能访问。
资金管理系统：这里的资金管理其实包含了三部分，第一部分是法币的支付网关，可能需要对接银行或第三方支付机构；第二部分就是数字货币钱包管理，它提供了大部分主流数字货币的支付功能；第三部分是用户持仓信息，所谓持仓就是用户持有多少数字货币，这个是记录在数据库中的，不需要与区块链保持一致，但是要求交易所的总账是平的。&lt;/p&gt;
&lt;h3 id=&#34;553-各自模块的特征&#34;&gt;5.5.3 各自模块的特征
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Web 业务系统与我们常见的电商系统无异，主要是用户账户以及简单的业务逻辑，重点是可扩展性，业务要求比较弹性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;交易撮合系统本质上是一个高并发的计算系统，特点是系统性能高和稳定性好，其中订单队列可以是编程语言中的数据容器，也可以是内存数据库。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运营后台系统在整个交易所生命周期的早期并不凸显重要性，但是运营后台系统恰恰是交易所中后期发展的核心系统，重点在数据准确，要求网络安全性高和可扩展性好。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;资金管理系统包含用户持仓状态，以及数字货币钱包服务，它是一个交易平台中安全性要求最高的系统，资金管理系统往往要搭配一个内存数据库，其中数字货币钱包服务也可以拆出来做成独立子系统，甚至可以改造成整个公司的内部区块浏览器，因为钱包服务需要设计成多个钱包实例，并统一所有的币种钱包接口。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>区块链学习--4技术下</title>
        <link>https://zhenyu0324.github.io/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0--4%E6%8A%80%E6%9C%AF%E4%B8%8B/</link>
        <pubDate>Sun, 07 Feb 2021 16:05:48 +0800</pubDate>
        
        <guid>https://zhenyu0324.github.io/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0--4%E6%8A%80%E6%9C%AF%E4%B8%8B/</guid>
        <description>&lt;h2 id=&#34;211-比特股bts&#34;&gt;2.11 比特股BTS
&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;没有开放式智能合约的区块链项目——比特股&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比特股发布于 2014 年，虽然没有引入智能合约的概念，但它提供了功能极为丰富的金融类工具，比特股上所有的金融合约都是事先在代码里写好的，所以说它的本身就是一个超级智能合约集合。&lt;/p&gt;
&lt;h3 id=&#34;2111-什么是比特股&#34;&gt;2.11.1 什么是比特股
&lt;/h3&gt;&lt;p&gt;比特股是一个公开透明的、7*24 小时不间断运行的、基于区块链技术的去中心化交易平台。&lt;/p&gt;
&lt;p&gt;它兼具了区块链的优点，也是第一个有关稳定数字货币的尝试，目前比特股提供了若干核心的金融服务，例如支付、撮合交易、资产存托等服务。&lt;/p&gt;
&lt;p&gt;相较于传统的金融 IT 系统，它的服务器是由分散在世界各地的受托人（Delegated）维护的，即使其中一些人被攻击也不会导致整个系统的宕机。&lt;/p&gt;
&lt;p&gt;比特股目前全网在线的服务器有 27 个，由于 DPoS 共识算法提供了较好的交易吞吐性能，理论上比特股的 TPS 可达 10 万，这也是比特股在技术上区别于其他区块链的最显著特征。比特股较好的 TPS 其实也是为了它的功能服务的。&lt;/p&gt;
&lt;h3 id=&#34;2112-比特股的两个机制&#34;&gt;2.11.2 比特股的两个机制
&lt;/h3&gt;&lt;p&gt;那么比特股是如何设计中心化交易所来避免上述风险的呢？&lt;/p&gt;
&lt;p&gt;比特股作为一个去中心化的交易所，它有两个机制可以避免上述的风险。&lt;/p&gt;
&lt;p&gt;第一、资金出入是由承兑商来支持的，人人都可以成为承兑商，也就是人人承兑；&lt;/p&gt;
&lt;p&gt;第二、锚定机制提供了稳定货币的出入金过程，锚定机制也保证了比特股的出入资金和交易撮合是分离的，避免了中心化交易平台的弊端。&lt;/p&gt;
&lt;h4 id=&#34;21121-人人承兑&#34;&gt;2.11.2.1 人人承兑
&lt;/h4&gt;&lt;p&gt;人人承兑就是提供了从法币到系统内置货币的转换，比特股系统内置了多种货币，它锚定了多数法币。&lt;/p&gt;
&lt;p&gt;例如 bitCNY、bitUSD、bitEUR 等等，这些系统内置货币是可以与 CNY、USD、EUR 按照 1：1 兑换的。而人人承兑货币其实就是提供了 bitCNY 和真正人民币之间的相互转换。&lt;/p&gt;
&lt;p&gt;它的机制上有点类似那个比特币的场外交易。所谓场外交易，就是没有中心化撮合中介，交易双方自行议价成交。&lt;/p&gt;
&lt;h4 id=&#34;21122-锚定机制&#34;&gt;2.11.2.2 锚定机制
&lt;/h4&gt;&lt;p&gt;锚定机制是一种去中心化的抵押机制。我们刚才提到了比特股系统内置了多种货币，它锚定了多数法币，例如 bitCNY、bitUSD、bitEUR 等等，这些系统内置货币是可以与 CNY、USD、EUR 按照 1：1 兑换的。&lt;/p&gt;
&lt;p&gt;系统内置货币的发行商是系统自身，发行给抵押了 bts 的用户，发行的数量是由抵押的代币数量决定的。你用 bts 抵押，然后换取 bitCNY。&lt;/p&gt;
&lt;p&gt;换句话说，任何持有 bts 的人可以用它来抵押生产系统的内置货币，例如 bitCNY，它的抵押规则要求两倍价值的 bts 进行抵押，由于有 2 倍价值的 bts 作为保障，所以定义 1 bitCNY = 1 元人民币的风险较低。&lt;/p&gt;
&lt;h3 id=&#34;2113-比特股的技术概览&#34;&gt;2.11.3 比特股的技术概览
&lt;/h3&gt;&lt;p&gt;比特股的核心代码是由 Cryptonomex 公司开源的石墨烯（Graphene）框架演变而来，它的主体代码是 C++ 编写的，里面使用了大量的 boost 库组件，如果你对石墨烯技术感兴趣，并且熟悉 C++，可以仔细研究一番。&lt;/p&gt;
&lt;p&gt;除了比特股核心，这里还有一套 Javascript 编写的 UI 产品，叫做 Bitshares-UI，Bitshares-UI 其实是一个轻量级的基于浏览器的钱包：比特股钱包，这个钱包将用户密钥存储在本地浏览器上，并且密钥是通过用户密码加密并储存在浏览器数据库。&lt;/p&gt;
&lt;h2 id=&#34;212-引人瞩目的区块链项目eosiotacardano&#34;&gt;2.12 引人瞩目的区块链项目：EOS、IOTA、Cardano
&lt;/h2&gt;&lt;h3 id=&#34;2121-柚子-eos&#34;&gt;2.12.1 柚子 EOS
&lt;/h3&gt;&lt;p&gt;EOS 全称 EOS.IO 软件，EOS 也是 EOS.IO 上的平台代币缩写，它暂时没有准确的中文翻译，中文社区把 EOS 叫柚子，这一点其实得益于 EOS 的发音与水果“柚子”相近。&lt;/p&gt;
&lt;p&gt;EOS 是一个以太坊的竞争型区块链，它提供了全新的区块链架构，使得去中心化平台水平扩容和垂直扩容都成为了可能。&lt;/p&gt;
&lt;p&gt;如果智能合约是程序，那么可以把 EOS 看成是一个超大的操作系统了，它为所有的程序，也就是智能合约提供了基本设施。例如账户、授权、数据库、异步通信等接口。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;EOS 的瞩目之处&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;EOS 号称可以提供百万级 TPS 交易性能&lt;/li&gt;
&lt;li&gt;EOS 的链上治理机制：区块链宪法以及 21 个超级节点&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 EOS 中，记账节点又被称作超级节点，EOS 一共有 21 个主节点，另外还有 100 个备选超级节点，这些超级节点完全是等价的。&lt;/p&gt;
&lt;p&gt;超级节点的基本职责包括了忠实打包交易、执行并验证智能合约、向全网广播有效区块以外，还多了一项职责：保障并促进 EOS 项目的发展。&lt;/p&gt;
&lt;p&gt;如何促进呢？BM 在 EOS 中强化了 DPoS 算法的投票机制，并首次提出了区块链宪法的概念。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;EOS.IO 应用使得区块链创建了一个点对点的服务条款协议或者绑定用户到一个合约，这都需要用户对其签名，简称“宪法”。&lt;/p&gt;
&lt;p&gt;宪法的内容定义了仅仅依靠代码无法在用户间履行义务，同时通过建立管辖权和可选的法律来解决相互间的争端。&lt;/p&gt;
&lt;p&gt;每个在网络广播的交易都必须将宪法的哈希值作为签名的一部分，从而显性地将签名者绑定在合约中。&lt;/p&gt;
&lt;p&gt;宪法还定义了人类可读意图的源代码协议。 这个意图是用来识别错误和功能之间的差异，当错误发生时，引导社区对什么是适当或不当修复。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;争议之处&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Vitalik 针对 EOS 超级节点竞选发表过意见。他认为 21 个节点的 DPoS 虽然引入了治理结构，但也很容易受到选民和持币大户的操纵，最终导致“财阀统治型”的治理结构。&lt;/p&gt;
&lt;p&gt;在超级节点竞选过程中，某些节点为了获得更多的选票，承诺当选后可以给投票者分红，这在西方文化中是无法接受的，这一点似乎违背了 BM 设计 DPoS 的初衷，所以 BM 以及 EOS 团队都表示坚决反对。&lt;/p&gt;
&lt;p&gt;BM 对此也给了回应，BM 表示自己的目标是降低创建社区的准入门槛，并允许市场自由竞争来奖励最高效的社区以及惩罚最腐败的社区。&lt;/p&gt;
&lt;h3 id=&#34;2122-埃欧塔-iota&#34;&gt;2.12.2 埃欧塔 IOTA
&lt;/h3&gt;&lt;p&gt;IOTA 是一个为了物联网（IoT) 而生的区块链项目。严格来说，IOTA 不是“区块链”，因为它没有区块，也不是链式结构。&lt;/p&gt;
&lt;p&gt;IOTA 提出了一种基于有向无环图（DAG）的分布式账本结构，这种结构 IOTA 将其命名为 The Tangle，探戈。&lt;/p&gt;
&lt;p&gt;任意交易 Tx-black 会引用过去的两条交易记录，这样被引用的交易 Tx-purple 相当于有了一次确认，间接地证明了合法性，随着一次又一次的被引用，Tx-purple 会转变成 Tx-green。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Tx-black 相当于图种的黑色图块，代表未确认的交易；&lt;/li&gt;
&lt;li&gt;Tx-purple 相当于紫色图块，代表已确认但还未成熟的交易；&lt;/li&gt;
&lt;li&gt;Tx-green 相当于是绿色图块，代表已确认已成熟的交易，是可信的。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;也就是说，我们发送交易的目标是成本绿色部分的交易，成为绿色部分的交易，可信度是可以计算的，面对不同的交易场景，可信度可以设置为 51%，90% 或者百分之百。&lt;/p&gt;
&lt;p&gt;IOTA 上的共识算法叫做 MCMC 算法，它可以任意选择黑色部分的两笔交易，进行引用。&lt;/p&gt;
&lt;p&gt;我们回到 DAG 的结构中，我们发现每一个绿色的交易都会有一条从黑色起始位置通往它的路径，那么你这笔交易的可信程度就可以很容易计算。&lt;/p&gt;
&lt;p&gt;例如我们执行 MCMC 算法 N 次，这笔交易被全网接受的概率就是 M/N，其中 M 就是能从底部通往这笔交易的数量。&lt;/p&gt;
&lt;h3 id=&#34;2123-卡尔达诺-cardano&#34;&gt;2.12.3 卡尔达诺 Cardano
&lt;/h3&gt;&lt;p&gt;卡尔达诺（Cardano）也是一个正在开发中的新一代区块链智能合约平台。&lt;/p&gt;
&lt;p&gt;卡尔达诺项目最大的特色是由理论研究主导，严格采用数学形式化验证的来证明严谨、安全性的区块链。&lt;/p&gt;
&lt;p&gt;卡尔达诺认为现阶段基础公链在无论在可规模化性（Scalability）、可互操作性（Interoperability）和可持续发展性（Sustainability）均存在不足，卡尔达诺希望进行概念和技术上的创新，最终解决上述三个方面问题。&lt;/p&gt;
&lt;p&gt;卡尔达诺的团队认为目前区块链面临着两个比较突出的问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;区块链协议的升级将会导致区块链分叉&lt;/li&gt;
&lt;li&gt;区块链的水平扩容和垂直扩容能力不足。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以 Cardano 提出了分层架构理念，这似乎与传统 IT 架构模式：分层式架构模式有点像，卡尔达诺由两个层次组成。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Settlement Layer 清算层：卡尔达诺的代币 ADA 在该层流动，是整个系统的支付和清算的基础。&lt;/li&gt;
&lt;li&gt;Computation Layer 计算层：卡尔达诺将在计算层提供智能合约、身份认证、消息通信等等功能。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;相比于概念创新，卡尔达诺的团队研究了一种被命名为 Ouroboros 的算法，它其实也是 PoS 共识算法的变种，不同的是卡尔达诺团队为此提供了数学形式化证明，证明了它是高效、安全的共识算法。&lt;/p&gt;
&lt;h2 id=&#34;213-国内区块链项目技术一览&#34;&gt;2.13 国内区块链项目技术一览
&lt;/h2&gt;&lt;h3 id=&#34;2131-小蚁-neo&#34;&gt;2.13.1 小蚁 NEO
&lt;/h3&gt;&lt;p&gt;我们以前讲到过，NEO 的前身是小蚁，小蚁最早在 2015 年发起，它在 2017 年中正式更名为 NEO。&lt;/p&gt;
&lt;p&gt;NEO 项目一共经历过两次 ICO，第一次 ICO 是项目创立，第二次 ICO 是项目更名后的品牌升级。可以说通过 NEO 项目的起起落落见证了整个国内区块链项目的发展。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;设计思路&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;NEO 是一个开放式智能经济平台，它提供了数字身份、数字资产、智能合约三种核心元素用来支持 NEO 智能经济生态。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数字资产：数字资产是以电子数据的形式存在的可编程控制的资产，NEO 在底层也直接支持类似 ERC20 的 Token 机制，所以用户可以在 NEO 上自行注册登记资产、交易和流转。它也通过数字身份解决与实体资产的映射关系，用户通过正规的数字身份所注册登记的资产受到法律的保护。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数字身份：数字身份是指以电子数据形式存在的个人、组织、事物的身份信息，NEO 将实现一套兼容 X.509 的数字身份标准以及支持 Web Of Trust 式的点对点的证书签发模式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;智能合约：NEO 上的智能合约与以太坊不同，叫做 NeoContract。这套智能合约体系的最大特点是直接支持 C#、Java 等主流编程语言，所以开发者可以在熟悉的 IDE 环境（Visual Studio、Eclipse 等）中进行智能合约的开发、调试、编译。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;技术特点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;NEO 采用了 PBFT 类的共识算法。NEO 的修改版为 dBFT 共识算法，这里 d 为 Delegated，就是代理人的意思。所有的 PBFT 类算法都有个特性，就是通信复杂度是节点数量的平方次，例如 7 个节点出一次块至少通信 72 次，对网络带宽要求很高。所以记账节点一般不会很多，它带来的优势就是 TPS 较高，并且不会分叉。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;自成一派的智能合约体系。这里降低了智能合约开发者的局限性，不必使用 Solidity 语言开发。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C# 技术生态。NEO 的主要实现都是 C# 语言编写的，得益于.Net Core 的开源，NEO 的技术生态也在一直扩张。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Token 体系。提供了等价于以太坊 ERC20 的 NEP-5 Token 体系。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2132-元界-metaverse&#34;&gt;2.13.2 元界 Metaverse
&lt;/h3&gt;&lt;p&gt;元界是一个关注社会和商业需求的区块链项目，目标是构建以数字资产（Metavase Smart Token）和数字身份 (Avatar) 为基础新型区块链生态，这种生态会为人类社会带来深刻的变革。&lt;/p&gt;
&lt;p&gt;总体思路是总结人与人、人与资产之间的关系，把总结后的通用需求抽象成模型，然后做到区块链底层供使用者方便使用，这种方式我们叫做 BISC（Buit-in Smart Contract）内置智能合约，它可以降低商业应用在开发和使用过程中的技术风险。&lt;/p&gt;
&lt;h3 id=&#34;2133-量子链-qtum&#34;&gt;2.13.3 量子链 QTUM
&lt;/h3&gt;&lt;p&gt;量子链致力于开发比特币和以太坊之外的新型区块链生态，它的目标是通过自行设计，让比特币和以太坊完美地融合在一起，并通过智能合约为人们提供 Dapp 平台。&lt;/p&gt;
&lt;p&gt;除此之外，量子链还提出了移动端 Dapp 策略，通过引入身份机制和 Data-feed 链外数据达到合规性要求，最终通过推动 Dapp 的普及，让传统互联网企业可以将量子链作为一个新的应用平台进行尝试。&lt;/p&gt;
&lt;p&gt;量子链关注利用区块链技术进行价值传输，首次提出了 VTP——Value Transfering Protocal，价值传输协议的概念。这里的价值传输协议是对标 HTTP、SMTP、POP3、SSH 等协议的。&lt;/p&gt;
&lt;p&gt;量子链认为，在比特币之前人们一直无法在不借助第三方的情况下进行较好的点对点价值转移，比特币是运行在互联网上的一个 VTP 协议，随着区块链技术的发展，人与人、人与信息的交互更加多样化，未来会有更多的实体会被数字化（Tokenization）。&lt;/p&gt;
&lt;p&gt;这里所说的就是资产登记，被登记完之后，肯定还会面临价值流转的问题。量子链从技术出发，提供了第一个结合比特币 UTXO 和以太坊 EVM 的区块链技术生态区来解决上述问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;技术特点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;与以太坊智能合约体系高度兼容的技术栈。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;共识算法使用了 PoS3.0 算法，属于经典 PoS 算法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提出了主控智能合约和普通智能合约的概念，通过主控合约可以引入链外数据 Data-feed。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过主控合约可以提供合规性需求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提供了等价于以太坊 ERC20 的 QRC20 Token 体系。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2134-比原链-bytom&#34;&gt;2.13.4 比原链 Bytom
&lt;/h3&gt;&lt;p&gt;比原链是一种多元的资产交互协议。简单来理解也是做数字资产的，不过换了种说法，理念稍不同。比原链认为在区块链上存在两种不同形态资产。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;比特资产：是指区块链上原生的数字货币、数字资产，例如比特币、以太币；&lt;/li&gt;
&lt;li&gt;原子资产：对应到现实世界的资产，例如权证、权益、股息、债券、情报资讯、预测信息等。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;人们可以通过比原链进行对上述两种资产进行登记、交换、对赌、甚至基于合约的更具复杂性的交互操作。目的是连通原子世界与比特世界，促进资产在两个世界间的交互和流转。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;技术特点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;共识算法是 PoW，属于忠实的比特币 PoW 党。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;挖矿算法采用对人工智能 ASIC 芯片友好型算法，在哈希过程中引入矩阵和卷积计算，使得矿机在闲置或被淘汰后，可用于 AI 硬件加速服务，从而产生额外的社会效益。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;兼容比特币 UTXO 模型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;默认提供了基于 HD 的主私钥账户体系。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;加密模块提供了基于国密 SM2、SM3 标准算法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;植入了隔离见证设计。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2134-本体网络-ontology-network&#34;&gt;2.13.4 本体网络 Ontology Network
&lt;/h3&gt;&lt;p&gt;本体网络是原 NEO 项目组成员李俊创立的，不过与 NEO 是完全独立的项目，随着技术大咖季宙栋的加入，市值跃入 TOP20。&lt;/p&gt;
&lt;p&gt;本体网络是一个主打构建分布式信任体系的区块链项目，支持多链、多系统融合的协议网络，不同的链和不同的系统都可以通过本体的信任协议进行协作。&lt;/p&gt;
&lt;p&gt;本体包含独立的分布式账本、P2P 网络协议、模块化的共识协议组，模块化的智能合约机制几个主要模块。&lt;/p&gt;
&lt;p&gt;本体的产品形式是 ONTO，ONTO 是基于本体的综合客户端产品、区块链搜索引擎和区块链体系的入口。&lt;/p&gt;
&lt;p&gt;ONTO 将帮助用户实现包括数字身份管理、数字资产管理、分布式数据交换等综合性功能，ONTO 可以将数字身份与现实身份进行映射关联，用户可以利用这款产品建立自己的数字身份和多维的身份画像，通过密码学算法实现隐私保护。&lt;/p&gt;
&lt;p&gt;本体主要提供了以下三种协议。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;提供分布式身份管理框架 （ONT ID），一个基于 W3C 的 DID 规范构建的去中心化的身份标识协议。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提供分布式数据交易协议 （ONT DATA），用于构建去中心化数据交易应用框架。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提供了信用评分协议（ONT Scores)，支持建立开发不同的声誉评价逻辑，提供评级授权与审计功能。
支撑这些协议的是 ONT 公链，以及 ONT 区块链高性能可定制化框架。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;技术特点&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;基于账户模型，并保留 UTXO 模型。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;共识算法采用 VBFT，它是结合 PoS、VRF(Verifiable Random Function) 和 BFT 的全新共识算法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;模块化的智能合约，提供 WASM 和 NEO VM 两种。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过 FPGA 加速计算密集型的业务模块。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多层跨链的结构设计。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提供链上搜索引擎。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;214-联盟链和它的困境&#34;&gt;2.14 联盟链和它的困境
&lt;/h2&gt;&lt;p&gt;联盟链源自于 Vitalik 对区块链的概念分类，是他第一次提出了联盟链的说法，联盟链的英文是 Consortium Blockchain。&lt;/p&gt;
&lt;p&gt;所谓联盟链，就是这个区块链具有准入许可，不像公链，任何人都可以随时进入，准入许可意味着候选节点进入区块链时需要得到已经在网络中的节点的许可。&lt;/p&gt;
&lt;p&gt;所以联盟链也叫做许可链，也就是 Permisson Chain，这个叫法在国外比较常见。联盟链的节点数通常不多，维护成本相比公链要低。&lt;/p&gt;
&lt;p&gt;有关联盟链与公链的概念区别，它们的区别仅仅是看新加入的节点是否要经过全网中其他节点的许可，这决定了一个区块链是否开放，开放程度决定了项目生态的大小，这也是最直观的区别。&lt;/p&gt;
&lt;p&gt;联盟链的技术框架很多，其中又以超级账本项目下的技术框架最为知名，应用也最为广泛，它基本代表了联盟链，所以，今天我们就重点来介绍一下超级账本项目。&lt;/p&gt;
&lt;h3 id=&#34;2141-超级账本&#34;&gt;2.14.1 超级账本
&lt;/h3&gt;&lt;p&gt;超级账本在 2015 年年底被发起，吸纳了众多重量级公司加入，它们包括大家耳熟能详的 IBM、Intel、Accenture、日立、JP 摩根、Digital Asset Holdings 等公司。&lt;/p&gt;
&lt;p&gt;超级账本的代码和组织结构都结构清晰、层次分明。可以说无论从声势还是实力上来说，它都可以完胜公链。&lt;/p&gt;
&lt;p&gt;主要技术框架&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Hyperledger Fabric&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;没有中文名，暂译【纺布克】，是 IBM 提供的，超级账本第一个项目。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;Hyperledger Sawtooth&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;中文名【锯齿湖】，Intel 提供，是超级账本第二个项目。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;Hyperledger Iroha&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;没有中文名，暂译【伊路哈】，由 Soramitsu 提供。&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;Hyperledger Burrow&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;没有中文名，暂译【掘地者】，由 Monax 提供。 掘地者提供了一个模块化的区块链客户端，提供了权限管理的智能合约虚拟机，它部分建立在以太坊虚拟机（EVM）规范的基础上。&lt;/p&gt;
&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;Hyperledger Indy&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有中文名，暂译【因迪】。 因迪是特别为去中心化的身份而建立的一种分布式账本。&lt;/p&gt;
&lt;h3 id=&#34;2142-联盟链的困境&#34;&gt;2.14.2 联盟链的困境
&lt;/h3&gt;&lt;p&gt;超级账本系列技术框架很好地诠释了分布式账本技术走到极致是什么样子的。&lt;/p&gt;
&lt;p&gt;几乎所有的超级账本项目都是技术主导，技术的强大也让他们忽视了市场的真实需求。&lt;/p&gt;
&lt;p&gt;联盟链是少数节点之间的活动，它往往退化成微观经济中的博弈，所以利用联盟链构建少数节点之间的协作系统不是一个技术问题，而是变成了如何构造一个稳定的微观经济模型使得协作者可以达成帕累托改进，在这里，技术变成了次要的。&lt;/p&gt;
&lt;p&gt;再好的技术工具如果不结合有效的激励和反馈机制，那么联盟链的应用落地过程似乎变得异常艰难，它很可能最后沦落为普通的分布式系统，这个分布式系统仍然是中心化的。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>区块链学习--3技术中</title>
        <link>https://zhenyu0324.github.io/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0--3%E6%8A%80%E6%9C%AF%E4%B8%AD/</link>
        <pubDate>Sun, 07 Feb 2021 16:00:25 +0800</pubDate>
        
        <guid>https://zhenyu0324.github.io/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0--3%E6%8A%80%E6%9C%AF%E4%B8%AD/</guid>
        <description>&lt;h2 id=&#34;27-哈希与加密算法&#34;&gt;2.7 哈希与加密算法
&lt;/h2&gt;&lt;p&gt;核心：&lt;strong&gt;区块链的密码学基础&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;区块链中主要应用了两类密码学算法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;哈希算法&lt;/li&gt;
&lt;li&gt;非对称加密算法&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;271-哈希算法&#34;&gt;2.7.1 哈希算法
&lt;/h3&gt;&lt;p&gt;哈希算法是一类数学函数算法，又称散列算法，它是一种数据映射关系。&lt;/p&gt;
&lt;p&gt;为了方便举例，我们假设 h = HASH( X | z )，你输入一个任意长的数据 z，经过哈希运算后，返回给你固定长度的数据 h，z 叫做原像，h 是哈希结果，又称作“数据指纹”，z 可选的数据集合构成了 X&lt;/p&gt;
&lt;p&gt;哈希算法具有下面的 4 种特性。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;原像不可逆。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;原像不可逆是指对于任意给定的 h，都无法依据 h 自身的信息推导出 z。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;难题友好性。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;难题友好性通俗的理解就是如果要得到难题答案，你只能暴力枚举，没有比这更好的方法。在 h = HASH( X | z ) 中，从 h 无法推导出 z，只能不断地计算尝试，那么 z 所在的数值集合构成了 X，X 的大小是哈希算法的安全因子之一。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;发散性。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;发散性是指对于任意的 z，即使我们只改动非常少的信息量，例如改动 1 个比特位生成 z&amp;rsquo;，那么 HASH(z) 与 HASH(z&amp;rsquo;) 就是两个大相径庭的结果，完全不相似。&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;抗碰撞性。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;抗碰撞性是指对于任意两个不相同的 z，那么他们对应的 h 值也不同。如果对于任意的 y 不等于 z，则 HASH(y) 不等于 HASH(z)；满足上述定义哈希特性的算法，我们也称作具有严格抗碰撞性。如果我们任意给定一个 z，你都无法找到另外一个 z&amp;rsquo;，使得其值也等于 h，满足这样的哈希特性的算法就有弱抗碰撞性。&lt;/p&gt;
&lt;p&gt;目前流行的 Hash 算法包括了 MD5、SHA-1 和 SHA-2，其中 MD5 被证明不具有强抗碰撞性。SHA （Secure Hash Algorithm）是一个 Hash 函数族，分为 SHA-1、SHA-2、SHA-3，代表了三代哈希标准，目前使用比较多的是 SHA-2 系列。&lt;/p&gt;
&lt;h4 id=&#34;2711-区块链上的哈希算法&#34;&gt;2.7.1.1 区块链上的哈希算法
&lt;/h4&gt;&lt;p&gt;哈希算法被广泛地使用在构造和验证区块、交易的完整性上。
&lt;img src=&#34;https://zhenyu0324.github.io/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0--3%E6%8A%80%E6%9C%AF%E4%B8%AD/blockChain_3-1.png&#34;
	width=&#34;1252&#34;
	height=&#34;684&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0--3%E6%8A%80%E6%9C%AF%E4%B8%AD/blockChain_3-1_hu_6bc461f6eaaeeeb0.png 480w, https://zhenyu0324.github.io/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0--3%E6%8A%80%E6%9C%AF%E4%B8%AD/blockChain_3-1_hu_9805f2cac5d4a498.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;183&#34;
		data-flex-basis=&#34;439px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;在图中可以看出，当前区块里面包含上一个区块的哈希，形成一个哈希指针链表，由于哈希的发散性，所以这个链表也有极大的发散性。&lt;/p&gt;
&lt;h4 id=&#34;2712-默克尔树merkle-tree&#34;&gt;2.7.1.2 默克尔树（Merkle tree）
&lt;/h4&gt;&lt;p&gt;哈希算法的一个重要应用是默克尔树（Merkle tree），默克尔树是一种数据结构，通常是一个二叉树，也有可能是多叉树，它以特定的方式逐层向上计算，直到顶部，最顶层叫做默克尔根，默克尔树最为常见和最简单的是二叉默克尔树。&lt;/p&gt;
&lt;p&gt;默克尔树的基本结构如下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0--3%E6%8A%80%E6%9C%AF%E4%B8%AD/blockChain_3-2.png&#34;
	width=&#34;1055&#34;
	height=&#34;633&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0--3%E6%8A%80%E6%9C%AF%E4%B8%AD/blockChain_3-2_hu_9688645acfeedbc7.png 480w, https://zhenyu0324.github.io/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0--3%E6%8A%80%E6%9C%AF%E4%B8%AD/blockChain_3-2_hu_2a4cec8c7b7d8ff7.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;166&#34;
		data-flex-basis=&#34;400px&#34;
	
&gt;&lt;/p&gt;
&lt;h3 id=&#34;272-非对称加密算法&#34;&gt;2.7.2 非对称加密算法
&lt;/h3&gt;&lt;p&gt;非对称加密算法是相对于对称算法而言的，这两者组成了密码学的核心内容。&lt;/p&gt;
&lt;p&gt;这两者的使用区别体现在密钥是否可以公开，对称密钥要求加解密过程均使用相同的密钥，而非对称加密可以提供一对钥匙，私钥自己保管，公钥可以公开。&lt;/p&gt;
&lt;p&gt;常见的对称加密算法有 DES、3DES、AES、IDEA， 常见的非对称加密算法有 RSA、ECC 等。&lt;/p&gt;
&lt;p&gt;在非对称算法中，私钥一般是通过一个随机数产生的，这个随机数我们也叫做种子，从这个角度来说，知道了这个随机数也就等于知道了私钥，不过私钥的产生范围非常大，在比特币中是 2 的 256 次方，差不多在 10 的 70 方数量级上。&lt;/p&gt;
&lt;p&gt;如果你产生随机数的算法足够均匀分布，私钥碰撞的可能性比中了 1 亿大奖同时被雷劈中的概率还要小数亿倍。所以区块链对产生随机数的算法要求比较高，它要求真实的均匀随机分布，而不是计算机伪随机数。&lt;/p&gt;
&lt;h2 id=&#34;28-utxo与普通账户模型&#34;&gt;2.8 UTXO与普通账户模型
&lt;/h2&gt;&lt;p&gt;区块链网络中有两种记账模式，除了 UTXO 模型还有 Account Based 结构，也就是普通账户模型，也叫账户余额模型，前者在比特币系的数字货币中被广泛使用，后者更多是用在智能合约型的区块链上。&lt;/p&gt;
&lt;h3 id=&#34;281-普通账户模型&#34;&gt;2.8.1 普通账户模型
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;举例解释定义&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我们先从传统的账户模型出发来聊聊是如何记账的，假设我们现在有一个支付系统，在这个支付系统中有村长和张三两个账户，村长账户里有 100 万，现在要转账给张三 10 万，这其中涉及的操作是这样的：&lt;/p&gt;
&lt;p&gt;检查村长的账户余额是否大于 10 万；
把村长的账户扣除 10 万变成 90 万，然后发送一笔转账消息给张三的账户；
张三的账户接受到转账消息，将张三的账户余额加 10 万。
我们可以发现，无论是村长还是张三，都具有一个余额作为状态，即当前余额是记录在某个地方的，只需要读出来即可，这种设计我们叫做账户余额模型。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;如果以上三个步骤是在一个中心化系统中，甚至在同一个数据库中，那将非常简单，会直接退化成一个事务，我们见到的银行账户、信用卡系统、证券交易系统、各种电商类应用，理财类应用基本都是一个中心化系统中的，最多也就是跨表跨数据库。&lt;/p&gt;
&lt;p&gt;如果以上的步骤中，村长和张三的账户分属两个不同的系统，例如从 A 银行到 B 银行，就需要经过人民银行支付系统，即可信任的中心化第三方来做中介。&lt;/p&gt;
&lt;p&gt;你可能发现了，在跨行转账的这种情况下，是没有办法做事务的，所以 1 和 3 是不同步的，如果 3 操作失败，还需要从 2 倒退到 1 的状态，这个情况叫做冲正交易。&lt;/p&gt;
&lt;h3 id=&#34;282-utxo-模型&#34;&gt;2.8.2 UTXO 模型
&lt;/h3&gt;&lt;p&gt;UTXO 全称是：“Unspent Transaction Output”，这指的是：未花费的交易输出。这里面三个单词分别表示 “未花费的”“交易”“输出”，接下来我来详细讲解一下 UTXO 的含义。&lt;/p&gt;
&lt;p&gt;UTXO 的核心设计思路是无状态，它记录的是交易事件，而不记录最终状态，也就是说只记录变更事件，用户需要根据历史记录自行计算余额。&lt;/p&gt;
&lt;p&gt;如下所示：&lt;/p&gt;
&lt;p&gt;　村长　100 万 &amp;ndash;&amp;gt; 张三　10 万 　
　　　　　　　 &amp;ndash;&amp;gt; 村长　90 万&lt;/p&gt;
&lt;p&gt;这里其实有三条子记录，左边一条，右边两条，左边叫做输入，右边叫做输出。&lt;/p&gt;
&lt;p&gt;输入和输出组成了交易，输入和输入需要满足一些约束条件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;任意一个交易必须至少一个输入、一个输出；&lt;/li&gt;
&lt;li&gt;输入必须全部移动，不能只使用部分，所以才产生了第二个输出指向村长自己；&lt;/li&gt;
&lt;li&gt;输入金额 = 输出金额之和 + 交易手续费，这里必须是等式。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于村长来说，首先构造交易的输入输出，满足上述条件，然后广播到全网，接收方自行判断交易是否属于自己。这里满足约束条件构成的交易模型，也就是村长记录的三条转账事件就是 UTXO 模型。&lt;/p&gt;
&lt;h3 id=&#34;283-账户余额模型与-utxo-的比较&#34;&gt;2.8.3 账户余额模型与 UTXO 的比较
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;存储空间，UTXO 占用空间比账户模型高，因为账户模型只记录最终状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;易用性，UTXO 比较难处理，账户模型简单容易理解。例如 UTXO 在使用上，还需要配合高效的 UTXO 组装算法，这个算法要求尽可能降低输入输出的个数，还要让“零钱“归整，算法的复杂度相比账户余额无疑要高。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安全性，UTXO 比账户模型要高，UTXO本身具备 ACID 的记账机制，而账户模型需要自行处理，例如重放攻击。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;普通账户模型具有较高的自由度，可以让智能合约有更好的发挥空间，并且它避免了 UTXO 的复杂组装逻辑，精度控制上也更为得心应手。&lt;/p&gt;
&lt;h3 id=&#34;284-utxo-的特性及缺点&#34;&gt;2.8.4 UTXO 的特性及缺点
&lt;/h3&gt;&lt;p&gt;从计算的角度来说，UTXO 具有非常好的并行支付能力，也就是我们上文中所说的如果没有尺寸限制，一笔交易可以包含任意笔输入输出，同时也没有次序要求，在一笔交易中哪一个 UTXO 在前，哪个在后面不影响最终结果。&lt;/p&gt;
&lt;p&gt;从存储的角度来说，UTXO 具有较好的可裁剪特性，可裁剪性指的是 UTXO 类型的交易，如果从最老的那一笔 UTXO 开始截断数据库，那么之前的数据可以删除掉了。&lt;/p&gt;
&lt;p&gt;如果想进一步压缩数据尺寸，可以在任意位置截断，记录 UTXO 对应的交易哈希即可，然后从其他节点获取并校验 UTXO，这也是 SPV 轻钱包工作的基础之一。&lt;/p&gt;
&lt;p&gt;以太坊中并没有使用比特币的这种 UTXO 设计，这与以太坊的宗旨有关，以太坊的目标是构建通用计算，而比特币是数字货币，需求不同导致设计的不同。&lt;/p&gt;
&lt;p&gt;V 神指出了 UTXO 的缺陷，一共有三类。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可表达的状态少&lt;/li&gt;
&lt;li&gt;区块链盲点（Blockchain-blindness）&lt;/li&gt;
&lt;li&gt;价值盲点（Value-blindness）&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;29去中心化与区块链交易性能&#34;&gt;2.9去中心化与区块链交易性能
&lt;/h2&gt;&lt;p&gt;比特币和以太坊的 TPS 一直被技术领域的人所诟病，或许这与工程师“高性能高并发”的情节有关。&lt;/p&gt;
&lt;h3 id=&#34;291-去中心化&#34;&gt;2.9.1 去中心化
&lt;/h3&gt;&lt;p&gt;去中心化与点对点有区别吗？我认为是有的，去中心化是包含了一定&lt;em&gt;政治主观色彩&lt;/em&gt;的词汇，点对点只是一个中性词汇，更适合用来描述系统的性质。&lt;/p&gt;
&lt;p&gt;去中心化这种说法树立了一个无形的靶子，这个靶子可大可小，大到政府机关，小到小商小贩。&lt;/p&gt;
&lt;p&gt;正如我们说的是 P2P 网络，而不是去中心化网络。所以在技术领域使用点对点，而不是去中心化，可以避免这种概念被过度消费，&lt;/p&gt;
&lt;h3 id=&#34;292技术上的去中心化&#34;&gt;2.9.2技术上的去中心化
&lt;/h3&gt;&lt;p&gt;我们在聊 DPOS 共识机制的时候，提到过一个 TPS 的计算公式，&lt;/p&gt;
&lt;p&gt;TPS = (block_size network_bandwidth witness_performance) / (block_time * witness_count)&lt;/p&gt;
&lt;p&gt;其中 witness_count 记账节点的数目与准入门槛在业界的争议比较大，如果完全去中心化的话，首先就意味着记账节点没有准入门槛，记账的节点可以无限多，当然这只是一个理想环境，工程实施的可行性几乎为零。&lt;/p&gt;
&lt;p&gt;比特币全球的全节点 1.2 万个，大大小小的挖矿节点只有几十个，常出块的只有 5 大矿池，但是比特币依然没有限制记账节点的准入门槛，以太坊也是如此。而在 EOS 中，既规定了记账节点的数目，又规定了门槛。&lt;/p&gt;
&lt;p&gt;可以这么说，控制了记账节点的数量和准入门槛，就等于决定了区块链 TPS 的大小。&lt;/p&gt;
&lt;h3 id=&#34;293-各个区块链的-tps-指标&#34;&gt;2.9.3 各个区块链的 TPS 指标
&lt;/h3&gt;&lt;p&gt;我们接下来看看一些区块链项目的 TPS 指标。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0--3%E6%8A%80%E6%9C%AF%E4%B8%AD/blockChain_3-3.png&#34;
	width=&#34;918&#34;
	height=&#34;250&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0--3%E6%8A%80%E6%9C%AF%E4%B8%AD/blockChain_3-3_hu_d4acab4695f02bf4.png 480w, https://zhenyu0324.github.io/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0--3%E6%8A%80%E6%9C%AF%E4%B8%AD/blockChain_3-3_hu_1e0a116afcedbf0b.png 1024w&#34;
	loading=&#34;lazy&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;367&#34;
		data-flex-basis=&#34;881px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;图中是 TPS 都在千笔以上的区块链项目，通过控制了记账节点的数量，牺牲了去中心化特性提升了 TPS，比如石墨烯系列的 DPOS，Ripple 的共识。&lt;/p&gt;
&lt;h3 id=&#34;294-业界的可选方案之一sharding-分片&#34;&gt;2.9.4 业界的可选方案之一：Sharding 分片
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;如何提升 TPS ？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;目前一共有两种正在讨论的方案，分别是 Sharding 分片技术和闪电网络。闪电网络旨在解决比特币微小额支付的实时性问题，其中的算法是比特币 TPS 扩展的一种方案。&lt;/p&gt;
&lt;p&gt;这两种方案不涉及修改共识机制。如果我们修改为 DPoS 共识机制、DAG 共识算法，也可以提升 TPS，不过不在本篇的讨论范围。&lt;/p&gt;
&lt;p&gt;分片技术是一种安装传统数据库分片的扩展，主要思路是将数据库分成多个分区（碎片）并将分区放置在不同的服务器上。&lt;/p&gt;
&lt;p&gt;在区块链场景下，全网的节点相当于于分布式数据库中的不同服务器，这时候我们可以将交易分成不同的部分，然后每个记账节点只需要验证交易的一部分即可，而不必验证完整的交易性。&lt;/p&gt;
&lt;p&gt;这带来的好处是就是并行化处理，记账节点之间相当于是协作关系，而不再是单纯的独立关系。&lt;/p&gt;
&lt;p&gt;随着网络的增长，这种协作关系也可以随之扩展，这种扩展也叫做水平扩容。&lt;/p&gt;
&lt;p&gt;分片的两种方案：状态分片、网络分片。&lt;/p&gt;
&lt;p&gt;第一种方案是是网络分片，网络分片是我们按照网络进行分区，区域内的交易归集在一起并在区域内进行验证，这样区域内的用户可以享受低延迟高吞吐的 TPS，但是会带来跨区域分片的复杂性。我们也可以将网络分片比喻成数据库集群分区。&lt;/p&gt;
&lt;p&gt;其次是状态分片，状态分片是在以太坊上提出的方案，状态分片目前没有确切的技术方案，尚在研究讨论阶段。&lt;/p&gt;
&lt;h2 id=&#34;210-智能合约与以太坊&#34;&gt;2.10 智能合约与以太坊
&lt;/h2&gt;&lt;h3 id=&#34;2101-智能合约&#34;&gt;2.10.1 智能合约
&lt;/h3&gt;&lt;p&gt;不同于法律意义上的合约概念，区块链领域的合约表达的是可以“自治自理”的 计算机协议，这套协议具有自我执行、自我验证的属性。&lt;/p&gt;
&lt;p&gt;如果完全从技术角度来看，智能合约等价于一段事先就被规定好逻辑和条款的计算机代码被激活运行的状态，同时，智能合约也提供了通用的用户接口，用户可以通过接口与用户交互。&lt;/p&gt;
&lt;p&gt;智能合约这一概念早在 20 世纪 90 年代就有人提出，这个人是从事智能合约和数字货币研究的尼克萨博（Nick Szabo）博士，尼克 1996 年在《Extopy》期刊上发表了对智能合约的描述，他认为智能合约是一个由数字表单指定的承诺，这个承诺包含关系到多方执行的一组协议。&lt;/p&gt;
&lt;p&gt;从定义中我们可以得知，智能合约由多个协议组成，这些协议包含了用户接口，能表达用户的承诺，它可以安全有效地确定公共网络上的关系。&lt;/p&gt;
&lt;p&gt;换句话说，智能合约是一个由计算机处理、可执行合约条款的交易协议，其总体目标是满足协议既定的条件，例如支付、抵押、保密协议。这可以降低合约欺诈造成的损失，降低仲裁和强制执行所产生的成本以及其他的交易成本。&lt;/p&gt;
&lt;h3 id=&#34;2102-以太坊及其发展历史&#34;&gt;2.10.2 以太坊及其发展历史
&lt;/h3&gt;&lt;p&gt;以太坊 Ethereum 项目的目标是打造一个去中心化的新一代互联网应用平台，这个平台称作 Dapp 平台。&lt;/p&gt;
&lt;p&gt;这些 Dapp 基于以太坊智能合约虚拟机开发、编译、部署，并且可以自定义业务逻辑，部署后全网可见且自动执行，理想情况下不存在宕机、审查、欺诈、第三方干预的情况。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;2013 年底以太坊的创始人 Vitalik 在比特币开发者社区提出了可以运行图灵完备（Turing-complete）形式的应用，但这一思想并没有得到比特币社区的支持。&lt;/p&gt;
&lt;p&gt;2014 年，Vitalik 带着自己的想法，宣布以太坊项目正式成立，2014 年上半年开始筹集资金，聚拢一些早期开发者，同年 7 月份进行了为期 42 天的 ICO，共筹集了超过 1800 万美元的比特币。&lt;/p&gt;
&lt;p&gt;2015 年 7 月，第一个版本的以太坊发布，主网正式上线，这一阶段 Bug 和设计缺陷较多，多是开发者在使用。&lt;/p&gt;
&lt;p&gt;2016 年以太坊发布第二个大版本 Homestead，用户逐渐多了起来，同期也吸纳了不少 Dapp 开发者。&lt;/p&gt;
&lt;p&gt;2016 年 6 月，以太坊上发生了著名的黑天鹅事件——TheDAO 事件，这打开了 ICO 市场，同时也造成了以太坊社区分叉，形成了以太坊和以太坊经典两个代币。&lt;/p&gt;
&lt;p&gt;2017 年 4 月，ICO 风靡中国，ERC20 提供了低成本方便高效的资金募集方式，为 ICO 提供了极大的便利，趁着数字货币牛市，以太坊的价格涨幅达十多倍，2018 年 1 月以太坊价格突破 1000 美元。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;2103-以太坊的核心概念&#34;&gt;2.10.3 以太坊的核心概念
&lt;/h3&gt;&lt;p&gt;以太坊核心概念包括：智能合约虚拟机 EVM 和 Solidity 编程语言、账户模型、以太币和 Gas，交易和消息。&lt;/p&gt;
&lt;h4 id=&#34;21031-智能合约虚拟机-evm-和-solidity-编程语言&#34;&gt;2.10.3.1 智能合约虚拟机 EVM 和 Solidity 编程语言
&lt;/h4&gt;&lt;p&gt;以太坊的核心概念首先是智能合约。&lt;/p&gt;
&lt;p&gt;智能合约包含两部分，一部分是开发语言，主要以 Solidity 为主，Solidity 与 Javascript 语言在使用上十分接近，这极大地降低了 Dapp 开发人员的学习成本。&lt;/p&gt;
&lt;p&gt;另一部分就是 EVM。 EVM 是以太坊智能合约虚拟机，我们可以等价理解它为 Javascript、Python 等脚本语言的执行引擎。&lt;/p&gt;
&lt;p&gt;它是一个轻量级的虚拟机隔离环境，它并不提供访问本地网络、进程、文件系统的功能，它更像是一个封闭的容器，这个容器里面装了一个正在运行 Dapp，可以看成是无法和外界交互的 Docker Container。&lt;/p&gt;
&lt;h4 id=&#34;21032-账户模型&#34;&gt;2.10.3.2 账户模型
&lt;/h4&gt;&lt;p&gt;以太坊并没有采用 UTXO 模型，也不同于银行账户，它是由以太坊开发者设计了自己的账户模型。&lt;/p&gt;
&lt;p&gt;以太坊上的账户有两种类型，第一类叫做合约账户 CA（Contracts Accounts)，第二类叫做外部账户 EOA（Externally Owned Accounts）。&lt;/p&gt;
&lt;p&gt;简单理解就是：CA 是智能合约代码用的账户，EOA 是人用的账户；所以 CA 可以存储并执行智能合约代码，它的智能被 EOA 激活，它也不保存和存储私钥，合约账户可以调用其他合约。&lt;/p&gt;
&lt;p&gt;EOA 则是人们直接控制的账户，可以存储以太币，可以发送交易到合约账户，触发既定的逻辑。EOA 账户由公钥标识，由对应的私钥控制。&lt;/p&gt;
&lt;h4 id=&#34;21033-以太币和-gas&#34;&gt;2.10.3.3 以太币和 Gas
&lt;/h4&gt;&lt;p&gt;Gas 是执行智能合约操作的燃料，智能合约的每一个步骤都会消耗 Gas，Gas 是由以太坊的平台代币以太币转化而来，最小单位是 wei，1ETH 相当于 10 的 18 次方 wei。&lt;/p&gt;
&lt;p&gt;以太币可以通过 PoW 挖矿而产生，目前以太坊主要通过 GPU 挖矿。挖出一个块可以换得 5 个以太币，并且还有一定的交易费、以及叔伯块的奖励。今年 4 月 6 日爆出著名矿机芯片厂商比特大陆已经开发出针对以太坊的 ASIC 专业矿机，相比 GPU 的效率提升 2.5 倍。&lt;/p&gt;
&lt;p&gt;以太坊上的交易与比特币中的 UTXO 交易不同，它是指 EOA 账户将一个经过签名的数据包发送到另外一个账户的过程，这个过程产生的账户状态变化将被存储到以太坊区块链上。&lt;/p&gt;
&lt;p&gt;以太坊上除了交易还有消息这个概念，消息指一个合约账户调用其他合约账户的过程，可以类比函数调用过程。&lt;/p&gt;
&lt;p&gt;所以以太坊上的 Dapp 如果被触发，有两种可能，第一种是交易触发，第二种是消息触发。&lt;/p&gt;
&lt;p&gt;这两种的区别在于前者是 EOA 发起的，后者只能是其他合约账户发起的。&lt;/p&gt;
&lt;h4 id=&#34;21034-交易和消息&#34;&gt;2.10.3.4 交易和消息
&lt;/h4&gt;&lt;p&gt;以太坊上的交易与比特币中的 UTXO 交易不同，它是指 EOA 账户将一个经过签名的数据包发送到另外一个账户的过程，这个过程产生的账户状态变化将被存储到以太坊区块链上。&lt;/p&gt;
&lt;p&gt;以太坊上除了交易还有消息这个概念，消息指一个合约账户调用其他合约账户的过程，可以类比函数调用过程。&lt;/p&gt;
&lt;p&gt;所以以太坊上的 Dapp 如果被触发，有两种可能，第一种是交易触发，第二种是消息触发。&lt;/p&gt;
&lt;p&gt;这两种的区别在于前者是 EOA 发起的，后者只能是其他合约账户发起的。&lt;/p&gt;
&lt;h4 id=&#34;21035-与比特币的主要区别&#34;&gt;2.10.3.5 与比特币的主要区别
&lt;/h4&gt;&lt;p&gt;以太坊项目又被称作区块链 2.0 项目，这里 2.0 就是指智能合约。那么以太坊与比特币相比，到底智能在那里呢？我们具体来看看。&lt;/p&gt;
&lt;p&gt;与比特币相比，以太坊首先不是一个单纯的数字货币项目，它可以提供全世界无差别的区块链智能合约应用平台，包含四大模块：P2P 网络、共识机制、账户模型、加密模块。&lt;/p&gt;
&lt;p&gt;区块链的开发者因为智能合约的出现开始分为两类。第一类是公链底层开发者，主要是以 C++ 和 Go 语言为主的全节点开发者，他们需要对区块链各个技术模块有很深的理解。&lt;/p&gt;
&lt;p&gt;第二类是智能合约开发者，也就是应用开发者，这类开发者对区块链的运行原理不需要理解很深，只需要会编写 Solidity，了解规范即可。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>区块链学习--2技术上</title>
        <link>https://zhenyu0324.github.io/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0--2%E6%8A%80%E6%9C%AF%E4%B8%8A/</link>
        <pubDate>Fri, 05 Feb 2021 10:15:28 +0800</pubDate>
        
        <guid>https://zhenyu0324.github.io/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0--2%E6%8A%80%E6%9C%AF%E4%B8%8A/</guid>
        <description>&lt;h1 id=&#34;2-区块链技术&#34;&gt;2. 区块链技术
&lt;/h1&gt;&lt;h2 id=&#34;21-技术基础&#34;&gt;2.1 技术基础
&lt;/h2&gt;&lt;h3 id=&#34;211-区块链的技术定义&#34;&gt;2.1.1 区块链的技术定义
&lt;/h3&gt;&lt;p&gt;简单来说，区块链是一个提供了拜占庭容错、并保证了最终一致性的分布式数据库。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从数据结构上看，它是基于时间序列的链式数据块结构&lt;/li&gt;
&lt;li&gt;从节点拓扑上看，它所有的节点互为冗余备份&lt;/li&gt;
&lt;li&gt;从操作上看，它提供了基于密码学的公私钥管理体系来管理账户&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;区块链在技术上的 7 个特征&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;区块链的存储基于分布式数据库；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据库是区块链的数据载体，区块链是交易的业务逻辑载体；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;区块链按时间序列化区块数据，整个网络有一个最终确定状态；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;区块链只对添加有效，对其他操作无效；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;交易基于非对称加密的公私钥验证；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;区块链网络要求拜占庭将军容错；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;共识算法能够“解决”双花问题&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;212-区块链的类型&#34;&gt;2.1.2 区块链的类型
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;公有区块链
区块链通常指的是公有区块链&lt;/li&gt;
&lt;li&gt;联盟链
所谓联盟链，就是这个区块链具有准入许可，不像公链，任何人都可以随时进入。准入许可也就意味着候选节点进入区块链时需要得到已经在网络中的节点许可，所以联盟链也叫做许可链。&lt;/li&gt;
&lt;li&gt;侧链
侧链是一种双向挂钩技术，将主链中的代币锁定到侧链中使用。所以可以将主链看作主干道，侧链看作与主链相对独立的一条分支道，作为主链功能的低耦合拓展。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;213区块链的核心技术组成&#34;&gt;2.1.3区块链的核心技术组成
&lt;/h3&gt;&lt;p&gt;四个组成模块&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;P2P 网络协议&lt;/li&gt;
&lt;li&gt;分布式一致性算法（共识机制）&lt;/li&gt;
&lt;li&gt;加密签名算法&lt;/li&gt;
&lt;li&gt;账户与存储模型&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;2131-p2p-网络协议&#34;&gt;2.1.3.1 P2P 网络协议
&lt;/h4&gt;&lt;p&gt;P2P 网络协议是所有区块链的最底层模块，负责交易数据的网络传输和广播、节点发现和维护&lt;/p&gt;
&lt;p&gt;通常我们所用的都是比特币 P2P 网络协议模块，它遵循一定的交互原则。比如：初次连接到其他节点会被要求按照&lt;strong&gt;握手协议&lt;/strong&gt;来确认状态，在握手之后开始请求 Peer 节点的&lt;strong&gt;地址数据&lt;/strong&gt;以及&lt;strong&gt;区块数据&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这套 P2P 交互协议也具有自己的指令集合，指令体现在在消息头（Message Header) 的命令（command）域中，这些命令为上层提供了节点发现、节点获取、区块头获取、区块获取等功能。&lt;/p&gt;
&lt;h4 id=&#34;2132分布式一致性算法&#34;&gt;2.1.3.2分布式一致性算法
&lt;/h4&gt;&lt;p&gt;在经典分布式计算领域，我们有 Raft 和 Paxos 算法家族代表的非拜占庭容错算法，以及具有拜占庭容错特性的 PBFT 共识算法。&lt;/p&gt;
&lt;p&gt;如果从技术演化的角度来看，我们可以得出一个图，其中，区块链技术把原来的分布式算法进行了经济学上的拓展。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/images/blockchain2_01.jpg&#34;
	
	
	
	loading=&#34;lazy&#34;
	
	
&gt;&lt;/p&gt;
&lt;p&gt;在图中我们可以看到，计算机应用在最开始多为单点应用，高可用方便采用的是冷灾备，后来发展到异地多活，这些异地多活可能采用的是负载均衡和路由技术，随着分布式系统技术的发展，我们过渡到了 Paxos 和 Raft 为主的分布式系统。&lt;/p&gt;
&lt;p&gt;而在区块链领域，多采用 PoW 工作量证明算法、PoS 权益证明算法，以及 DPoS 代理权益证明算法，以上三种是业界主流的共识算法，这些算法与经典分布式一致性算法不同的是融入了经济学博弈的概念，下面我分别简单介绍这三种共识算法。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;PoW：通常是指在给定的约束下，求解一个特定难度的数学问题，谁解的速度快，谁就能获得记账权（出块）权利。这个求解过程往往会转换成计算问题，所以在比拼速度的情况下，也就变成了谁的计算方法更优，以及谁的设备性能更好。比特币本身的演化很好地诠释了这个问题，中本聪设计的思路本来是由 CPU 计算。随着市场发展，人们发现 GPU 也可以参与其中，而且效率可以达到十倍百倍，现在，这项工作基本以 ASIC 专业挖矿芯片为主。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PoS：这是一种股权证明机制，它的基本概念是产生区块的难度应该与你在网络里所占的股权（所有权占比）成比例，目前有三个版本 PoS1.0、PoS2.0、PoS3.0。它实现的核心思路是：使用你所锁定代币的币龄（CoinAge）以及一个小的工作量证明，去计算一个目标值，当满足目标值时，你将可能获取记账权。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DPoS：简单来理解就是将 PoS 共识算法中的记账者转换为指定节点数组成的小圈子，而不是所有人都可以参与记账，这个圈子可能是 21 个节点，也有可能是 101 个节点。这一点取决于设计，只有这个圈子中的节点才能获得记账权。这将极大地提高系统的吞吐量，因为更少的节点也就意味着网络和节点的可控。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;2133加密签名算法&#34;&gt;2.1.3.3加密签名算法
&lt;/h4&gt;&lt;p&gt;在区块链领域，哈希算法是应用得最多的算法。哈希算法具有抗碰撞性、原像不可逆、难题友好性等特征。&lt;/p&gt;
&lt;p&gt;其中，难题友好性正是众多 PoW 币种赖以存在的基础，在比特币中，SHA256 算法被用作工作量证明的计算方法，也就是我们所说的挖矿算法。&lt;/p&gt;
&lt;p&gt;区块链 Token 系统的基石：公私钥密码算法&lt;/p&gt;
&lt;p&gt;在比特币大类的代码中，基本上使用的都是 ECDSA。ECDSA 是 ECC 与 DSA 的结合，整个签名过程与 DSA 类似，所不一样的是签名中采取的算法为 ECC（椭圆曲线函数）。&lt;/p&gt;
&lt;h4 id=&#34;2134-账户与交易模型&#34;&gt;2.1.3.4 账户与交易模型
&lt;/h4&gt;&lt;p&gt;区块链的账本特性，通常分为 UTXO 结构以及基于 Account-Balance 结构的账本结构，我们也称为账本模型。UTXO 是“unspent transaction input/output”的缩写，翻译过来就是指“未花费的交易输入输出”。&lt;/p&gt;
&lt;p&gt;这个区块链中 Token 转移的一种记账模式，每次转移均以输入输出的形式出现。而在 Balance 结构中，是没有这个模式的。&lt;/p&gt;
&lt;h2 id=&#34;22-p2p网络&#34;&gt;2.2 P2P网络
&lt;/h2&gt;&lt;p&gt;比特币、以太坊等众多数字货币都实现了属于自己的 P2P 网络协议。&lt;/p&gt;
&lt;p&gt;主要有4部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;区块链的网络连接与拓扑结构&lt;/li&gt;
&lt;li&gt;节点发现&lt;/li&gt;
&lt;li&gt;局域网穿透&lt;/li&gt;
&lt;li&gt;节点交互协议&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;221-网络连接与拓扑结构&#34;&gt;2.2.1 网络连接与拓扑结构
&lt;/h3&gt;&lt;h4 id=&#34;2211-网络连接&#34;&gt;2.2.1.1 网络连接
&lt;/h4&gt;&lt;p&gt;除去少数支持 UDP 协议的区块链项目外，绝大部分的区块链项目所使用的底层网络协议依然是 TCP/IP 协议。&lt;/p&gt;
&lt;p&gt;所以从网络协议的角度来看，区块链其实是基于 TCP/IP 网络协议的，这与 HTTP 协议、SMTP 协议是处在同一层，也就是应用层。&lt;/p&gt;
&lt;p&gt;比特币的 P2P 网络基于 TCP 构建，主网默认通信端口为 8333。&lt;/p&gt;
&lt;p&gt;以太坊的 P2P 网络则与比特币不太相同，以太坊 P2P 网络是一个完全加密的网络，提供 UDP 和 TCP 两种连接方式，主网默认 TCP 通信端口是 30303，推荐的 UDP 发现端口为 30301。&lt;/p&gt;
&lt;h4 id=&#34;2212-拓扑结构&#34;&gt;2.2.1.2 拓扑结构
&lt;/h4&gt;&lt;p&gt;P2P 网络拓扑结构有很多种，有些是中心化拓扑，有些是半中心化拓扑，有些是全分布式拓扑结构。&lt;/p&gt;
&lt;p&gt;比特币全节点组成的网络是一种全分布式的拓扑结构，节点与节点之间的传输过程更接近“泛洪算法”，即：交易从某个节点产生，接着广播到临近节点，临近节点一传十十传百，直至传播到全网。﻿﻿&lt;/p&gt;
&lt;h3 id=&#34;222-节点发现&#34;&gt;2.2.2 节点发现
&lt;/h3&gt;&lt;p&gt;节点发现是任何区块链节点接入区块链 P2P 网络的第一步。这与你孤身一人去陌生地方旅游一样，如果没有地图和导航，那你只能拽附近的人问路，“拽附近的人问路”的这个动作就可以理解成节点发现。&lt;/p&gt;
&lt;h4 id=&#34;2221-初始节点发现&#34;&gt;2.2.2.1 初始节点发现
&lt;/h4&gt;&lt;p&gt;节点发现可分为初始节点发现，和启动后节点发现。&lt;/p&gt;
&lt;p&gt;初始节点发现一共有两种方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一种叫做 DNS-seed，又称 DNS 种子节点，DNS 就是中心化域名查询服务，比特币的社区维护者会维护一些域名。&lt;/li&gt;
&lt;li&gt;第二种方式就是，代码中硬编码（ hard-code ）了一些地址，这些地址我们称之为种子节点（seed-node），当所有的种子节点全部失效时，全节点会尝试连接这些种子节点。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;启动后节点发现&#34;&gt;启动后节点发现
&lt;/h4&gt;&lt;p&gt;在 Bitcoin 的网络中，一个节点可以将自己维护的对等节点列表 (peer list) 发送给临近节点，所以在初始节点发现之后，你的节点要做的第一件事情就是向对方要列表：“快把你的节点列表给我复制一份。”&lt;/p&gt;
&lt;p&gt;所以在每次需要发送协议消息的时候，它会花费固定的时间尝试和已存的节点列表中的节点建立链接，如果有任何一个节点在超时之前可以连接上，就不用去 DNS seed 获取地址，一般来说，这种可能性很小，尤其是全节点数目非常多的情况下。&lt;/p&gt;
&lt;p&gt;而在以太坊网络中，也会维护类似的一个节点列表 (NodeTable)，但是这个节点列表与比特币的简单维护不同，它采用了 P2P 网络协议中一个成熟的算法，叫做 Kademlia 网络，简称 KAD 网络。&lt;/p&gt;
&lt;h4 id=&#34;2223-黑名单与长连接&#34;&gt;2.2.2.3 黑名单与长连接
&lt;/h4&gt;&lt;p&gt;公有区块链面临的网络环境是非常开放的，任何人只要下载好钱包，打开运行就进入了这个 P2P 网络，这也会带来被攻击的可能。&lt;/p&gt;
&lt;p&gt;不过总的来说，黑名单我们也可以通过操作系统的防火墙去处理，这并不算一个特别棘手的问题。&lt;/p&gt;
&lt;h3 id=&#34;223-局域网穿透&#34;&gt;2.2.3 局域网穿透
&lt;/h3&gt;&lt;p&gt;公网与局域网建立 映射
NAT 技术和 UPnP 协议&lt;/p&gt;
&lt;p&gt;NAT 技术非常常见，这里使用的是源 NAT，简而言之就是替换 TCP 报文中的源地址并映射到内网地址。&lt;/p&gt;
&lt;p&gt;UPnP 是通用即插即用（Universal Plug and Play）的缩写，它主要用于设备的智能互联互通，所有在网络上的设备马上就能知道有新设备加入。&lt;/p&gt;
&lt;h3 id=&#34;234-节点交互协议&#34;&gt;2.3.4 节点交互协议
&lt;/h3&gt;&lt;p&gt;一旦节点建立连接以后，节点之间的交互是遵循一些特定的命令，这些命令写在消息的头部，消息体写的则是消息内容。&lt;/p&gt;
&lt;p&gt;命令分为两种，一种是请求命令，一种是数据交互命令。&lt;/p&gt;
&lt;h2 id=&#34;23-共识算法与分布式一致性算法&#34;&gt;2.3 共识算法与分布式一致性算法
&lt;/h2&gt;&lt;p&gt;分布式系统面临的问题
分布式系统面临了几个问题：一致性问题，可终止性问题、合法性问题。&lt;/p&gt;
&lt;p&gt;可终止性可以理解为系统必须在有限的时间内给出一致性结果，合法性是指提案必须是系统内的节点提出。当然其中面对的最重要也是最基础的问题，就是我们常说的一致性问题。&lt;/p&gt;
&lt;p&gt;一致性是指在某个分布式系统中，任意节点的提案能够在约定的协议下被其他所有节点所认可。&lt;/p&gt;
&lt;h3 id=&#34;231-有关分布式系统的定理&#34;&gt;2.3.1 有关分布式系统的定理
&lt;/h3&gt;&lt;p&gt;我们在介绍具体的分布式一致性算法之前，先介绍两个定理，做一下铺垫。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一个是 FLP 不可能性，简单来说是：即使网络通信完全可靠，只要产生了拜占庭错误，就不存在一个确定性的共识算法能够为异步分布式系统提供一致性。换句话来说就是，不存在一个通用的共识算法可以解决所有的拜占庭错误。&lt;/li&gt;
&lt;li&gt;第二个是 CAP 定理，CAP 定理是分布式系统领域最重要的定理之一，这个我们在“理解区块链的常见误区”一文中稍微讲到过。也就是在设计分布式系统的过程中，“一致性”“可用性”“分区容忍性”三者中，我们只能选择两个作为主要强化的点，另外一个必然会被弱化。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们由 CAP 定理可以推导出严格一致性和最终一致性。&lt;/p&gt;
&lt;p&gt;通过以上我们可以发现比特币、以太坊等公链是偏重高可用性、分区容忍性（AP），满足最终一致性（C）且 TPS 较低的分布式系统。&lt;/p&gt;
&lt;h3 id=&#34;232-共识算法与分布式一致性算法&#34;&gt;2.3.2 共识算法与分布式一致性算法
&lt;/h3&gt;&lt;h4 id=&#34;2321-经典的分布式一致性算法&#34;&gt;2.3.2.1 经典的分布式一致性算法
&lt;/h4&gt;&lt;p&gt;经典分布式一致性算法有 Raft 协议，Raft 协议是一种强 Leader 的一致性算法，它的吞吐量基本就是 Leader 的吞吐量，它无法抵御节点恶意篡改数据的攻击。&lt;/p&gt;
&lt;p&gt;稍微复杂一点的就是 Paxos 协议，Paxos 能提供不同场合不同种类的一致性算法，所以 Paxos 有很多变种，经典 Paxos 是 Leaderless 的，有变种是强 Leader 型的，叫做 Fast Paxos，有关 Paxos 的文献非常丰富，这里就不赘述了。&lt;/p&gt;
&lt;p&gt;以上两种都是不提供拜占庭容错的系统，下面介绍一种具有拜占庭容错的一致性算法。&lt;/p&gt;
&lt;p&gt;PBFT 全称实用性拜占庭容错系统（Practical Byzantine Fault Tolerance, PBFT)，PBFT 是一种状态机，要求所有节点共同维护一个状态，所有节点采取的行动一致，PBFT 非常适合联盟链等对性能具有较高要求的场合，超级账本项目中的 Fabric 框架默认采用的就是 PBFT 的修改版本。&lt;/p&gt;
&lt;h4 id=&#34;2322-区块链共识算法&#34;&gt;2.3.2.2 区块链共识算法
&lt;/h4&gt;&lt;p&gt;区块链的共识算法，我在某些场合直接称作基于经济学的博弈算法，以区别于经典分布式一致性算法思路，它的整体思路就是让攻击者的攻击成本远远大于收益。&lt;/p&gt;
&lt;p&gt;区块链中的共识算法目前具有工业成熟度的是 PoW，另外两种比较成熟的是 PoS 和 DPoS，其次还有一些变种和单一币种使用的共识算法，例如 Ripple 共识、
PoC 共识（概念性证明）、PoE 共识（存在性证明）。&lt;/p&gt;
&lt;p&gt;在使用 PoW 共识算法的情况下，容错阈值是 50%，而 PBFT 及其变种的容错阈值是 33% 左右，这里的百分比是指作弊节点占全网节点的比例。&lt;/p&gt;
&lt;h2 id=&#34;24-pow共识&#34;&gt;2.4 PoW共识
&lt;/h2&gt;&lt;h3 id=&#34;241-pow-工作量证明&#34;&gt;2.4.1 PoW 工作量证明
&lt;/h3&gt;&lt;p&gt;PoW 全称 Proof of Work，中文名是工作量证明，PoW 共识机制其实是一种设计思路，而不是一种具体的实现。PoW 机制其实早在 1997 年就被提出了，它早期多被应用在抵抗滥用软件服务的场景中，例如抵抗垃圾邮件（所以 PoW在邮件服务系统会有所涉及）。&lt;/p&gt;
&lt;h3 id=&#34;242-如何理解区块链-pow&#34;&gt;2.4.2 如何理解区块链 PoW
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;举个例子，假设我们给定一个字符串“geekbang”，我们提出的难题是，计算一个数字，与给定的字符串连接起来，使这个字符串的 SHA256 计算结果的前 4 位是 0，这个数字我们称作 nonce，比如字符串 &amp;ldquo;geekbang1234&amp;rdquo;，nonce 就是 1234，我们要找到符合条件的 nonce。&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;实际挖矿的基本步骤如下。&lt;/p&gt;
&lt;p&gt;生成 Coinbase 交易，并与其他所有准备打包进区块的交易组成交易列表，并生成默克尔哈希；
把默克尔哈希及其他相关字段组装成区块头，将区块头（Block Header）作为工作量证明的输入，区块头中包含了前一区块的哈希，区块头一共 80 字节数据；
不停地变更区块头中的随机数即 nonce 的数值，也就是暴力搜索，并对每次变更后的的区块头做双重 SHA256 运算，即 SHA256(SHA256(Block_Header))），将结果值与当前网络的目标值做对比，如果小于目标值，则解题成功，工作量证明完成。&lt;/p&gt;
&lt;p&gt;如果更深程度去理解的话，PoW 机制是将现实世界的物理资源转化成区块链上虚拟资源的过程，这种转化为区块链提供了可信的前提。&lt;/p&gt;
&lt;h3 id=&#34;243-pow-挖矿的发展历程&#34;&gt;2.4.3 PoW 挖矿的发展历程
&lt;/h3&gt;&lt;p&gt;在区块链的发展史上，PoW 经历了大致两个阶段。分为&lt;strong&gt;早期分散挖矿阶段&lt;/strong&gt;和&lt;strong&gt;中心化矿池挖矿阶段&lt;/strong&gt;。我们目前处于第二个阶段，并且将会长期处于这个阶段。&lt;/p&gt;
&lt;p&gt;早期分散挖矿是中本聪的愿景，期望是 1CPU=1 票，所以如果 CPU 挖矿，那么将会是非常理想化的情况，而现实的情况是，SHA256 只需要非常简单的重复计算逻辑，它不需要复杂的逻辑控制。&lt;/p&gt;
&lt;p&gt;那么 CPU这种重控制逻辑，轻重复计算的计算单元来搞这么低端的暴力计算非常吃力不讨好，大部分人的第一反应肯定是用 GPU 呀，非常正确。除了 GPU 挖矿，我们还有 ASIC 芯片挖矿。&lt;/p&gt;
&lt;p&gt;中心化挖矿很好理解，算力如果越分散，也就意味着竞争越激烈，如果某个节点计算出答案了，那么也意味着其他矿工这段时间的工作量几乎都白费了，投入了物理资源结果零收益，可以说是负收益。&lt;/p&gt;
&lt;p&gt;那怎么办呢？思路就是把分散的算力汇聚到一个池子里面，这个池子我们称作矿池，就像四面八方的小溪流最终汇总成一条大江一样。&lt;/p&gt;
&lt;p&gt;矿工参与到某个矿池，相当于矿工把算力租给矿池了，与其他矿工联合挖矿，最后看起来矿池这个节点的算力就会很大，获得记账权的概率就越大，如果这个矿池计算出了答案，将获得 Coinbase 的奖励，矿池就会按既定的分配比例打给每一位参与的矿工。&lt;/p&gt;
&lt;h3 id=&#34;244-pow-挖矿算法分类与简介&#34;&gt;2.4.4 PoW 挖矿算法分类与简介
&lt;/h3&gt;&lt;p&gt;PoW 挖矿算法大致分为两个大类，第一类叫做计算困难，第二类叫内存困难。&lt;/p&gt;
&lt;p&gt;这两类的区别在于对于提供工作量证明的组件要求不同。我们知道计算机的组成分为计算单元和存储单元，通过以往的编程经验我们还可以知道，一个计算机的瓶颈往往是 IO，如果要制造大量的 IO 操作，可以通过写程序撑大内存，制造大量的数据处理过程，使工作量证明从计算单元转变为存储单元。&lt;/p&gt;
&lt;p&gt;其实在 PoW 挖矿中心化以后，又出现了一次挖矿工具改进，这次超越了 GPU，人们先是尝试在 FPGA 上尝试 SHA256 的计算过程，结果计算效率成倍于 GPU。&lt;/p&gt;
&lt;p&gt;FPGA 出现的时间比较短暂，最终人们开发出了 ASIC 专业芯片来计算 SHA256，这就是我们常说的专业矿机。&lt;/p&gt;
&lt;p&gt;以太坊的 PoW 挖矿算法：ETHASH，ETHASH 是 Dagger-Hashimoto 的修改版本，它是典型的内存困难型挖矿算法。&lt;/p&gt;
&lt;h3 id=&#34;245-pow-的优势和劣势&#34;&gt;2.4.5 PoW 的优势和劣势
&lt;/h3&gt;&lt;p&gt;PoW 共识的内在优势在于可以稳定币价，因为在 PoW 币种下，矿工的纯收益来自 Coinbase 奖励减去设备和运营成本，成本会驱使矿工至少将币价维持在一个稳定水平，所以攻击者很难在短时间内获得大量算力来攻击主链。&lt;/p&gt;
&lt;p&gt;PoW 共识的外在优势是目前它看起来依然是工业成熟度最高的区块共识算法，所以在用户信任度上、矿工基础上都有很好的受众。&lt;/p&gt;
&lt;p&gt;PoW 共识最大的缺点是非常消耗计算资源，耗电耗能源，这一点也一直为人们所诟病。因为每次产生新的区块都会让相当一部分工作量证明白白浪费了，也就是将计算资源浪费了。&lt;em&gt;目前来看这个是无解的，只要是 PoW 共识，一定会遇到计算资源浪费的问题。&lt;/em&gt;&lt;/p&gt;
&lt;h4 id=&#34;双花攻击与自私挖矿&#34;&gt;双花攻击与自私挖矿
&lt;/h4&gt;&lt;p&gt;从理论上来看，PoW 会一直有 51% 算力攻击的问题，即攻击者只需要购买超过全网 51% 算力设备，即可发起“双花攻击”，甚至“重放攻击”等多种高收益攻击，这个问题目前没有解决方案。&lt;/p&gt;
&lt;p&gt;除了 51% 攻击，PoW 共识还有自私挖矿的问题，自私挖矿是一种特殊的攻击类型，不会影响区块链正常运转，但是会形成矿霸，间接造成 51% 攻击，我们就曾经遇到过这样的自私挖矿攻击。&lt;/p&gt;
&lt;h2 id=&#34;25-pos共识机制&#34;&gt;2.5 PoS共识机制
&lt;/h2&gt;&lt;p&gt;&lt;em&gt;PoS 全称是 Proof of Stake，中文翻译为权益证明。&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&#34;251-pos-的由来&#34;&gt;2.5.1 PoS 的由来
&lt;/h3&gt;&lt;p&gt;PoS 最早出现在点点币的创始人 Sunny King 的白皮书中，它的目的就是为了解决使用 PoW 挖矿出现大量资源浪费的问题。&lt;/p&gt;
&lt;h3 id=&#34;252-什么是-pos&#34;&gt;2.5.2 什么是 PoS？
&lt;/h3&gt;&lt;p&gt;我先来讲一个叫做币龄的概念，币龄这个概念其实很好理解，它的英文是 CoinAge，字面意思就是币数量乘以天数。&lt;/p&gt;
&lt;p&gt;我们回过头来看看 PoS 究竟是什么，区块链共识机制的第一步就是随机筛选一个记账者，PoW 是通过计算能力来获得记账权，计算能力越强，获得记账权的概率越大。&lt;/p&gt;
&lt;p&gt;PoS 则将此处的计算能力更换为财产证明，就是节点所拥有的币龄越多，获得的记账的概率就越大。这有点像公司的股权结构，股权占比大的合伙人话语权越重。&lt;/p&gt;
&lt;p&gt;PoS 的发展经历了三个版本，第一个版本是以点点币为代币的 PoS1.0 版本，这个版本中使用的是币龄；第二个版本为代表的是黑币（blackcoin），它使用的为 PoS2.0 版本，对应这个版本使用的是币数量，相当于是财产证明，后面黑币又升级到 PoS3.0，这个版本又回到了币龄。&lt;/p&gt;
&lt;h3 id=&#34;253-pos-的实现原理&#34;&gt;2.5.3 PoS 的实现原理
&lt;/h3&gt;&lt;p&gt;通过上一篇我们知道 PoW 挖矿的基本逻辑和步骤，我们先寻求一个 nonce小于目标值，这一步用公式可表示为：&lt;/p&gt;
&lt;p&gt;Hash (block_header) &amp;lt; Target&lt;/p&gt;
&lt;p&gt;从公式中我们可以看到，PoW 下所有矿工的目标值是一样的，只要计算结果哈希小于目标值即可，简化来看就是前导 0 的个数。&lt;/p&gt;
&lt;p&gt;而在 PoS 系统中，这个公式变更为：&lt;/p&gt;
&lt;p&gt;Hash (block_header) &amp;lt; Target * CoinAge&lt;/p&gt;
&lt;p&gt;我们可以看出多引入了一个变量叫做 CoinAge，也就是币龄，这里就有意思了。&lt;/p&gt;
&lt;p&gt;这个变量为会造成每个矿工看到的目标值不一样，如果你的币龄越大，也就意味着你的获得答案越容易。这里的 Target 与 PoW 一致，与全网难度成反比，用来控制出块速度的。&lt;/p&gt;
&lt;h3 id=&#34;254-pos-的相关问题&#34;&gt;2.5.4 PoS 的相关问题
&lt;/h3&gt;&lt;p&gt;通过上述的介绍我们知道：PoS 似乎完美地解决了 PoW 挖矿资源浪费的问题，甚至还顺带解决了 51% 攻击的问题，这里可以顺便讲一下 51% 攻击是什么，它是指 PoW 矿工如果积累了超过 51% 的算力，则可以一定程度篡改账本。&lt;/p&gt;
&lt;p&gt;这里顺便科普一下，什么是 51% 攻击呢，我们发现，矿工挖矿的成本不再是物理设备和电费，而是虚拟代币，它的边际成本几乎为零，本质上 PoS 让挖矿者和使用者合二为一了。&lt;/p&gt;
&lt;p&gt;这也意味着如果挖矿者发起 51% 攻击，就需要拥有全网 51% 的币或币龄，这几乎不可能办到，即使你成功地实施了 51% 攻击，那么也意味着作为全网最大的持币大户的你，损失也会最大。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;PoS问题&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;币发行的问题&lt;/p&gt;
&lt;p&gt;如何分散出去，解决方案&amp;mdash;-&amp;gt;分阶段挖矿，即第一阶段是 PoW 挖矿，到第二阶段才是 PoS 挖矿&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于币龄是与时间挂钩的，这也意味着用户可以无限囤积一定的币，等过了很久再一次性挖矿发起攻击。所以解决方案是：PoS 机制需要引入一个时间上限来控制时间因素的自然增长。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;虽然引入了时间上下限，用户还是倾向于囤积代币，这会造成币流通的不充分；基于此，所以瑞迪币引入了币龄按时间衰减，构造了权益速度证明，鼓励用户流动代币，而不是倾向于囤积代币。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;离线攻击&lt;/p&gt;
&lt;p&gt;即使引入了时间上下限，时间仍然是自然流动的，也就是可以不需要求挖矿节点长时间在线。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当然这些问题都不是致命问题，还记得我们一开始提到了 PoS 经历了三个版本，而第二个版本 PoS 2.0 使用的不是币龄，而直接是币的数量。&lt;/p&gt;
&lt;p&gt;这会造成完全不同的结果，上述第二、三、四问题都不存在了，似乎看起来直接使用币的数量会更好一些，但却出现了整个 PoS 机制的致命问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这个问题叫做 Nothing at Stake，翻译过来叫做无成本利益问题。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;26-dpos共识机制&#34;&gt;2.6 DPoS共识机制
&lt;/h2&gt;&lt;p&gt;DPoS 全称是 Delegated Proof of Stake，中文翻译过来是代理权益证明。&lt;/p&gt;
&lt;h3 id=&#34;261-bm-与dpos&#34;&gt;2.6.1 BM 与DPoS
&lt;/h3&gt;&lt;p&gt;BM 的本名是 Daniel Larimer，由于他的 GitHub 昵称是 ByteMaster，所以才被称作 BM。BM 是比特股、Steemit、EOS 项目的创始人，截止发稿时，这三个产品的市值均在区块链项目的 Top33 以内。&lt;/p&gt;
&lt;p&gt;BM 开发第一个项目——比特股，同时创造出 DPoS，把自己的高性能共识算法想法形成了实践。&lt;/p&gt;
&lt;p&gt;在这里，我们可以看出 DPoS 与其他共识机制的第一个区别，就是交易确认时间短。&lt;/p&gt;
&lt;h3 id=&#34;262-dpos&#34;&gt;2.6.2 DPoS
&lt;/h3&gt;&lt;p&gt;DPoS 共识算法就是将 PoS 共识算法中的记账者转换为指定节点数组成的小圈子，而不是所有人都可以参与记账，这个圈子可能是 21 个节点，也有可能是 101 个节点，这一点取决于设计，只有这个圈子中的节点才能获得记账权。这将极大地提高系统的吞吐量，因为更少的节点也就意味着网络和节点的可控。&lt;/p&gt;
&lt;h4 id=&#34;2621--dpos-共识的目标&#34;&gt;2.6.2.1  DPoS 共识的目标
&lt;/h4&gt;&lt;p&gt;DPoS 算法是 BM 根据当时 PoW、PoS 的不足而改进的共识算法，它的目的就是为了&lt;strong&gt;提高性能&lt;/strong&gt;，也就是交易确认时间短。&lt;/p&gt;
&lt;p&gt;要注意的一点是在 DPoS 中，记账节点不叫做矿工，而是改称为见证人，Witness。&lt;/p&gt;
&lt;p&gt;所以这个公式变成了下面的样子。&lt;/p&gt;
&lt;p&gt;TPS = (block_size network_bandwidth witness_performance) /
(block_time * witness_count)&lt;/p&gt;
&lt;p&gt;&lt;em&gt;我们可以看到，要提高 TPS，可以提升分子项，降低分母项，也就是增大区块大小 block_size、提升记账节点网络带宽 network_bandwidth、提升记账节点处理性能 witness_performance，减小区块时间 block_time、减小记账节点数量 witness_count。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;我们事先规定好记账节点的数量，接着让全网所有节点可以投票决定哪些节点可以成为记账节点，这样就限制并减小了分母项 witness_count，这个过程我们也称作投票选举。&lt;/p&gt;
&lt;p&gt;BM 还为 DPoS 算法确立两个原则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;投票选举过程一定要保证最大权益所有者最终能控制全网，因为一旦出了问题，他们的损失最大；&lt;/li&gt;
&lt;li&gt;与 PoW、PoS 一样，所有节点仅承认“最长”链。
这两个原则确立了 DPoS 共识的基本特性，第一条放大了 PoS 共识使用者就是记账者的优点，第二点则规定了分叉时系统应该表现的行为。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;2622--dpos-共识算法分析&#34;&gt;2.6.2.2  DPoS 共识算法分析
&lt;/h4&gt;&lt;p&gt;区块链的正常运转依赖于见证人 (Delegates)，见证人是由全网节点投票产生的，见证人也是记账节点的实际控制人，见证人在完成打包交易的同时可以领取区块奖励和交易的手续费，并且可以执行社区投票的提案，所以 DPoS 共识算法不仅仅是算法，而是一个包含了协作治理关系的共识机制。&lt;/p&gt;
&lt;p&gt;在实际应用中，比特股中见证人是 101 人，EOS 里是 21 人。比特股中见证人们赚取手续费，EOS 里见证人们分享 EOS 的通胀收益。他们都是通过公开选举选出来的，选票就是大家手里的比特股或 EOS。&lt;/p&gt;
&lt;h4 id=&#34;2623-有关-dpos-的一个争论中心化问题&#34;&gt;2.6.2.3 有关 DPoS 的一个争论：中心化问题。
&lt;/h4&gt;&lt;p&gt;由于见证人团体数量较少，逐步产生了中心化的问题。
在 PoW 中，矿工、开发者、用户三权分立。而 DPoS 似乎将这三权合并到了见证人和理事会手中。在 EOS 中，BM 还制定了区块链宪法，要求所有记账节点必须遵守，所以也有人抨击这是具备了 BM 特色的去中心化。&lt;/p&gt;
&lt;p&gt;从某种角度来看，DPoS 是社区治理加上共识算法，不再是单纯的技术共识，这是与 PoW、PoS 算法最大的不同。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>区块链学习--1区块链基础</title>
        <link>https://zhenyu0324.github.io/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0--1%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/</link>
        <pubDate>Thu, 04 Feb 2021 15:24:50 +0800</pubDate>
        
        <guid>https://zhenyu0324.github.io/p/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0--1%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80/</guid>
        <description>&lt;h1 id=&#34;1-区块链基础&#34;&gt;1. 区块链基础
&lt;/h1&gt;&lt;h2 id=&#34;11区块链是什么&#34;&gt;1.1区块链是什么
&lt;/h2&gt;&lt;h3 id=&#34;111区块链与区块链行业&#34;&gt;1.1.1区块链与区块链行业
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;区块链是一个崭新的行业，与社交、电影、游戏一样，具有自己独特的内涵和发展过程&lt;/li&gt;
&lt;li&gt;这个行业是通过比特币形成的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以比特币为基础，衍生出了许多其他如以太坊、比特股、EOS 等币共同形成了区块链行业。&lt;/p&gt;
&lt;h3 id=&#34;112区块链的魅力&#34;&gt;1.1.2区块链的魅力
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;具有理想主义情怀的极客所提出的“去中心化”&amp;mdash;&amp;ndash;“链圈”&lt;/li&gt;
&lt;li&gt;以赚钱为主要目标的投资者和生意人&amp;mdash;-“币圈”&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;前者为后者提供了极佳的赚钱土壤，后者为前者注入了赖以生存的资金。听起来好像“沆瀣一气”，其实并没有，这也是区块链行业通常所说的链圈和币圈。&lt;/p&gt;
&lt;h3 id=&#34;113区块链究竟是什么&#34;&gt;1.1.3区块链究竟是什么
&lt;/h3&gt;&lt;p&gt;简单来说，区块链首先是一个分布式网络。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;总结一下区块链是什么：&lt;/p&gt;
&lt;p&gt;区块链是一个分布式网络；
区块链可以帮助多个节点达成共识去记录和 Token 相关的事情；
区块链可以帮助所有人无门槛地构建属于自己的小经济系统。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;114-推荐资料&#34;&gt;1.1.4 推荐资料
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;基础知识《精通比特币》&lt;/li&gt;
&lt;li&gt;行业知识《区块链：从数字货币到信用社会》&lt;/li&gt;
&lt;li&gt;技术进阶《区块链原理设计与应用》&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;12-区块链怎么运行&#34;&gt;1.2 区块链怎么运行
&lt;/h2&gt;&lt;h3 id=&#34;121-中心化记账的问题&#34;&gt;1.2.1 中心化记账的问题
&lt;/h3&gt;&lt;p&gt;银行是中心化记账模式
问题：如果中心化账本存在错误，怎么办？&lt;/p&gt;
&lt;h3 id=&#34;122记账介绍&#34;&gt;1.2.2记账介绍
&lt;/h3&gt;&lt;p&gt;每家每户都记账，账簿上不再记载每户村民的余额，而只记载每一笔 Transaction，即记载每一笔交易的付款人、收款人和付款金额。
需要解决：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一致性问题&lt;/li&gt;
&lt;li&gt;安全(加解密)
&lt;strong&gt;流程&lt;/strong&gt;
记账&amp;mdash;-&amp;gt;创建创世区块&amp;mdash;-&amp;gt;交易&amp;mdash;-&amp;gt;打包 Transaction 挖矿）&amp;mdash;-&amp;gt;广播交易&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;13共识机制&#34;&gt;1.3共识机制
&lt;/h2&gt;&lt;p&gt;在上述记账流程中，打包环节分为 &amp;ldquo;打包 Transaction&amp;rdquo;、&amp;ldquo;广播交易&amp;rdquo; 都需要运用到共识机制。&lt;/p&gt;
&lt;p&gt;共识机制是区块链是核心的组成要素之一，它决定了区块链的业务吞吐量、交易速度、不可篡改性、准入门槛等等，是最为关键的技术要素之一。&lt;/p&gt;
&lt;p&gt;共识机制主要解决了两个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;谁有权利&lt;/li&gt;
&lt;li&gt;作弊问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;131拜占庭将军问题&#34;&gt;1.3.1拜占庭将军问题
&lt;/h3&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zh.wikipedia.org/zh/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98#:~:text=%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98%5B%E7%BC%96%E8%BE%91%5D&amp;amp;text=%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98%EF%BC%88Byzantine%20Generals,%E5%90%8C%E4%B8%80%E5%A5%97%E5%8D%8F%E4%BD%9C%E7%AD%96%E7%95%A5%E8%A1%8C%E5%8A%A8%E3%80%82&amp;amp;text=%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98%E8%A2%AB%E8%AE%A4%E4%B8%BA,%E7%9A%84%E9%97%AE%E9%A2%98%E7%B1%BB%E5%9E%8B%E4%B9%8B%E4%B8%80%E3%80%82&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;维基百科:拜占庭将军问题&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://baike.baidu.com/item/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B%E9%97%AE%E9%A2%98&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;百度百科:拜占庭将军问题&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.zhihu.com/question/23167269&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;知乎:如何理解拜占庭将军问题？&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;拜占庭将军问题（Byzantine failures），是由莱斯利·兰伯特提出的点对点通信中的基本问题。含义是在存在消息丢失的不可靠信道上试图通过消息传递的方式达到一致性是不可能的  。&lt;/li&gt;
&lt;li&gt;拜占庭将军问题是一个协议问题，拜占庭帝国军队的将军们必须全体一致的决定是否攻击某一支敌军。问题是这些将军在地理上是分隔开来的，并且将军中存在叛徒。叛徒可以任意行动以达到以下目标：欺骗某些将军采取进攻行动；促成一个不是所有将军都同意的决定，如当将军们不希望进攻时促成进攻行动；或者迷惑某些将军，使他们无法做出决定。如果叛徒达到了这些目的之一，则任何攻击行动的结果都是注定要失败的，只有完全达成一致的努力才能获得胜利  。&lt;/li&gt;
&lt;li&gt;拜占庭假设是对现实世界的模型化，由于硬件错误、网络拥塞或断开以及遭到恶意攻击，计算机和网络可能出现不可预料的行为 。&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
&lt;h3 id=&#34;132-最经典的入门型共识机制pow-工作量证明&#34;&gt;1.3.2 最经典的入门型共识机制：PoW 工作量证明
&lt;/h3&gt;&lt;p&gt;PoW （Proof of Work）工作量证明可以解决上述的两个问题。
在 PoW 这种机制中，计算资源（又称算力）是决定记账权的唯一因素。与之对应的，便是计算难度。计算难度又称作挖矿难度，计算难度是区块链为了控制产生答案的速度，比如平均 10 分钟就有一个答案产生，平均 2 分钟一个答案产生。&lt;/p&gt;
&lt;h3 id=&#34;133-pow-到底是如何避免作弊者的呢&#34;&gt;1.3.3 PoW 到底是如何避免作弊者的呢
&lt;/h3&gt;&lt;p&gt;计算资源（算力）&lt;/p&gt;
&lt;p&gt;PoW 中一个有趣的设计是激励机制，在 PoW 共识机制下，我们假设所有参与者都是理性的，理性的意思就是单纯逐利，不考虑家庭、爱好等其他因素。有了理性的前提，PoW 共识机制会给每个诚实的记账者予以奖励，这个设计可以抗击作弊收益的问题。&lt;/p&gt;
&lt;p&gt;怎么进行抗击的呢？整个过程是这样的，理性的人如果作弊、篡改账本肯定需要投入成本，也就是计算资源，收益是篡改账本获得的收益减去投入成本，这个收益往往小于诚实计算所获得的收益。所以，作弊者在作弊过程中投入的计算资源过大，反而得不偿失。&lt;/p&gt;
&lt;h3 id=&#34;134-pow-工作量证明的补充解决双花攻击&#34;&gt;1.3.4 PoW 工作量证明的补充：解决双花攻击
&lt;/h3&gt;&lt;p&gt;上面给出了一个结论，我们说作弊的收益往往小于诚实计算的收益。这一点其实对应到区块链领域有个著名的问题：双花攻击（double-spending） 。
双花攻击是指一个代币被花费了两次，这在任意的区块链系统中是不被允许的。如果避免了双花问题，基本就能避免上述作弊中收益过大的问题，因为攻击者首先要窃取到你的私钥，同时又能控制了你的计算资源（算力）。&lt;/p&gt;
&lt;p&gt;所有记账节点都会遵循以下两条规则：&lt;/p&gt;
&lt;p&gt;规则一：一个代币如果已经被花费，那么会被标记成已花费，如果再次接收到这个代币被花费的请求，那么记账节点会拒绝打包这笔交易；&lt;/p&gt;
&lt;p&gt;规则二：如果同时接收到两个信封，这两个信封中装的两笔交易出现了一个代币被花费了两次的情况，这种情况也就是我们所说的分叉（Fork），那么选择挖矿难度比较大的那个信封。&lt;/p&gt;
&lt;p&gt;规则一避免了未确认的交易出现双花，规则二基本避免已经确认的交易中（信封中）的双花问题。
假设作弊者的计算资源（算力）占整个系统的 30%，那么连续两次获得记账权的概率是 9%，看起来作弊的可能性还是挺高的，如果是连续 6 次获得记账权呢？概率直降到万分之七。&lt;/p&gt;
&lt;p&gt;在比特币中，这个 6 也就是 6 次确认，表示连续 6 个块过去了，如果我的交易没有被双花的话，那么它被篡改的可能性将越来越小，最后变得几乎不可能被篡改。这也是区块链不可被篡改说法的由来。
试想，如果任何作弊者花了大量的成本获取了系统 30% 的计算资源（算力），最后只有万分之七的概率获得篡改的可能性，比起作弊，还不如诚实记账的收益高。&lt;/p&gt;
&lt;h2 id=&#34;14区块链的应用类型&#34;&gt;1.4区块链的应用类型
&lt;/h2&gt;&lt;h3 id=&#34;141-数字货币应用方向&#34;&gt;1.4.1 数字货币应用方向
&lt;/h3&gt;&lt;p&gt;数字货币是区块链的第一大应用类型，市场上目前可统计的数字货币币种有 1500 种以上，2017 年其迅速增长的市值让人措手不及。
那么说，到底如何理解数字货币这个概念呢？其实你可以简单理解为一种无主权、社区自治的货币形式。&lt;/p&gt;
&lt;p&gt;数字货币特点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;总量透明公开&lt;/p&gt;
&lt;p&gt;数字货币的总量也分为两种，一种是总量设上限的，另外一种是不设上限的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数字货币缓慢释放&lt;/p&gt;
&lt;p&gt;通常在矿工的那部分是需要靠“挖”才能出来的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;代码执行规则&lt;/p&gt;
&lt;p&gt;由于我们在白皮书中规定好了总量和数字货币释放的机制，白皮书的内容会成为整个社区的基础共识，所以在项目的主网上线之后，数字货币的释放不再是人为控制，而是在代码层面体现，代码将负责控制数字货币的释放，这里去除了人为操作的因素。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;基本上，所有公有区块链项目都会具备以上特性，可见数字货币和区块链的关系十分紧密。另外，在区块链领域，一个项目的开始运营，就伴随着一个新的数字货币的产生，这个数字货币会成为这个项目的基础代币，也有可能会派生出其他货币。&lt;/p&gt;&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;142-数字资产方向&#34;&gt;1.4.2 数字资产方向
&lt;/h3&gt;&lt;p&gt;怎么理解呢？如果区块链可以做数字货币，那么同理，它也可以应用到其他任何资产，尤其是虚拟资产。&lt;/p&gt;
&lt;p&gt;虚拟资产一般包括有金融资产、游戏代币、数字版权、域名、用户流量等。由于虚拟资产不需要与实体资产进行挂钩，所以在对应到区块链上更为方便。它具体的应用形式在供应链金融、票据市场都有所体现。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;区块链圈子内有个非常有名的加拿大白胡子大叔，他基本上是逢会必现。他要做的应用简而言之叫做“良心区块链”，不是指区块链项目的良心，是指他希望用区块链技术让所有人可以进行自我管理，自我管理的方式是对“良心”进行评价和奖励。&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&#34;143-比较成熟的应用类型&#34;&gt;1.4.3 比较成熟的应用类型
&lt;/h3&gt;&lt;p&gt;那么区块链目前有哪些比较成熟的应用呢？其实我们有时候想得太远了，反而忽略了脚下。首先来说，任何的区块链创始项目如果要活下去，就要先解决钱的问题，也就是融资问题。&lt;/p&gt;
&lt;p&gt;我们在前面说到，任何的区块链项目基本都会产生一个基础代币，那么什么样的融资模式能让投资者和项目方都满意呢？&lt;/p&gt;
&lt;p&gt;其实，这个融资模式本身就是一个很成熟的应用。——答案是去年被七部委明令禁止的 ICO(Initial Coin Offering)。&lt;/p&gt;
&lt;p&gt;ICO 的中文名是首次代币发行，又称为区块链众筹，这是一种新型的融资模式，投资者可以用手中的比特币或其他代币投到一些区块链创始项目。&lt;/p&gt;
&lt;h2 id=&#34;15-如何理解数字货币它与区块链又是什么样的关系&#34;&gt;1.5 如何理解数字货币？它与区块链又是什么样的关系？
&lt;/h2&gt;&lt;h3 id=&#34;151-数字货币的概念&#34;&gt;1.5.1 数字货币的概念
&lt;/h3&gt;&lt;p&gt;数字货币通常是国内的叫法，在国外，它一般称作“加密货币”。数字货币听起来比加密货币更抽象一点，“数字”旨在表现它不同于传统货币的行为，即它可以通过“数字”表现更多自定义的行为。&lt;/p&gt;
&lt;p&gt;那么，如何用一句话来解释什么是“数字货币”（加密货币）呢？我们可以这样形容：数字货币通常是基于区块链技术、在全球范围内公开发行的、并且没有任何国家政府背书的虚拟货币，这种虚拟货币具有“去信任”、“点对点”、“公开记账”、“不可篡改”等特征。&lt;/p&gt;
&lt;p&gt;既然聊到了虚拟货币，我们正好可以把电子货币、虚拟货币、数字货币（加密货币）的概念捋一捋。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;电子货币&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;近年来，现金使用的频度降低，很多人首选使用电子支付。电子货币和数字货币一样都是无形的，但是电子货币其实就是将法币电子化，例如第三方支付平台，银行卡电子现金，银行大小额支付系统等等。它只是以电子的方式记录了原来法币的账目，从本质上来说，它们仍然需要在多个中心化系统中进行稽核、对账，“电子”本身并没有成为金融的一部分。&lt;/p&gt;
&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;虚拟货币&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 2017 年区块链投机狂热的时候，“虚拟货币”这个词基本是用来指区块链项目的基础代币，这样的叫法大多源自于圈外投机者。其实不然，虚拟货币所指代的概念远比电子货币以及数字货币都要更加广泛。&lt;/p&gt;
&lt;p&gt;虚拟货币通常是由非金融机构发行的非实体货币，大致分为三类。&lt;/p&gt;
&lt;p&gt;第一类比如游戏代币，通常不与实体经济发生联系。例如在《王者荣耀》这款游戏中，如果你想要得到新的道具，就必须有足够的游戏代币（钻石和点券），这种虚拟货币还有个特征就是封闭性，即只能在这款游戏中使用。
第二类是积分类，它可以与实体经济发生联系，比如常旅客积分，超市礼品卡，这种虚拟货币也有个特征叫做单向性，即只能流入，而不能流出。
第三类自然就是我们主要讲的数字货币（加密货币）了，比特币便是其中典型。&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;数字货币&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;数字货币一般是指公有区块链平台底下的基础代币，该代币被记录在由密码学保证的一套公开账本上，与传统货币不同的是，由于去中心化以及可编程等特性，此种货币具有可自定义行为的属性。&lt;/p&gt;
&lt;p&gt;在比特币中，我们可以定义多重签名交易来实现真正意义上的“由多人共同掌管的机构型账户”。&lt;/p&gt;
&lt;h3 id=&#34;152-数字货币的发行过程&#34;&gt;1.5.2 数字货币的发行过程
&lt;/h3&gt;&lt;p&gt;数字货币在 2016 年开始加速，2017 年借助 ICO 呈井喷式发展，数字货币市场形成了一个大泡沫，这与 2000 年初的互联网泡沫十分相似，但是泡沫并不可怕，它只是一个热门新生事物的必然过程。&lt;/p&gt;
&lt;p&gt;我们需要在这个泡沫中找到规律，那么首先就要了解数字货币的发行过程。我们可以以比特币为例子来聊聊它的发行过程。&lt;/p&gt;
&lt;p&gt;比特币的发行过程是通过挖矿维持的，是依靠矿工挖矿产生比特币。相当于矿工自己就是一个小型的印钞机。&lt;/p&gt;
&lt;p&gt;矿工每挖出一个区块，也就是在第二篇文章中提到的“打包一个信封”，会产生一个 Coinbase 交易，这个 Coinbase 交易相当于凭空产生了币，矿工可以从 Coinbase 获得比特币，作为维护系统的奖励。&lt;/p&gt;
&lt;p&gt;Coinbase 的产出是每 4 年衰减一半的，第一个 4 年是挖出每个块 50 个比特币，第二个 4 年的周期就是挖出每块产出 25 个，目前比特币处于第三个 4 年，Coinbase 产出 12.5 个比特币的阶段。&lt;/p&gt;
&lt;h2 id=&#34;16-理解区块链之前先上手体验一把数字货币&#34;&gt;1.6 理解区块链之前，先上手体验一把数字货币
&lt;/h2&gt;&lt;h3 id=&#34;161-什么是数字货币钱包&#34;&gt;1.6.1 什么是数字货币钱包
&lt;/h3&gt;&lt;p&gt;数字货币钱包是最贴近用户的区块链程序，数字货币钱包会可以帮你管理数字货币私钥，发送交易，可以显示你的交易历史记录。从用户功能的角度，数字货币钱包比较接近我们日常使用的钱包，它帮助你管理纸币、硬币、信用卡借记卡。&lt;/p&gt;
&lt;p&gt;数字货币钱包作为数字货币的载体，从技术角度来看，数字货币钱包分为三种类型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;全节点钱包&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;全节点钱包是指官方发行的一种数字货币钱包版本，这个版本包含了完整的功能需求，挖矿、发送交易、查询交易记录、管理私钥。
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SPV 轻钱包（Simplified Payment Verification）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;轻钱包为了用户体验，牺牲了全节点的部分功能，属于全节点钱包的简化版，如挖矿功能、查询交易功能就没有。
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;中心化资产托管钱包&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;这种钱包其实是第三方服务商帮助你打理你的数字货币，找一个中介托管你的数字货币，比较典型的有 blockchain.info。
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;附录&#34;&gt;附录
&lt;/h3&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;OK 国际站：【www.okex.com】
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;火币网国际站：【www.huobi.pro】
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;币安：【www.binance.com】
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;中比特国际站：【www.zb.com】
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;中比特海外版：【www.exx.com】
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;比特儿海外版:【www.gate.io】
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;比特时代海外版:【www.aex.com】
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;元宝网海外版:【www.bcex.ca】
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;聚币海外版:【www.coinegg.com】
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;云币海外版:【www.big.one】
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;币久网海外版:【www.cex.com】
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;币赢网:【www.coinw.com】
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;kex:【www.kex.com】
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;国外交易平台
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;Bitfinex:【www.bitfinex.com】
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;B 网:【www.bittrex.com】
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;R 网:【www.rightbtc.com】
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;P 网:【www.poloniex.com】
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;L 网:【liqui.io】
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;H 网：【hashtoken.co】
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;CEO：【www.bite.ceo】
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;BTBT：【www.btbt.top】
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;HitBTC:【hitbtc.com】
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;bithumb:【www.bithumb.com】
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;coincheck:【coincheck.com/cn/】
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;bit-z:【www.bit-z.com】
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;去中心化交易平台
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;以德：【etherdelta.com】
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;比特股：【bitshares.org/wallet/#】
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;场外交易平台
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;local：【localbitcoins.com/zh-cn】
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;可盈可乐：【www.coincola.com/】
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;比特币世界【www.bitcoinworld.com/】
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;元宝场外交易【www.otc789.com/】
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;电脑看行情网站
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;非小号：【www.feixiaohao.com】
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;手机看行情软件：mytoken，aicoin
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;比特币、区块链新闻网站
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;金色财经：【www.jinse.com】
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;巴比特：【www.8btc.com】
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;bitcoin86：【www.bitcoin86.com】
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;17-区块链的常见误区&#34;&gt;1.7 区块链的常见误区
&lt;/h2&gt;&lt;h3 id=&#34;1-71数字货币没有背书我为什么要用呢&#34;&gt;1. 7.1数字货币没有背书，我为什么要用呢？
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;我们首先要跳出自己的视野局限&lt;/li&gt;
&lt;li&gt;其次是信用货币是与国家利益息息相关的。比如国家之间的贸易战，通常会在本国货币政策上所有体现。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果硬要说一说数字货币的背书，我认为，社区本身就是一种背书。&lt;/p&gt;
&lt;p&gt;社区由用户、开发者、矿工三者组成的。&lt;/p&gt;
&lt;p&gt;他们之间的利益相互绑定，用户使用数字货币决定了市场价格，开发者为数字货币开发了更多的功能来提升生产效率，矿工是系统的维护者，三者包含了数量巨大的个体，每个个体都相当于为数字货币作了背书。&lt;/p&gt;
&lt;h3 id=&#34;172-数字货币是不是投机炒币&#34;&gt;1.7.2 数字货币是不是投机炒币？
&lt;/h3&gt;&lt;p&gt;另外还有一种误解来自于行业之外的人，认为数字货币就是投机、就是炒币。其实不是这样的，数字货币出现的初衷并不是为了投机炒币，而是希望构造一个点对点的去信任系统，只是在发展过程中被投机主义者大肆利用了。&lt;/p&gt;
&lt;h3 id=&#34;173--区块链是不是万能的&#34;&gt;1.7.3  区块链是不是万能的？
&lt;/h3&gt;&lt;p&gt;很多人接触了区块链以后，觉得看什么都想拿区块链来做。但是，你忽略了一点，区块链本身也属于分布式系统，分布式系统有哪些局限、哪些约束，区块链一样也有。&lt;/p&gt;
&lt;p&gt;需要指出的是，区块链领域有个说法叫做“不可能三角”，意思是说区块链的“去中心化”“安全”“环保”三个要素不可能同时全部满足。&lt;/p&gt;
&lt;p&gt;这个说法我没有仔细论证，个人感觉这三个指标并不好量化，所以未必成立。本着学术严谨的原则，我不作过多的评价。&lt;/p&gt;
&lt;p&gt;反而在分布式领域，有个著名的 CAP 定理。&lt;/p&gt;
&lt;p&gt;在 CAP 中，Consistency 是一致性，表示同样数据在分布式系统中所有地方都是被复制成相同；Availability 是可用性，表示所有在分布式系统活跃的节点都能够处理操作且能响应查询；Partition tolerance 是分区容忍性，表示不同节点之间数据同步有意外情况产生时，能够容错。&lt;/p&gt;
&lt;p&gt;一般情况下，CAP 理论认为你不能同时拥有上述三种，只能同时选择两种。所以，当我们应用到区块链上时，可以明显地发现区块链其实是一个 AP 系统，尤其在 A 这个指标上，也就是可用性做得非常好，所以相应地，C 就会降低，反映到具体系统中的交易吞吐量上，自然会也会降低。&lt;/p&gt;
&lt;p&gt;当我们在分区容忍性和一致性中做取舍的时候，如果强调“不可篡改”“去中心化”这两个特性，就会明显感觉到区块链跟不上大吞吐量的业务。&lt;/p&gt;
&lt;p&gt;所以理解了以上内容，我们在做技术选型时，如果去中心化不是强需求，还是建议你使用中心化的解决方案。&lt;/p&gt;
&lt;h3 id=&#34;174-去中心化是不是区块链唯一的评价标准&#34;&gt;1.7.4 去中心化是不是区块链唯一的评价标准？
&lt;/h3&gt;&lt;p&gt;既然谈到了中心化，我们就来看看“你是否应该去中心化”的话题，自区块链发展至今，“中心化”和“去中心化”的争论就一直存在。&lt;/p&gt;
&lt;p&gt;支持去中心化的观点认为：区块链的初衷就是去中心化，所以也衍生出一条准则：“凡是没有做好去中心化指标的系统都不是区块链”。&lt;/p&gt;
&lt;p&gt;持有这样观点的人通常都跟我一样是技术出身，或多或少都有些理想主义的极客情怀，这一点本来是无可厚非的，但市场是逐利的，情怀其实常常并没有办法变现。&lt;/p&gt;
&lt;p&gt;所以，这导致的最直接结果就是：秉持这种去中心化原则会让区块链的落地过程异常缓慢。&lt;/p&gt;
&lt;p&gt;持有“去中心化是唯一准则”这样的观点，往往也会误导刚刚入门的业务和产品相关的人员，误以为去中心化是区块链产品的一条评价标准。&lt;/p&gt;
&lt;p&gt;其实并不是这样，去中心化只是一个公有区块链应当具备的基本特性，但是我们衍生到区块链应用层面的时候，其实去中心化往往并不能契合到一个公司的业务上，所以我在这里提倡：当我们在思考区块链的解决方案时，还是应当以需求为第一导向。&lt;/p&gt;
&lt;p&gt;事实上，我们在讨论去中心化的时候，更多是夹杂了对强势的不满，这其实可以转化成“对服务者进行监督”的思路，一味地强调去中心化可能会陷入舍本逐末的尴尬境地，我们一定要看需求是什么，再去选择要不要。&lt;/p&gt;
&lt;p&gt;换句话说，任何情况下，人与人之间必然存在信息不对称和认知不对称的问题，任何应用都会存在信息提供者和信息消费者这两种角色。&lt;/p&gt;
&lt;p&gt;这是由人类社会结构决定的，妄图消除这两种角色之间的差异是非常难的。所以应用的“去中心化”要问运营者和消费者，而不是空喊口号。&lt;/p&gt;
&lt;p&gt;有个常提及的词叫做“赋能”，被赋于能力的角色始终处于被动地位的，我们可以把区块链看做新型的赋能工具，至于是不是去中心化，设计过程中要看具体的应用场景，实施过程最终取决于消费者。&lt;/p&gt;
&lt;h2 id=&#34;18-最主流区块链项目有哪些&#34;&gt;1.8 最主流区块链项目有哪些？
&lt;/h2&gt;&lt;h3 id=&#34;181-比特币&#34;&gt;1.8.1 比特币
&lt;/h3&gt;&lt;p&gt;比特币的发布时间为 2009 年 1 月 9 号，预计它的挖矿可以一直持续到 2140 年，发行总量收敛到 2100 万。比特币的出块时间是 10 分钟，出块时间是指全网平均产生一个区块的时间间隔。&lt;/p&gt;
&lt;p&gt;比特币是所有数字资产的始祖，这带来的效果就是：比特币的公众认可度非常高，纵然面临着矿池中心化 （关于矿池中心化的问题会在后面的“深入区块链技术”部分内讲解）的问题，但是公众依然非常信任比特币这种资产。&lt;/p&gt;
&lt;h3 id=&#34;182-以太坊&#34;&gt;1.8.2 以太坊
&lt;/h3&gt;&lt;p&gt;以太坊是一个区块链应用平台，它的极大创新在于它提供了智能合约这种可以自定义业务逻辑的工具，智能合约是一种可编程的合约，合约是由用户编写并且部署到区块链上的。&lt;/p&gt;
&lt;p&gt;以太坊的优势是为全世界的开发者们提供了一种开发工具，这种工具让所有人都能释放出巨大的创造力，所以基本上可以看成：只要是有一定技术基础的开发者，通过智能合约可以随时为以太坊贡献内容。&lt;/p&gt;
&lt;p&gt;这形成了一种良性循环，开发者使用智能合约的时候，发现的问题提交给以太坊开发者社区，社区改进智能合约的缺陷，新的开发者基于智能合约开发多样性的工具包，这种核心开发者与社区互动的良性循环是以太坊生态最重要的一部分。&lt;/p&gt;
&lt;p&gt;以太坊的口号是“世界计算机”，从这句口号里，可见它野心的大小。&lt;/p&gt;
&lt;p&gt;以太坊在 2014 年开始众筹，2015 年 3 月份正式运行，它采取的共识机制是 PoW，但根据核心团队公布的方案，后期会逐渐迁移到 PoS 共识算法。以太坊的总发行量是：6000 万 +1872 万 / 年，目前的区块时间是 12 秒。&lt;/p&gt;
&lt;p&gt;同时我们从以太坊社区可以看到，以太坊绝大部分开发流程和智能合约都已经形成行业标准，比如常见的 ERC20 代币标准，ERC725 身份标准。&lt;/p&gt;
&lt;p&gt;而 ERC20 代币标准，则为智能合约指明了主要的业务方向：数字资产，有的叫智能资产，它们的含义差不多。以太坊 2017 价格大幅上涨，最直接的原因就是：ERC20 代币成为事实意义上的区块链标准资产。&lt;/p&gt;
&lt;h3 id=&#34;183-瑞波币&#34;&gt;1.8.3 瑞波币
&lt;/h3&gt;&lt;p&gt;瑞波币（Ripple）是一个比较另类的区块链项目，因为从本质上来说，它更像是一种支付结算协议，瑞波币不需要挖矿，它是通过一种叫“Open Coin”的算法，提供瑞波协议共识来达到记账的目的。&lt;/p&gt;
&lt;p&gt;瑞波币旨在为全球跨境机构提供了高效率的支付过程，提供较好的全球支付体验。因为涉及了机构之间的资产转移，瑞波币被设计成需要准入许可才能进入瑞波的支付网络，这一点有些像我们所说的联盟链。&lt;/p&gt;
&lt;p&gt;瑞波团队掌握了一半以上的瑞波币，所以瑞波币面临的币价被操纵的问题很严重。如果你是一个技术极客，那么你可以略过该项目。如果你想创建一个有关支付结算的区块链项目，那么一定要研究瑞波币。&lt;/p&gt;
&lt;h3 id=&#34;184-莱特币&#34;&gt;1.8.4 莱特币
&lt;/h3&gt;&lt;p&gt;如果我们仔细观察，会发现比特币的 Logo 颜色为金色，而莱特币的 Logo 的颜色为银色。一金一银，相信你应该明白莱特币的定位了。&lt;/p&gt;
&lt;p&gt;莱特币在技术上仅仅把比特币的挖矿算法修改成了 Scrypt 算法，Scrypt 算法是一个可参数化、可配置的挖矿算法，不过它依然没有防住专业矿机的出现。它的其他核心代码几乎与比特币保持一致。&lt;/p&gt;
&lt;p&gt;莱特币的崛起得益于良好的市场运作，从提供的功能来看，莱特币与比特币没有区别。那么说，为什么还要有莱特币呢？&lt;/p&gt;
&lt;p&gt;是这样的，比特币扩容之争的核心焦点在是否使用“隔离见证”的方法，我们其实知道，“隔离见证”虽然在比特币社区提出，但是第一个应用的地方是莱特币，相信你能看出这里的逻辑，即：莱特币作为比特币的先行者，它会替代比特币做一些具有实验性质的试运行。&lt;/p&gt;
&lt;h3 id=&#34;185-tether&#34;&gt;1.8.5 Tether
&lt;/h3&gt;&lt;p&gt;Tether 也是一个特殊的区块链项目，它为所有区块链资产提供了法币（主要是美元）兑换网关。&lt;/p&gt;
&lt;p&gt;Tether 又称 USDT，言外之意就是和美元一对一锚定，用户存入多少美元，就会产生多少 USDT 进入虚拟资产网络。USDT 可以直接在虚拟货币交易所与比特币等其他区块链资产进行交易。&lt;/p&gt;
&lt;p&gt;Tether 可以直接在二级市场流通，是数字货币交易市场重要的交易入口。另外，Tether 可能存在被冻结和没收的风险。&lt;/p&gt;
&lt;h3 id=&#34;186-国内的公有区块链项目&#34;&gt;1.8.6 国内的公有区块链项目
&lt;/h3&gt;&lt;p&gt;中国的公链项目不多，分别有 NEO、量子链、元界、公信宝、比原链。&lt;/p&gt;
&lt;p&gt;目前市值最高的是 NEO，NEO 的前身是小蚁，在经历了 2017 年初的市值低谷之后，NEO 通过品牌重塑以及市场推广，目前已经稳居市值 Top10。&lt;/p&gt;
&lt;p&gt;NEO 主打的也是智能合约，不过相比以太坊，NEO 更有方向性，旨在通过智能合约塑造一个基于区块链的智能经济。NEO 的创始人达鸿飞，也是一个非常 Nice 的大叔。&lt;/p&gt;
&lt;p&gt;量子链是也是国内比较知名的区块链项目，它的市值稳居 Top20，与 NEO 不同的是，量子链完全支持以太坊智能合约，也就是说能在以太坊上运行的智能合约也能在量子链上运行。&lt;/p&gt;
&lt;p&gt;量子链的创始人是戴旭光，人称帅初，是一个不到 30 岁就登上福布斯的技术极客。&lt;/p&gt;
&lt;p&gt;元界在 2017 年初上线造成了一波市场轰动，元界是当时唯一一家既能提供数字货币交易平台服务，又能提供公链技术服务的技术团队，2017 上半年整个市场非常看好。
随即创始人初夏虎基于元界发了两个代币，由于这两个代币的运作没有跟上，导致市场恶评不断，再经过 9.4 的一刀切式监管，元界项目坠入低谷。&lt;/p&gt;
&lt;p&gt;公信宝是比特股社区的开发者，将比特股的底层技术石墨烯技术改造成属于自己的公链项目，公信宝团队是一个靠谱的团队，市场价值也十分不错。&lt;/p&gt;
&lt;p&gt;比原链是巴比特社区创始人长铗发起的，比原链目前负责人是段新星，比原链也是一个致力于打造资产数字化，提供资产流通的一个公链平台。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>LeetCode 2:Add Two Numbers</title>
        <link>https://zhenyu0324.github.io/p/leetcode-2add-two-numbers/</link>
        <pubDate>Wed, 13 Jan 2021 21:13:54 +0800</pubDate>
        
        <guid>https://zhenyu0324.github.io/p/leetcode-2add-two-numbers/</guid>
        <description>&lt;h1 id=&#34;两数相加&#34;&gt;两数相加
&lt;/h1&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode.com/problems/add-two-numbers/description/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;两数相加&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。&lt;/p&gt;
&lt;p&gt;请你将两个数相加，并以相同形式返回一个表示和的链表。&lt;/p&gt;
&lt;p&gt;你可以假设除了数字 0 之外，这两个数都不会以 0 开头。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;p&gt;输入：l1 = [2,4,3], l2 = [5,6,4]&lt;/p&gt;
&lt;p&gt;输出：[7,0,8]&lt;/p&gt;
&lt;p&gt;解释：342 + 465 = 807.&lt;/p&gt;
&lt;p&gt;示例 2：&lt;/p&gt;
&lt;p&gt;输入：l1 = [0], l2 = [0]&lt;/p&gt;
&lt;p&gt;输出：[0]&lt;/p&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; public ListNode addTwoNumbers2(ListNode l1, ListNode l2) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        if (l1 == null || l2 == null) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            return null;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        ListNode head = new ListNode(-1);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        boolean upFlag = false;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        while (l1 != null || l2 != null) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            int val1 = l1 != null ? l1.val : 0;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            int val2 = l2 != null ? l2.val : 0;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            int num = val1 + val2;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            if (upFlag) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                num += 1;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            if (num &amp;gt; 9) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                upFlag = true;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                num = num % 10;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            } else {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                upFlag = false;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            insertIntoList(head, new ListNode(num));
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            if (l1 != null) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                l1 = l1.next;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            if (l2 != null) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                l2 = l2.next;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        if (upFlag) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            insertIntoList(head,new ListNode(1));
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        return head.next;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    private void insertIntoList(ListNode head, ListNode node) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        if (head == null || node == null) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            return;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        ListNode tail = head;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        while (tail.next != null) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            tail = tail.next;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        node.next = null;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        tail.next = node;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
        </item>
        <item>
        <title>LeetCode 1:two number sum</title>
        <link>https://zhenyu0324.github.io/p/leetcode-1two-number-sum/</link>
        <pubDate>Wed, 13 Jan 2021 18:13:54 +0800</pubDate>
        
        <guid>https://zhenyu0324.github.io/p/leetcode-1two-number-sum/</guid>
        <description>&lt;h1 id=&#34;两数之和&#34;&gt;两数之和
&lt;/h1&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://leetcode.com/problems/two-sum/description/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;两数之和&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。&lt;/p&gt;
&lt;p&gt;你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。&lt;/p&gt;
&lt;p&gt;你可以按任意顺序返回答案。&lt;/p&gt;
&lt;p&gt;示例 1：&lt;/p&gt;
&lt;p&gt;输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
示例 2：&lt;/p&gt;
&lt;p&gt;输入：nums = [3,2,4], target = 6
输出：[1,2]
示例 3：&lt;/p&gt;
&lt;p&gt;输入：nums = [3,3], target = 6
输出：[0,1]&lt;/p&gt;
&lt;p&gt;提示：&lt;/p&gt;
&lt;p&gt;2 &amp;lt;= nums.length &amp;lt;= 103&lt;/p&gt;
&lt;p&gt;-109 &amp;lt;= nums[i] &amp;lt;= 109&lt;/p&gt;
&lt;p&gt;-109 &amp;lt;= target &amp;lt;= 109&lt;/p&gt;
&lt;p&gt;只会存在一个有效答案&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-fallback&#34; data-lang=&#34;fallback&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;public int[] twoSum(int[] nums, int target) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        if (nums == null || nums.length &amp;lt; 2) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            return null;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        Map&amp;lt;Integer, Integer&amp;gt; numberArrayMap = new HashMap&amp;lt;Integer, Integer&amp;gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        for (int i = 0; i &amp;lt; nums.length; i++) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            numberArrayMap.put(nums[i], i);
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        for (int i = 0; i &amp;lt; nums.length; i++) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            int difference = target - nums[i];
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            if (numberArrayMap.keySet().contains(difference)&amp;amp;&amp;amp;numberArrayMap.get(difference)!=i) {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;                return new int[]{i, numberArrayMap.get(difference)};
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        return null;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
        </item>
        <item>
        <title>Chinese Test</title>
        <link>https://zhenyu0324.github.io/p/test-chinese/</link>
        <pubDate>Wed, 09 Sep 2020 00:00:00 +0000</pubDate>
        
        <guid>https://zhenyu0324.github.io/p/test-chinese/</guid>
        <description>&lt;img src="https://zhenyu0324.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash.jpg" alt="Featured image of post Chinese Test" /&gt;&lt;h2 id=&#34;正文测试&#34;&gt;正文测试
&lt;/h2&gt;&lt;p&gt;而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。&lt;/p&gt;
&lt;p&gt;奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。&lt;/p&gt;
&lt;h2 id=&#34;引用&#34;&gt;引用
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;思念是最暖的忧伤像一双翅膀&lt;br&gt;
让我停不了飞不远在过往游荡&lt;br&gt;
不告而别的你 就算为了我着想&lt;br&gt;
这么沉痛的呵护 我怎么能翱翔&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.youtube.com/watch?v=3aypp_YlBzI&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;最暖的憂傷 - 田馥甄&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;图片&#34;&gt;图片
&lt;/h2&gt;&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/test-chinese/florian-klauer-nptLmg6jqDo-unsplash.jpg&#34;
	width=&#34;667&#34;
	height=&#34;1000&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/test-chinese/florian-klauer-nptLmg6jqDo-unsplash_hu_e98fca2b4272416e.jpg 480w, https://zhenyu0324.github.io/p/test-chinese/florian-klauer-nptLmg6jqDo-unsplash_hu_e3d37c9ded115b12.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Photo by Florian Klauer on Unsplash&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;66&#34;
		data-flex-basis=&#34;160px&#34;
	
&gt;  &lt;img src=&#34;https://zhenyu0324.github.io/p/test-chinese/luca-bravo-alS7ewQ41M8-unsplash.jpg&#34;
	width=&#34;1000&#34;
	height=&#34;667&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/test-chinese/luca-bravo-alS7ewQ41M8-unsplash_hu_e13c58d5189f892c.jpg 480w, https://zhenyu0324.github.io/p/test-chinese/luca-bravo-alS7ewQ41M8-unsplash_hu_8fc948b7ee525251.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Photo by Luca Bravo on Unsplash&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;149&#34;
		data-flex-basis=&#34;359px&#34;
	
&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://zhenyu0324.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash.jpg&#34;
	width=&#34;1000&#34;
	height=&#34;750&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu_503c0ebcc5245e10.jpg 480w, https://zhenyu0324.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu_48c98de55fb3c999.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Photo by Helena Hertz on Unsplash&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;133&#34;
		data-flex-basis=&#34;320px&#34;
	
&gt;  &lt;img src=&#34;https://zhenyu0324.github.io/p/test-chinese/hudai-gayiran-3Od_VKcDEAA-unsplash.jpg&#34;
	width=&#34;667&#34;
	height=&#34;1000&#34;
	srcset=&#34;https://zhenyu0324.github.io/p/test-chinese/hudai-gayiran-3Od_VKcDEAA-unsplash_hu_f81a3588c5c4a663.jpg 480w, https://zhenyu0324.github.io/p/test-chinese/hudai-gayiran-3Od_VKcDEAA-unsplash_hu_1c52ba2a4ad7b9a0.jpg 1024w&#34;
	loading=&#34;lazy&#34;
	
		alt=&#34;Photo by Hudai Gayiran on Unsplash&#34;
	
	
		class=&#34;gallery-image&#34; 
		data-flex-grow=&#34;66&#34;
		data-flex-basis=&#34;160px&#34;
	
&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-markdown&#34; data-lang=&#34;markdown&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;![&lt;span class=&#34;nt&#34;&gt;Photo by Florian Klauer on Unsplash&lt;/span&gt;](&lt;span class=&#34;na&#34;&gt;florian-klauer-nptLmg6jqDo-unsplash.jpg&lt;/span&gt;)  ![&lt;span class=&#34;nt&#34;&gt;Photo by Luca Bravo on Unsplash&lt;/span&gt;](&lt;span class=&#34;na&#34;&gt;luca-bravo-alS7ewQ41M8-unsplash.jpg&lt;/span&gt;) 
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;![&lt;span class=&#34;nt&#34;&gt;Photo by Helena Hertz on Unsplash&lt;/span&gt;](&lt;span class=&#34;na&#34;&gt;helena-hertz-wWZzXlDpMog-unsplash.jpg&lt;/span&gt;)  ![&lt;span class=&#34;nt&#34;&gt;Photo by Hudai Gayiran on Unsplash&lt;/span&gt;](&lt;span class=&#34;na&#34;&gt;hudai-gayiran-3Od_VKcDEAA-unsplash.jpg&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;相册语法来自 &lt;a class=&#34;link&#34; href=&#34;https://typlog.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Typlog&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Markdown Syntax Guide</title>
        <link>https://zhenyu0324.github.io/p/markdown-syntax-guide/</link>
        <pubDate>Mon, 11 Mar 2019 00:00:00 +0000</pubDate>
        
        <guid>https://zhenyu0324.github.io/p/markdown-syntax-guide/</guid>
        <description>&lt;img src="https://zhenyu0324.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash.jpg" alt="Featured image of post Markdown Syntax Guide" /&gt;&lt;p&gt;This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.&lt;/p&gt;
&lt;h2 id=&#34;headings&#34;&gt;Headings
&lt;/h2&gt;&lt;p&gt;The following HTML &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt;—&lt;code&gt;&amp;lt;h6&amp;gt;&lt;/code&gt; elements represent six levels of section headings. &lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; is the highest section level while &lt;code&gt;&amp;lt;h6&amp;gt;&lt;/code&gt; is the lowest.&lt;/p&gt;
&lt;h1 id=&#34;h1&#34;&gt;H1
&lt;/h1&gt;&lt;h2 id=&#34;h2&#34;&gt;H2
&lt;/h2&gt;&lt;h3 id=&#34;h3&#34;&gt;H3
&lt;/h3&gt;&lt;h4 id=&#34;h4&#34;&gt;H4
&lt;/h4&gt;&lt;h5 id=&#34;h5&#34;&gt;H5
&lt;/h5&gt;&lt;h6 id=&#34;h6&#34;&gt;H6
&lt;/h6&gt;&lt;h2 id=&#34;paragraph&#34;&gt;Paragraph
&lt;/h2&gt;&lt;p&gt;Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.&lt;/p&gt;
&lt;p&gt;Itatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.&lt;/p&gt;
&lt;h2 id=&#34;blockquotes&#34;&gt;Blockquotes
&lt;/h2&gt;&lt;p&gt;The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a &lt;code&gt;footer&lt;/code&gt; or &lt;code&gt;cite&lt;/code&gt; element, and optionally with in-line changes such as annotations and abbreviations.&lt;/p&gt;
&lt;h4 id=&#34;blockquote-without-attribution&#34;&gt;Blockquote without attribution
&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Tiam, ad mint andaepu dandae nostion secatur sequo quae.
&lt;strong&gt;Note&lt;/strong&gt; that you can use &lt;em&gt;Markdown syntax&lt;/em&gt; within a blockquote.&lt;/p&gt;&lt;/blockquote&gt;
&lt;h4 id=&#34;blockquote-with-attribution&#34;&gt;Blockquote with attribution
&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Don&amp;rsquo;t communicate by sharing memory, share memory by communicating.&lt;br&gt;
— &lt;cite&gt;Rob Pike&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/cite&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id=&#34;tables&#34;&gt;Tables
&lt;/h2&gt;&lt;p&gt;Tables aren&amp;rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;Name&lt;/th&gt;
          &lt;th&gt;Age&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;Bob&lt;/td&gt;
          &lt;td&gt;27&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Alice&lt;/td&gt;
          &lt;td&gt;23&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;inline-markdown-within-tables&#34;&gt;Inline Markdown within tables
&lt;/h4&gt;&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;Italics&lt;/th&gt;
          &lt;th&gt;Bold&lt;/th&gt;
          &lt;th&gt;Code&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;em&gt;italics&lt;/em&gt;&lt;/td&gt;
          &lt;td&gt;&lt;strong&gt;bold&lt;/strong&gt;&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;code&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;A&lt;/th&gt;
          &lt;th&gt;B&lt;/th&gt;
          &lt;th&gt;C&lt;/th&gt;
          &lt;th&gt;D&lt;/th&gt;
          &lt;th&gt;E&lt;/th&gt;
          &lt;th&gt;F&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;Lorem ipsum dolor sit amet, consectetur adipiscing elit.&lt;/td&gt;
          &lt;td&gt;Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex.&lt;/td&gt;
          &lt;td&gt;Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus&lt;/td&gt;
          &lt;td&gt;Proin sit amet velit nec enim imperdiet vehicula.&lt;/td&gt;
          &lt;td&gt;Ut bibendum vestibulum quam, eu egestas turpis gravida nec&lt;/td&gt;
          &lt;td&gt;Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;code-blocks&#34;&gt;Code Blocks
&lt;/h2&gt;&lt;h4 id=&#34;code-block-with-backticks&#34;&gt;Code block with backticks
&lt;/h4&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&amp;lt;!doctype html&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;html&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;lang&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;en&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;head&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;meta&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;charset&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;utf-8&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;title&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;Example HTML5 Document&lt;span class=&#34;p&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;title&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;head&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;Test&lt;span class=&#34;p&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;html&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;code-block-indented-with-four-spaces&#34;&gt;Code block indented with four spaces
&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;&amp;lt;!doctype html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
  &amp;lt;title&amp;gt;Example HTML5 Document&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
  &amp;lt;p&amp;gt;Test&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;code-block-with-hugos-internal-highlight-shortcode&#34;&gt;Code block with Hugo&amp;rsquo;s internal highlight shortcode
&lt;/h4&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&amp;lt;!doctype html&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;html&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;lang&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;en&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;head&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;meta&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;charset&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;utf-8&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;title&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;Example HTML5 Document&lt;span class=&#34;p&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;title&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;head&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;Test&lt;span class=&#34;p&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;/&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;html&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h4 id=&#34;diff-code-block&#34;&gt;Diff code block
&lt;/h4&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-diff&#34; data-lang=&#34;diff&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;[dependencies.bevy]
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git = &amp;#34;https://github.com/bevyengine/bevy&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;rev = &amp;#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13&amp;#34;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gd&#34;&gt;- features = [&amp;#34;dynamic&amp;#34;]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;gd&#34;&gt;&lt;/span&gt;&lt;span class=&#34;gi&#34;&gt;+ features = [&amp;#34;jpeg&amp;#34;, &amp;#34;dynamic&amp;#34;]
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;list-types&#34;&gt;List Types
&lt;/h2&gt;&lt;h4 id=&#34;ordered-list&#34;&gt;Ordered List
&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;First item&lt;/li&gt;
&lt;li&gt;Second item&lt;/li&gt;
&lt;li&gt;Third item&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;unordered-list&#34;&gt;Unordered List
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;List item&lt;/li&gt;
&lt;li&gt;Another item&lt;/li&gt;
&lt;li&gt;And another item&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;nested-list&#34;&gt;Nested list
&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Fruit
&lt;ul&gt;
&lt;li&gt;Apple&lt;/li&gt;
&lt;li&gt;Orange&lt;/li&gt;
&lt;li&gt;Banana&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Dairy
&lt;ul&gt;
&lt;li&gt;Milk&lt;/li&gt;
&lt;li&gt;Cheese&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;other-elements--abbr-sub-sup-kbd-mark&#34;&gt;Other Elements — abbr, sub, sup, kbd, mark
&lt;/h2&gt;&lt;p&gt;&lt;abbr title=&#34;Graphics Interchange Format&#34;&gt;GIF&lt;/abbr&gt; is a bitmap image format.&lt;/p&gt;
&lt;p&gt;H&lt;sub&gt;2&lt;/sub&gt;O&lt;/p&gt;
&lt;p&gt;X&lt;sup&gt;n&lt;/sup&gt; + Y&lt;sup&gt;n&lt;/sup&gt; = Z&lt;sup&gt;n&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;Press &lt;kbd&gt;CTRL&lt;/kbd&gt; + &lt;kbd&gt;ALT&lt;/kbd&gt; + &lt;kbd&gt;Delete&lt;/kbd&gt; to end the session.&lt;/p&gt;
&lt;p&gt;Most &lt;mark&gt;salamanders&lt;/mark&gt; are nocturnal, and hunt for insects, worms, and other small creatures.&lt;/p&gt;
&lt;h2 id=&#34;hyperlinked-image&#34;&gt;Hyperlinked image
&lt;/h2&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://google.com&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;img src=&#34;https://www.google.com/images/branding/googlelogo/1x/googlelogo_light_color_272x92dp.png&#34;
	
	
	
	loading=&#34;lazy&#34;
	
		alt=&#34;Google&#34;
	
	
&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;The above quote is excerpted from Rob Pike&amp;rsquo;s &lt;a class=&#34;link&#34; href=&#34;https://www.youtube.com/watch?v=PAAkCSZUG1c&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;talk&lt;/a&gt; during Gopherfest, November 18, 2015.&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;</description>
        </item>
        <item>
        <title>Placeholder Text</title>
        <link>https://zhenyu0324.github.io/p/placeholder-text/</link>
        <pubDate>Sat, 09 Mar 2019 00:00:00 +0000</pubDate>
        
        <guid>https://zhenyu0324.github.io/p/placeholder-text/</guid>
        <description>&lt;img src="https://zhenyu0324.github.io/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash.jpg" alt="Featured image of post Placeholder Text" /&gt;&lt;p&gt;Lorem est tota propiore conpellat pectoribus de pectora summo.&lt;/p&gt;
&lt;p&gt;Redit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Exierant elisi ambit vivere dedere&lt;/li&gt;
&lt;li&gt;Duce pollice&lt;/li&gt;
&lt;li&gt;Eris modo&lt;/li&gt;
&lt;li&gt;Spargitque ferrea quos palude&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Comas hunc haec pietate fetum procerum dixit&lt;/li&gt;
&lt;li&gt;Post torum vates letum Tiresia&lt;/li&gt;
&lt;li&gt;Flumen querellas&lt;/li&gt;
&lt;li&gt;Arcanaque montibus omnes&lt;/li&gt;
&lt;li&gt;Quidem et&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;vagus-elidunt&#34;&gt;Vagus elidunt
&lt;/h1&gt;&lt;p&gt;&lt;svg class=&#34;canon&#34; xmlns=&#34;http://www.w3.org/2000/svg&#34; overflow=&#34;visible&#34; viewBox=&#34;0 0 496 373&#34; height=&#34;373&#34; width=&#34;496&#34;&gt;&lt;g fill=&#34;none&#34;&gt;&lt;path stroke=&#34;#000&#34; stroke-width=&#34;.75&#34; d=&#34;M.599 372.348L495.263 1.206M.312.633l494.95 370.853M.312 372.633L247.643.92M248.502.92l246.76 370.566M330.828 123.869V1.134M330.396 1.134L165.104 124.515&#34;&gt;&lt;/path&gt;&lt;path stroke=&#34;#ED1C24&#34; stroke-width=&#34;.75&#34; d=&#34;M275.73 41.616h166.224v249.05H275.73zM54.478 41.616h166.225v249.052H54.478z&#34;&gt;&lt;/path&gt;&lt;path stroke=&#34;#000&#34; stroke-width=&#34;.75&#34; d=&#34;M.479.375h495v372h-495zM247.979.875v372&#34;&gt;&lt;/path&gt;&lt;ellipse cx=&#34;498.729&#34; cy=&#34;177.625&#34; rx=&#34;.75&#34; ry=&#34;1.25&#34;&gt;&lt;/ellipse&gt;&lt;ellipse cx=&#34;247.229&#34; cy=&#34;377.375&#34; rx=&#34;.75&#34; ry=&#34;1.25&#34;&gt;&lt;/ellipse&gt;&lt;/g&gt;&lt;/svg&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Canons_of_page_construction#Van_de_Graaf_canon&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;The Van de Graaf Canon&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;mane-refeci-capiebant-unda-mulcebat&#34;&gt;Mane refeci capiebant unda mulcebat
&lt;/h2&gt;&lt;p&gt;Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. &lt;strong&gt;Faces illo pepulere&lt;/strong&gt; tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.&lt;/p&gt;
&lt;p&gt;Iubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.&lt;/p&gt;
&lt;p&gt;Eurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel &lt;strong&gt;mitis temploque&lt;/strong&gt; vocatus, inque alis, &lt;em&gt;oculos nomen&lt;/em&gt; non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides &lt;strong&gt;parte&lt;/strong&gt;.&lt;/p&gt;</description>
        </item>
        <item>
        <title>Math Typesetting</title>
        <link>https://zhenyu0324.github.io/p/math-typesetting/</link>
        <pubDate>Fri, 08 Mar 2019 00:00:00 +0000</pubDate>
        
        <guid>https://zhenyu0324.github.io/p/math-typesetting/</guid>
        <description>&lt;p&gt;Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.&lt;/p&gt;
&lt;p&gt;In this example we will be using &lt;a class=&#34;link&#34; href=&#34;https://katex.org/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;KaTeX&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Create a partial under &lt;code&gt;/layouts/partials/math.html&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Within this partial reference the &lt;a class=&#34;link&#34; href=&#34;https://katex.org/docs/autorender.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Auto-render Extension&lt;/a&gt; or host these scripts locally.&lt;/li&gt;
&lt;li&gt;Include the partial in your templates like so:&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;{{&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; or .Params.math .Site.Params.math &lt;span class=&#34;o&#34;&gt;}}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;{{&lt;/span&gt; partial &lt;span class=&#34;s2&#34;&gt;&amp;#34;math.html&amp;#34;&lt;/span&gt; . &lt;span class=&#34;o&#34;&gt;}}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;o&#34;&gt;{{&lt;/span&gt; end &lt;span class=&#34;o&#34;&gt;}}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;To enable KaTeX globally set the parameter &lt;code&gt;math&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; in a project&amp;rsquo;s configuration&lt;/li&gt;
&lt;li&gt;To enable KaTeX on a per page basis include the parameter &lt;code&gt;math: true&lt;/code&gt; in content files&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; Use the online reference of &lt;a class=&#34;link&#34; href=&#34;https://katex.org/docs/supported.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Supported TeX Functions&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&#34;examples&#34;&gt;Examples
&lt;/h3&gt;&lt;p&gt;Inline math: $\varphi = \dfrac{1+\sqrt5}{2}= 1.6180339887…$&lt;/p&gt;
&lt;p&gt;Block math:
&lt;/p&gt;
$$
 \varphi = 1+\frac{1} {1+\frac{1} {1+\frac{1} {1+\cdots} } } 
$$</description>
        </item>
        <item>
        <title>Emoji Support</title>
        <link>https://zhenyu0324.github.io/p/emoji-support/</link>
        <pubDate>Tue, 05 Mar 2019 00:00:00 +0000</pubDate>
        
        <guid>https://zhenyu0324.github.io/p/emoji-support/</guid>
        <description>&lt;img src="https://zhenyu0324.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash.jpg" alt="Featured image of post Emoji Support" /&gt;&lt;p&gt;Emoji can be enabled in a Hugo project in a number of ways.&lt;/p&gt;
&lt;p&gt;The &lt;a class=&#34;link&#34; href=&#34;https://gohugo.io/functions/emojify/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;code&gt;emojify&lt;/code&gt;&lt;/a&gt; function can be called directly in templates or &lt;a class=&#34;link&#34; href=&#34;https://gohugo.io/templates/shortcode-templates/#inline-shortcodes&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Inline Shortcodes&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;To enable emoji globally, set &lt;code&gt;enableEmoji&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; in your site&amp;rsquo;s &lt;a class=&#34;link&#34; href=&#34;https://gohugo.io/getting-started/configuration/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;configuration&lt;/a&gt; and then you can type emoji shorthand codes directly in content files; e.g.&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;nowrap&#34;&gt;&lt;span class=&#34;emojify&#34;&gt;🙈&lt;/span&gt; &lt;code&gt;:see_no_evil:&lt;/code&gt;&lt;/span&gt;  &lt;span class=&#34;nowrap&#34;&gt;&lt;span class=&#34;emojify&#34;&gt;🙉&lt;/span&gt; &lt;code&gt;:hear_no_evil:&lt;/code&gt;&lt;/span&gt;  &lt;span class=&#34;nowrap&#34;&gt;&lt;span class=&#34;emojify&#34;&gt;🙊&lt;/span&gt; &lt;code&gt;:speak_no_evil:&lt;/code&gt;&lt;/span&gt;&lt;/p&gt;
&lt;br&gt;
&lt;p&gt;The &lt;a class=&#34;link&#34; href=&#34;http://www.emoji-cheat-sheet.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Emoji cheat sheet&lt;/a&gt; is a useful reference for emoji shorthand codes.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;N.B.&lt;/strong&gt; The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-html&#34; data-lang=&#34;html&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;.emoji {
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description>
        </item>
        <item>
        <title>[中文] 《长恨歌》</title>
        <link>https://zhenyu0324.github.io/p/%E4%B8%AD%E6%96%87-%E9%95%BF%E6%81%A8%E6%AD%8C/</link>
        <pubDate>Wed, 30 Aug 2017 01:37:56 +0800</pubDate>
        
        <guid>https://zhenyu0324.github.io/p/%E4%B8%AD%E6%96%87-%E9%95%BF%E6%81%A8%E6%AD%8C/</guid>
        <description>&lt;blockquote&gt;
&lt;p&gt;《长恨歌》是中国唐朝诗人白居易的一首长篇叙事诗。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h1 id=&#34;第一段贵妃受宠爱&#34;&gt;第一段：贵妃受宠爱
&lt;/h1&gt;&lt;p&gt;汉皇重色思倾国，御宇多年求不得。杨家有女初长成，养在深闺人未识。&lt;/p&gt;
&lt;p&gt;天生丽质难自弃，一朝选在君王侧。回眸一笑百媚生，六宫粉黛无颜色。&lt;/p&gt;
&lt;p&gt;春寒赐浴华清池，温泉水滑洗凝脂。侍儿扶起娇无力，始是新承恩泽时。&lt;/p&gt;
&lt;p&gt;云鬓花颜金步摇，芙蓉帐暖度春宵。春宵苦短日高起，从此君王不早朝。&lt;/p&gt;
&lt;p&gt;承欢侍宴无闲暇，春从春游夜专夜。后宫佳丽三千人，三千宠爱在一身。&lt;/p&gt;
&lt;p&gt;金屋妆成娇侍夜，玉楼宴罢醉和春。姊妹弟兄皆列士，可怜光彩生门户。&lt;/p&gt;
&lt;p&gt;遂令天下父母心，不重生男重生女。骊宫高处入青云，仙乐风飘处处闻。&lt;/p&gt;
&lt;p&gt;缓歌慢舞凝丝竹，尽日君王看不足。渔阳鼙鼓动地来，惊破霓裳羽衣曲。&lt;/p&gt;
&lt;h1 id=&#34;第二段马嵬惊变&#34;&gt;第二段：马嵬惊变
&lt;/h1&gt;&lt;p&gt;九重城阙烟尘生，千乘万骑西南行。翠华摇摇行复止，西出都门百余里。&lt;/p&gt;
&lt;p&gt;六军不发无奈何，宛转蛾眉马前死。花钿委地无人收，翠翘金雀玉搔头。&lt;/p&gt;
&lt;p&gt;君王掩面救不得，回看血泪相和流。黄埃散漫风萧索，云栈萦纡登剑阁。&lt;/p&gt;
&lt;p&gt;峨嵋山下少人行，旌旗无光日色薄。蜀江水碧蜀山青，圣主朝朝暮暮情。&lt;/p&gt;
&lt;p&gt;行宫见月伤心色，夜雨闻铃肠断声。&lt;/p&gt;
&lt;h1 id=&#34;第三段玄宗皇帝思念&#34;&gt;第三段：玄宗皇帝思念
&lt;/h1&gt;&lt;p&gt;天旋地转回龙驭，到此踌躇不能去。马嵬坡下泥土中，不见玉颜空死处。&lt;/p&gt;
&lt;p&gt;君臣相顾尽霑衣，东望都门信马归。归来池苑皆依旧，太液芙蓉未央柳。&lt;/p&gt;
&lt;p&gt;芙蓉如面柳如眉，对此如何不泪垂。春风桃李花开日，秋雨梧桐叶落时。&lt;/p&gt;
&lt;p&gt;西宫南内多秋草，落叶满阶红不扫。梨园弟子白发新，椒房阿监青娥老。&lt;/p&gt;
&lt;p&gt;夕殿萤飞思悄然，孤灯挑尽未成眠。迟迟钟鼓初长夜，耿耿星河欲曙天。&lt;/p&gt;
&lt;p&gt;鸳鸯瓦冷霜华重，翡翠衾寒谁与共。悠悠生死别经年，魂魄不曾来入梦。&lt;/p&gt;
&lt;h1 id=&#34;第四段仙界寻妃&#34;&gt;第四段：仙界寻妃
&lt;/h1&gt;&lt;p&gt;临邛道士鸿都客，能以精诚致魂魄。为感君王辗转思，遂教方士殷勤觅。&lt;/p&gt;
&lt;p&gt;排空驭气奔如电，升天入地求之遍。上穷碧落下黄泉，两处茫茫皆不见。&lt;/p&gt;
&lt;p&gt;忽闻海上有仙山，山在虚无缥缈间。楼阁玲珑五云起，其中绰约多仙子。&lt;/p&gt;
&lt;p&gt;中有一人字太真，雪肤花貌参差是。金阙西厢叩玉扃，转教小玉报双成。&lt;/p&gt;
&lt;p&gt;闻道汉家天子使，九华帐里梦魂惊。揽衣推枕起徘徊，珠箔银屏迤逦开。&lt;/p&gt;
&lt;p&gt;云髻(鬓?)半偏新睡觉，花冠不整下堂来。风吹仙袂飘飘(飖)举，犹似霓裳羽衣舞。&lt;/p&gt;
&lt;p&gt;玉容寂寞泪阑干，梨花一枝春带雨。含情凝睇谢君王，一别音容两渺茫。&lt;/p&gt;
&lt;p&gt;昭阳殿里恩爱绝，蓬莱宫中日月长。回头下望人寰处，不见长安见尘雾。&lt;/p&gt;
&lt;p&gt;唯将旧物表深情，钿合金钗寄将去。钗留一股合一扇，钗擘黄金合分钿。&lt;/p&gt;
&lt;p&gt;但教心似金钿坚，天上人间会相见。临别殷勤重寄词，词中有誓两心知。&lt;/p&gt;
&lt;p&gt;七月七日长生殿，夜半无人私语时。在天愿作比翼鸟，在地愿为连理枝。&lt;/p&gt;
&lt;p&gt;天长地久有时尽，此恨绵绵无绝期。&lt;/p&gt;
</description>
        </item>
        
    </channel>
</rss>
